var tipuesearch = {"pages":[{"text":"FFTXlib A self-contained library for handling FFT in QE","tags":"","loc":"index.html","title":" FFTXlib "},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !---------------------------------------------------------------------------- SUBROUTINE fftx_error__ ( calling_routine , message , ierr ) !---------------------------------------------------------------------------- ! ! ... This is a simple routine which writes an error message to output: ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! CHARACTER ( LEN =* ), INTENT ( IN ) :: calling_routine , message ! the name of the calling calling_routine ! the output message INTEGER , INTENT ( IN ) :: ierr ! CHARACTER ( LEN = 6 ) :: cerr INTEGER :: info ! IF ( ierr <= 0 ) THEN RETURN END IF ! ! ... the error message is written un the \"*\" unit ! WRITE ( cerr , FMT = '(I6)' ) ierr WRITE ( UNIT = * , FMT = '(/,1X,78(\"%\"))' ) WRITE ( UNIT = * , FMT = '(5X,\"Error in routine \",A,\" (\",A,\"):\")' ) & TRIM ( calling_routine ), TRIM ( ADJUSTL ( cerr )) WRITE ( UNIT = * , FMT = '(5X,A)' ) TRIM ( message ) WRITE ( UNIT = * , FMT = '(1X,78(\"%\"),/)' ) ! WRITE ( * , '(\"     stopping ...\")' ) ! #if defined(__MPI) ! CALL mpi_abort ( MPI_COMM_WORLD , ierr , info ) ! #endif ! STOP 1 ! RETURN ! END SUBROUTINE fftx_error__","tags":"","loc":"sourcefile/fft_error.f90.html","title":"fft_error.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=---------------------------------------------------------------------------=! MODULE fft_interfaces !=-------------------------------------------------------------------------=! IMPLICIT NONE PRIVATE PUBLIC :: fwfft , invfft INTERFACE invfft ! ! invfft is the interface to both the \"normal\" fft invfft_x, ! and to the \"box-grid\" version invfft_, used only in CP ! The latter has an additional argument ! SUBROUTINE invfft_x ( grid_type , f , dfft ) USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft COMPLEX ( DP ) :: f (:) END SUBROUTINE invfft_x ! SUBROUTINE invfft_b ( grid_type , f , dfft , ia ) USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) INTEGER , INTENT ( IN ) :: ia CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft COMPLEX ( DP ) :: f (:) END SUBROUTINE invfft_b END INTERFACE INTERFACE fwfft SUBROUTINE fwfft_x ( grid_type , f , dfft ) USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft COMPLEX ( DP ) :: f (:) END SUBROUTINE fwfft_x END INTERFACE !=--------------------------------------------------------------------------=! END MODULE fft_interfaces !=---------------------------------------------------------------------------=! ! !----------------------------------------------------------------------- SUBROUTINE invfft_x ( grid_type , f , dfft ) !----------------------------------------------------------------------- ! grid_type = 'Dense' !   inverse fourier transform of potentials and charge density f !   on the dense grid . On output, f is overwritten ! grid_type = 'Smooth' !   inverse fourier transform of  potentials and charge density f !   on the smooth grid . On output, f is overwritten ! grid_type = 'Wave' !   inverse fourier transform of  wave functions f !   on the smooth grid . On output, f is overwritten ! grid_type = 'Custom' !   inverse fourier transform of potentials and charge density f !   on a custom grid. On output, f is overwritten ! grid_type = 'CustomWave' !   inverse fourier transform of  wave functions f !   on a custom grid. On output, f is overwritten ! ! dfft = FFT descriptor, IMPORTANT NOTICE: grid is specified only by dfft. ! No check is performed on the correspondence between dfft and grid_type. ! grid_type is now used only to distinguish cases 'Wave' / 'CustomWave' ! from all other cases ! USE fft_scalar , ONLY : cfft3d , cfft3ds USE fft_smallbox , ONLY : cft_b , cft_b_omp USE fft_parallel , ONLY : tg_cft3s USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type COMPLEX ( DP ) :: f (:) ! IF ( grid_type == 'Dense' ) THEN CALL start_clock ( 'fft' ) ELSE IF ( grid_type == 'Smooth' ) THEN CALL start_clock ( 'ffts' ) ELSE IF ( grid_type == 'Wave' ) THEN CALL start_clock ( 'fftw' ) ELSE IF ( grid_type == 'Box' ) THEN CALL fftx_error__ ( ' invfft ' , ' incorrect CALL for Box fft ' , 1 ) ELSE IF ( grid_type == 'Custom' ) THEN CALL start_clock ( 'fftc' ) ELSE IF ( grid_type == 'CustomWave' ) THEN CALL start_clock ( 'fftcw' ) ELSE CALL fftx_error__ ( ' invfft ' , ' unknown grid: ' // grid_type , 1 ) END IF #if defined(__MPI) && !defined __USE_3D_FFT IF ( grid_type == 'Dense' . OR . grid_type == 'Smooth' . OR . & grid_type == 'Custom' ) THEN CALL tg_cft3s ( f , dfft , 1 ) ELSE IF ( grid_type == 'Wave' . OR . grid_type == 'CustomWave' ) THEN CALL tg_cft3s ( f , dfft , 2 , dfft % have_task_groups ) END IF #else IF ( grid_type == 'Dense' . OR . grid_type == 'Smooth' . OR . & grid_type == 'Custom' ) THEN CALL cfft3d ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , 1 ) ELSE IF ( grid_type == 'Wave' . OR . grid_type == 'CustomWave' ) THEN #if defined(__MPI) && defined __USE_3D_FFT CALL cfft3d ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , 1 ) #else CALL cfft3ds ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , 1 , & dfft % isind , dfft % iplw ) #endif END IF #endif IF ( grid_type == 'Dense' ) THEN CALL stop_clock ( 'fft' ) ELSE IF ( grid_type == 'Smooth' ) THEN CALL stop_clock ( 'ffts' ) ELSE IF ( grid_type == 'Wave' ) THEN CALL stop_clock ( 'fftw' ) ELSE IF ( grid_type == 'Custom' ) THEN CALL stop_clock ( 'fftc' ) ELSE IF ( grid_type == 'CustomWave' ) THEN CALL stop_clock ( 'fftcw' ) END IF RETURN END SUBROUTINE invfft_x !----------------------------------------------------------------------- SUBROUTINE fwfft_x ( grid_type , f , dfft ) !----------------------------------------------------------------------- ! grid_type = 'Dense' !   forward fourier transform of potentials and charge density f !   on the dense grid . On output, f is overwritten ! grid_type = 'Smooth' !   forward fourier transform of potentials and charge density f !   on the smooth grid . On output, f is overwritten ! grid_type = 'Wave' !   forward fourier transform of  wave functions f !   on the smooth grid . On output, f is overwritten ! grid_type = 'Custom' !   forward fourier transform of potentials and charge density f !   on a custom grid . On output, f is overwritten ! grid_type = 'CustomWave' !   forward fourier transform of  wave functions !   on a custom grid . On output, f is overwritten ! ! dfft = FFT descriptor, IMPORTANT NOTICE: grid is specified only by dfft. ! No check is performed on the correspondence between dfft and grid_type. ! grid_type is now used only to distinguish cases 'Wave' / 'CustomWave' ! from all other cases ! USE fft_scalar , ONLY : cfft3d , cfft3ds USE fft_parallel , ONLY : tg_cft3s USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type COMPLEX ( DP ) :: f (:) IF ( grid_type == 'Dense' ) THEN CALL start_clock ( 'fft' ) ELSE IF ( grid_type == 'Smooth' ) THEN CALL start_clock ( 'ffts' ) ELSE IF ( grid_type == 'Wave' ) THEN CALL start_clock ( 'fftw' ) ELSE IF ( grid_type == 'Custom' ) THEN CALL start_clock ( 'fftc' ) ELSE IF ( grid_type == 'CustomWave' ) THEN CALL start_clock ( 'fftcw' ) ELSE CALL fftx_error__ ( ' fwfft ' , ' unknown grid: ' // grid_type , 1 ) END IF #if defined(__MPI) && !defined(__USE_3D_FFT) IF ( grid_type == 'Dense' . OR . grid_type == 'Smooth' . OR . & grid_type == 'Custom' ) THEN CALL tg_cft3s ( f , dfft , - 1 ) ELSE IF ( grid_type == 'Wave' . OR . grid_type == 'CustomWave' ) THEN CALL tg_cft3s ( f , dfft , - 2 , dfft % have_task_groups ) END IF #else IF ( grid_type == 'Dense' . OR . grid_type == 'Smooth' . OR . & grid_type == 'Custom' ) THEN CALL cfft3d ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , - 1 ) ELSE IF ( grid_type == 'Wave' . OR . grid_type == 'CustomWave' ) THEN #if defined(__MPI) && defined(__USE_3D_FFT) CALL cfft3d ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , - 1 ) #else CALL cfft3ds ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , - 1 , & dfft % isind , dfft % iplw ) #endif END IF #endif IF ( grid_type == 'Dense' ) THEN CALL stop_clock ( 'fft' ) ELSE IF ( grid_type == 'Smooth' ) THEN CALL stop_clock ( 'ffts' ) ELSE IF ( grid_type == 'Wave' ) THEN CALL stop_clock ( 'fftw' ) ELSE IF ( grid_type == 'Custom' ) THEN CALL stop_clock ( 'fftc' ) ELSE IF ( grid_type == 'CustomWave' ) THEN CALL stop_clock ( 'fftcw' ) END IF RETURN ! END SUBROUTINE fwfft_x !----------------------------------------------------------------------- SUBROUTINE invfft_b ( grid_type , f , dfft , ia ) !----------------------------------------------------------------------- !   not-so-parallel 3d fft for box grid, implemented ONLY for sign=1 !   G-space to R-space, output = \\sum_G f(G)exp(+iG*R) !   The array f (overwritten on output) is NOT distributed: !   a copy is present on each processor. !   The fft along z  is done on the entire grid. !   The fft along xy is done ONLY on planes that have components on the !   dense grid for each processor. Note that the final array will no !   longer be the same on all processors. !   grid_type = 'Box' (only allowed value!) !   dfft = fft descriptor for the box grid !   ia   = index of the atom with a box grid. Used to find the number !          of planes on this processors, contained in dfft%np3(ia) ! USE fft_scalar , ONLY : cfft3d , cfft3ds USE fft_smallbox , ONLY : cft_b , cft_b_omp USE fft_parallel , ONLY : tg_cft3s USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft ! Removed the 'OPTIONAL' attribute. When present, the specific interfaces ! 'invfft_x' and 'invfft_b' cannot be disambiguated when the generic interface ! call is made. This is a violation the Fortran standard. The Cray compiler ! errors out on this, while the Intel only issues a warning. --rbw ! INTEGER, OPTIONAL, INTENT(IN) :: ia INTEGER , INTENT ( IN ) :: ia CHARACTER ( LEN =* ), INTENT ( IN ) :: grid_type COMPLEX ( DP ) :: f (:) ! INTEGER :: imin3 , imax3 , np3 IF ( grid_type /= 'Box' ) & CALL fftx_error__ ( ' invfft ' , ' inconsistent call for Box fft ' , 1 ) ! clocks called inside a parallel region do not work properly! ! in the future we probably need a thread safe version of the clock !$omp master CALL start_clock ( 'fftb' ) !$omp end master #if defined(__MPI) && !defined(__USE_3D_FFT) IF ( dfft % np3 ( ia ) > 0 ) THEN #if defined(__OPENMP) CALL cft_b_omp ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , & dfft % imin3 ( ia ), dfft % imax3 ( ia ), 1 ) #else CALL cft_b ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , & dfft % imin3 ( ia ), dfft % imax3 ( ia ), 1 ) #endif END IF #else #if defined(__OPENMP) CALL cft_b_omp ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , & dfft % imin3 ( ia ), dfft % imax3 ( ia ), 1 ) #else CALL cfft3d ( f , dfft % nr1 , dfft % nr2 , dfft % nr3 , & dfft % nr1x , dfft % nr2x , dfft % nr3x , 1 ) #endif #endif !$omp master CALL stop_clock ( 'fftb' ) !$omp end master RETURN END SUBROUTINE invfft_b","tags":"","loc":"sourcefile/fft_interfaces.f90.html","title":"fft_interfaces.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=---------------------------------------------------------------------==! ! ! !     Parallel 3D FFT high level Driver !     ( Charge density and Wave Functions ) ! !     Written and maintained by Carlo Cavazzoni !     Last update Apr. 2009 ! !=---------------------------------------------------------------------==! ! MODULE fft_parallel ! IMPLICIT NONE SAVE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) PRIVATE :: DP ! CONTAINS ! !  General purpose driver, including Task groups parallelization ! !---------------------------------------------------------------------------- SUBROUTINE tg_cft3s ( f , dfft , isgn , use_task_groups ) !---------------------------------------------------------------------------- ! ! ... isgn = +-1 : parallel 3d fft for rho and for the potential !                  NOT IMPLEMENTED WITH TASK GROUPS ! ... isgn = +-2 : parallel 3d fft for wavefunctions ! ! ... isgn = +   : G-space to R-space, output = \\sum_G f(G)exp(+iG*R) ! ...              fft along z using pencils        (cft_1z) ! ...              transpose across nodes           (fft_scatter) ! ...                 and reorder ! ...              fft along y (using planes) and x (cft_2xy) ! ... isgn = -   : R-space to G-space, output = \\int_R f(R)exp(-iG*R)/Omega ! ...              fft along x and y(using planes)  (cft_2xy) ! ...              transpose across nodes           (fft_scatter) ! ...                 and reorder ! ...              fft along z using pencils        (cft_1z) ! ! ...  The array \"planes\" signals whether a fft is needed along y : ! ...    planes(i)=0 : column f(i,*,*) empty , don't do fft along y ! ...    planes(i)=1 : column f(i,*,*) filled, fft along y needed ! ...  \"empty\" = no active components are present in f(i,*,*) ! ...            after (isgn>0) or before (isgn<0) the fft on z direction ! ! ...  Note that if isgn=+/-1 (fft on rho and pot.) all fft's are needed ! ...  and all planes(i) are set to 1 ! ! This driver is based on code written by Stefano de Gironcoli for PWSCF. ! Task Group added by Costas Bekas, Oct. 2005, adapted from the CPMD code ! (Alessandro Curioni) and revised by Carlo Cavazzoni 2007. ! USE fft_scalar , ONLY : cft_1z , cft_2xy USE scatter_mod , ONLY : fft_scatter USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! COMPLEX ( DP ), INTENT ( inout ) :: f ( : ) ! array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout INTEGER , INTENT ( in ) :: isgn ! fft direction LOGICAL , OPTIONAL , INTENT ( in ) :: use_task_groups ! specify if you want to use task groups parallelization ! ! the following ifdef prevents usage of directive in older ifort versions ! #if defined(__INTEL_COMPILER) #if __INTEL_COMPILER  >= 1300 ! the following is a workaround for Intel 12.1 bug #if __INTEL_COMPILER  < 9999 !dir$ attributes align: 4096 :: yf, aux #endif #endif #endif INTEGER :: me_p INTEGER :: n1 , n2 , n3 , nx1 , nx2 , nx3 COMPLEX ( DP ), ALLOCATABLE :: yf (:), aux (:) INTEGER :: planes ( dfft % nr1x ) LOGICAL :: use_tg ! ! IF ( present ( use_task_groups ) ) THEN use_tg = use_task_groups ELSE use_tg = . false . ENDIF ! IF ( use_tg . and . . not . dfft % have_task_groups ) & CALL fftx_error__ ( ' tg_cft3s ' , ' call requiring task groups for a descriptor without task groups ' , 1 ) ! n1 = dfft % nr1 n2 = dfft % nr2 n3 = dfft % nr3 nx1 = dfft % nr1x nx2 = dfft % nr2x nx3 = dfft % nr3x ! IF ( use_tg ) THEN ALLOCATE ( aux ( dfft % nogrp * dfft % tg_nnr ) ) ALLOCATE ( YF ( dfft % nogrp * dfft % tg_nnr ) ) ELSE ALLOCATE ( aux ( dfft % nnr ) ) ENDIF ! me_p = dfft % mype + 1 ! IF ( isgn > 0 ) THEN ! IF ( isgn /= 2 ) THEN ! IF ( use_tg ) & CALL fftx_error__ ( ' tg_cft3s ' , ' task groups on large mesh not implemented ' , 1 ) ! CALL cft_1z ( f , dfft % nsp ( me_p ), n3 , nx3 , isgn , aux ) ! planes = dfft % iplp ! ELSE ! IF ( use_tg ) THEN CALL pack_group_sticks ( f , yf , dfft ) CALL cft_1z ( yf , dfft % tg_nsw ( me_p ), n3 , nx3 , isgn , aux ) ELSE CALL cft_1z ( f , dfft % nsw ( me_p ), n3 , nx3 , isgn , aux ) ENDIF ! planes = dfft % iplw ! ENDIF ! CALL fw_scatter ( isgn ) ! forward scatter from stick to planes ! IF ( use_tg ) THEN CALL cft_2xy ( f , dfft % tg_npp ( me_p ), n1 , n2 , nx1 , nx2 , isgn , planes ) ELSE CALL cft_2xy ( f , dfft % npp ( me_p ), n1 , n2 , nx1 , nx2 , isgn , planes ) ENDIF ! ELSE ! IF ( isgn /= - 2 ) THEN ! IF ( use_tg ) & CALL fftx_error__ ( ' tg_cft3s ' , ' task groups on large mesh not implemented ' , 1 ) ! planes = dfft % iplp ! ELSE ! planes = dfft % iplw ! ENDIF IF ( use_tg ) THEN CALL cft_2xy ( f , dfft % tg_npp ( me_p ), n1 , n2 , nx1 , nx2 , isgn , planes ) ELSE CALL cft_2xy ( f , dfft % npp ( me_p ), n1 , n2 , nx1 , nx2 , isgn , planes ) ENDIF ! CALL bw_scatter ( isgn ) ! IF ( isgn /= - 2 ) THEN ! CALL cft_1z ( aux , dfft % nsp ( me_p ), n3 , nx3 , isgn , f ) ! ELSE ! IF ( use_tg ) THEN CALL cft_1z ( aux , dfft % tg_nsw ( me_p ), n3 , nx3 , isgn , yf ) CALL unpack_group_sticks ( yf , f , dfft ) ELSE CALL cft_1z ( aux , dfft % nsw ( me_p ), n3 , nx3 , isgn , f ) ENDIF ! ENDIF ! ENDIF ! IF ( use_tg ) THEN DEALLOCATE ( yf ) ENDIF DEALLOCATE ( aux ) ! RETURN ! CONTAINS ! SUBROUTINE fw_scatter ( iopt ) !Transpose data for the 2-D FFT on the x-y plane ! !NOGRP*dfft%nnr: The length of aux and f !nr3x: The length of each Z-stick !aux: input - output !f: working space !isgn: type of scatter !dfft%nsw(me) holds the number of Z-sticks proc. me has. !dfft%npp: number of planes per processor ! ! USE scatter_mod , ONLY : fft_scatter ! INTEGER , INTENT ( in ) :: iopt ! IF ( iopt == 2 ) THEN ! IF ( use_tg ) THEN ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nogrp * dfft % tg_nnr , f , dfft % tg_nsw , dfft % tg_npp , iopt , use_tg ) ! ELSE ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nnr , f , dfft % nsw , dfft % npp , iopt ) ! ENDIF ! ELSEIF ( iopt == 1 ) THEN ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nnr , f , dfft % nsp , dfft % npp , iopt ) ! ENDIF ! RETURN END SUBROUTINE fw_scatter ! SUBROUTINE bw_scatter ( iopt ) ! USE scatter_mod , ONLY : fft_scatter ! INTEGER , INTENT ( in ) :: iopt ! IF ( iopt == - 2 ) THEN ! IF ( use_tg ) THEN ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nogrp * dfft % tg_nnr , f , dfft % tg_nsw , dfft % tg_npp , iopt , use_tg ) ! ELSE ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nnr , f , dfft % nsw , dfft % npp , iopt ) ! ENDIF ! ELSEIF ( iopt == - 1 ) THEN ! CALL fft_scatter ( dfft , aux , nx3 , dfft % nnr , f , dfft % nsp , dfft % npp , iopt ) ! ENDIF ! RETURN END SUBROUTINE bw_scatter ! END SUBROUTINE tg_cft3s ! ! ! !---------------------------------------------------------------------------- SUBROUTINE fw_tg_cft3_z ( f_in , dfft , f_out ) !---------------------------------------------------------------------------- ! USE fft_scalar , ONLY : cft_1z USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! COMPLEX ( DP ), INTENT ( inout ) :: f_in ( : ) ! INPUT array containing data to be transformed COMPLEX ( DP ), INTENT ( inout ) :: f_out (:) ! OUTPUT TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout ! CALL cft_1z ( f_in , dfft % tg_nsw ( dfft % mype + 1 ), dfft % nr3 , dfft % nr3x , 2 , f_out ) ! END SUBROUTINE fw_tg_cft3_z ! !---------------------------------------------------------------------------- SUBROUTINE bw_tg_cft3_z ( f_out , dfft , f_in ) !---------------------------------------------------------------------------- ! USE fft_scalar , ONLY : cft_1z USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! COMPLEX ( DP ), INTENT ( inout ) :: f_out ( : ) ! OUTPUT COMPLEX ( DP ), INTENT ( inout ) :: f_in (:) ! INPUT array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout ! CALL cft_1z ( f_in , dfft % tg_nsw ( dfft % mype + 1 ), dfft % nr3 , dfft % nr3x , - 2 , f_out ) ! END SUBROUTINE bw_tg_cft3_z ! !---------------------------------------------------------------------------- SUBROUTINE fw_tg_cft3_scatter ( f , dfft , aux ) !---------------------------------------------------------------------------- ! USE scatter_mod , ONLY : fft_scatter USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE ! COMPLEX ( DP ), INTENT ( inout ) :: f ( : ), aux ( : ) ! array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout ! CALL fft_scatter ( dfft , aux , dfft % nr3x , dfft % nogrp * dfft % tg_nnr , f , dfft % tg_nsw , dfft % tg_npp , 2 , . true . ) ! END SUBROUTINE fw_tg_cft3_scatter ! !---------------------------------------------------------------------------- SUBROUTINE bw_tg_cft3_scatter ( f , dfft , aux ) !---------------------------------------------------------------------------- ! USE scatter_mod , ONLY : fft_scatter USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE ! COMPLEX ( DP ), INTENT ( inout ) :: f ( : ), aux ( : ) ! array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout ! CALL fft_scatter ( dfft , aux , dfft % nr3x , dfft % nogrp * dfft % tg_nnr , f , dfft % tg_nsw , dfft % tg_npp , - 2 , . true . ) ! END SUBROUTINE bw_tg_cft3_scatter ! !---------------------------------------------------------------------------- SUBROUTINE fw_tg_cft3_xy ( f , dfft ) !---------------------------------------------------------------------------- ! USE fft_scalar , ONLY : cft_2xy USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE ! COMPLEX ( DP ), INTENT ( inout ) :: f ( : ) ! INPUT/OUTPUT array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout INTEGER :: planes ( dfft % nr1x ) ! planes = dfft % iplw CALL cft_2xy ( f , dfft % tg_npp ( dfft % mype + 1 ), dfft % nr1 , dfft % nr2 , dfft % nr1x , dfft % nr2x , 2 , planes ) ! END SUBROUTINE fw_tg_cft3_xy ! !---------------------------------------------------------------------------- SUBROUTINE bw_tg_cft3_xy ( f , dfft ) !---------------------------------------------------------------------------- ! USE fft_scalar , ONLY : cft_2xy USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE ! COMPLEX ( DP ), INTENT ( inout ) :: f ( : ) ! INPUT/OUTPUT  array containing data to be transformed TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! descriptor of fft data layout INTEGER :: planes ( dfft % nr1x ) ! planes = dfft % iplw CALL cft_2xy ( f , dfft % tg_npp ( dfft % mype + 1 ), dfft % nr1 , dfft % nr2 , dfft % nr1x , dfft % nr2x , - 2 , planes ) ! END SUBROUTINE bw_tg_cft3_xy !---------------------------------------------------------------------------- SUBROUTINE pack_group_sticks ( f , yf , dfft ) USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif COMPLEX ( DP ), INTENT ( in ) :: f ( : ) ! array containing all bands, and gvecs distributed across processors COMPLEX ( DP ), INTENT ( out ) :: yf ( : ) ! array containing bands collected into task groups TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft INTEGER :: ierr ! IF ( dfft % tg_rdsp ( dfft % nogrp ) + dfft % tg_rcv ( dfft % nogrp ) > size ( yf ) ) THEN CALL fftx_error__ ( 'pack_group_sticks' , ' inconsistent size ' , 1 ) ENDIF IF ( dfft % tg_psdsp ( dfft % nogrp ) + dfft % tg_snd ( dfft % nogrp ) > size ( f ) ) THEN CALL fftx_error__ ( 'pack_group_sticks' , ' inconsistent size ' , 2 ) ENDIF CALL start_clock ( 'ALLTOALL' ) ! !  Collect all the sticks of the different states, !  in \"yf\" processors will have all the sticks of the OGRP #if defined(__MPI) CALL MPI_ALLTOALLV ( f ( 1 ), dfft % tg_snd , dfft % tg_psdsp , MPI_DOUBLE_COMPLEX , yf ( 1 ), dfft % tg_rcv , & & dfft % tg_rdsp , MPI_DOUBLE_COMPLEX , dfft % ogrp_comm , IERR ) IF ( ierr /= 0 ) THEN CALL fftx_error__ ( 'pack_group_sticks' , ' alltoall error 1 ' , abs ( ierr ) ) ENDIF #else IF ( dfft % tg_rcv ( dfft % nogrp ) /= dfft % tg_snd ( dfft % nogrp ) ) THEN CALL fftx_error__ ( 'pack_group_sticks' , ' inconsistent size ' , 3 ) ENDIF yf ( 1 : dfft % tg_rcv ( dfft % nogrp ) ) = f ( 1 : dfft % tg_snd ( dfft % nogrp ) ) #endif CALL stop_clock ( 'ALLTOALL' ) ! !YF Contains all ( ~ NOGRP*dfft%nsw(me) ) Z-sticks ! RETURN END SUBROUTINE pack_group_sticks ! SUBROUTINE unpack_group_sticks ( yf , f , dfft ) USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif COMPLEX ( DP ), INTENT ( out ) :: f ( : ) ! array containing all bands, and gvecs distributed across processors COMPLEX ( DP ), INTENT ( in ) :: yf ( : ) ! array containing bands collected into task groups TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft ! !  Bring pencils back to their original distribution ! INTEGER :: ierr ! IF ( dfft % tg_usdsp ( dfft % nogrp ) + dfft % tg_snd ( dfft % nogrp ) > size ( f ) ) THEN CALL fftx_error__ ( 'unpack_group_sticks' , ' inconsistent size ' , 3 ) ENDIF IF ( dfft % tg_rdsp ( dfft % nogrp ) + dfft % tg_rcv ( dfft % nogrp ) > size ( yf ) ) THEN CALL fftx_error__ ( 'unpack_group_sticks' , ' inconsistent size ' , 4 ) ENDIF CALL start_clock ( 'ALLTOALL' ) #if defined(__MPI) CALL MPI_Alltoallv ( yf ( 1 ), & dfft % tg_rcv , dfft % tg_rdsp , MPI_DOUBLE_COMPLEX , f ( 1 ), & dfft % tg_snd , dfft % tg_usdsp , MPI_DOUBLE_COMPLEX , dfft % ogrp_comm , IERR ) IF ( ierr /= 0 ) THEN CALL fftx_error__ ( 'unpack_group_sticks' , ' alltoall error 2 ' , abs ( ierr ) ) ENDIF #endif CALL stop_clock ( 'ALLTOALL' ) RETURN END SUBROUTINE unpack_group_sticks SUBROUTINE tg_gather ( dffts , v , tg_v ) ! USE fft_types , ONLY : fft_dlay_descriptor ! T.G. ! NOGRP:      Number of processors per orbital task group IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dffts REAL ( DP ) :: v (:) REAL ( DP ) :: tg_v (:) INTEGER :: nsiz , i , ierr , nsiz_tg INTEGER :: recv_cnt ( dffts % nogrp ), recv_displ ( dffts % nogrp ) nsiz_tg = dffts % tg_nnr * dffts % nogrp IF ( size ( tg_v ) < nsiz_tg ) & CALL fftx_error__ ( ' tg_gather ' , ' tg_v too small ' , ( nsiz_tg - size ( tg_v ) ) ) nsiz = dffts % npp ( dffts % mype + 1 ) * dffts % nr1x * dffts % nr2x IF ( size ( v ) < nsiz ) & CALL fftx_error__ ( ' tg_gather ' , ' v too small ' , ( nsiz - size ( v ) ) ) ! !  The potential in v is distributed across all processors !  We need to redistribute it so that it is completely contained in the !  processors of an orbital TASK-GROUP ! recv_cnt ( 1 ) = dffts % npp ( dffts % nolist ( 1 ) + 1 ) * dffts % nr1x * dffts % nr2x recv_displ ( 1 ) = 0 DO i = 2 , dffts % nogrp recv_cnt ( i ) = dffts % npp ( dffts % nolist ( i ) + 1 ) * dffts % nr1x * dffts % nr2x recv_displ ( i ) = recv_displ ( i - 1 ) + recv_cnt ( i - 1 ) ENDDO ! clean only elements that will not be overwritten ! DO i = recv_displ ( dffts % nogrp ) + recv_cnt ( dffts % nogrp ) + 1 , size ( tg_v ) tg_v ( i ) = 0.0 d0 ENDDO #if defined(__MPI) CALL MPI_Allgatherv ( v ( 1 ), nsiz , MPI_DOUBLE_PRECISION , & tg_v ( 1 ), recv_cnt , recv_displ , MPI_DOUBLE_PRECISION , dffts % ogrp_comm , IERR ) IF ( ierr /= 0 ) & CALL fftx_error__ ( ' tg_gather ' , ' MPI_Allgatherv ' , abs ( ierr ) ) #endif END SUBROUTINE tg_gather ! !  Complex version of previous routine ! SUBROUTINE tg_cgather ( dffts , v , tg_v ) ! USE fft_types , ONLY : fft_dlay_descriptor ! T.G. ! NOGRP:      Number of processors per orbital task group IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dffts COMPLEX ( DP ) :: v (:) COMPLEX ( DP ) :: tg_v (:) INTEGER :: nsiz , i , ierr , nsiz_tg INTEGER :: recv_cnt ( dffts % nogrp ), recv_displ ( dffts % nogrp ) nsiz_tg = dffts % tg_nnr * dffts % nogrp IF ( size ( tg_v ) < nsiz_tg ) & CALL fftx_error__ ( ' tg_gather ' , ' tg_v too small ' , ( nsiz_tg - size ( tg_v ) ) ) nsiz = dffts % npp ( dffts % mype + 1 ) * dffts % nr1x * dffts % nr2x IF ( size ( v ) < nsiz ) & CALL fftx_error__ ( ' tg_gather ' , ' v too small ' , ( nsiz - size ( v ) ) ) ! !  The potential in v is distributed across all processors !  We need to redistribute it so that it is completely contained in the !  processors of an orbital TASK-GROUP ! recv_cnt ( 1 ) = dffts % npp ( dffts % nolist ( 1 ) + 1 ) * dffts % nr1x * dffts % nr2x recv_displ ( 1 ) = 0 DO i = 2 , dffts % nogrp recv_cnt ( i ) = dffts % npp ( dffts % nolist ( i ) + 1 ) * dffts % nr1x * dffts % nr2x recv_displ ( i ) = recv_displ ( i - 1 ) + recv_cnt ( i - 1 ) ENDDO ! clean only elements that will not be overwritten ! DO i = recv_displ ( dffts % nogrp ) + recv_cnt ( dffts % nogrp ) + 1 , size ( tg_v ) tg_v ( i ) = ( 0.0 d0 , 0.0 d0 ) ENDDO ! ! The quantities are complex, multiply the cunters by 2 and gather ! real numbers ! nsiz = 2 * nsiz recv_cnt = 2 * recv_cnt recv_displ = 2 * recv_displ #if defined(__MPI) CALL MPI_Allgatherv ( v ( 1 ), nsiz , MPI_DOUBLE_PRECISION , & tg_v ( 1 ), recv_cnt , recv_displ , MPI_DOUBLE_PRECISION , dffts % ogrp_comm , IERR ) IF ( ierr /= 0 ) & CALL fftx_error__ ( ' tg_cgather ' , ' MPI_Allgatherv ' , abs ( ierr ) ) #endif END SUBROUTINE tg_cgather END MODULE fft_parallel","tags":"","loc":"sourcefile/fft_parallel.f90.html","title":"fft_parallel.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! MODULE fft_param IMPLICIT NONE INTEGER , PARAMETER :: nfftx = 2049 !! Number of different FFT tables that the module !!could keep into memory without reinitialization INTEGER , PARAMETER :: ndims = 3 !!Max allowed fft dimension END MODULE fft_param","tags":"","loc":"sourcefile/fft_param.f90.html","title":"fft_param.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #if defined(__DFTI) #include \"mkl_dfti.f90\" !=----------------------------------------------------------------------=! MODULE fft_scalar !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding USE MKL_DFTI ! -- this can be found in the MKL include directory USE fft_param IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_1z , cft_2xy , cfft3d , cfft3ds ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) TYPE dfti_descriptor_array TYPE ( DFTI_DESCRIPTOR ), POINTER :: desc END TYPE !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"z\" ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_1z ( c , nsl , nz , ldz , isign , cout ) !     driver routine for nsl 1d complex fft's of length nz !     ldz >= nz is the distance between sequences to be transformed !     (ldz>nz is used on some architectures to reduce memory conflicts) !     input  :  c(ldz*nsl)   (complex) !     output : cout(ldz*nsl) (complex - NOTA BENE: transform is not in-place!) !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nz, nsl, ldz) are stored and re-used if available INTEGER , INTENT ( IN ) :: isign INTEGER , INTENT ( IN ) :: nsl , nz , ldz COMPLEX ( DP ) :: c (:), cout (:) REAL ( DP ) :: tscale INTEGER :: i , err , idir , ip , void INTEGER , SAVE :: zdims ( 3 , ndims ) = - 1 INTEGER , SAVE :: icurrent = 1 LOGICAL :: found INTEGER :: tid #if defined(__OPENMP) INTEGER :: offset , ldz_t INTEGER :: omp_get_max_threads EXTERNAL :: omp_get_max_threads #endif !   Intel MKL native FFT driver TYPE ( DFTI_DESCRIPTOR_ARRAY ), SAVE :: hand ( ndims ) LOGICAL , SAVE :: dfti_first = . TRUE . INTEGER :: dfti_status = 0 ! CALL check_dims () ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . found ) THEN !   no table exist for these parameters !   initialize a new one CALL init_dfti () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_1z' ) #endif IF ( isign < 0 ) THEN dfti_status = DftiComputeForward ( hand ( ip )% desc , c , cout ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DftiComputeForward ' , dfti_status ) ELSE IF ( isign > 0 ) THEN dfti_status = DftiComputeBackward ( hand ( ip )% desc , c , cout ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DftiComputeBackward ' , dfti_status ) END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_1z' ) #endif RETURN CONTAINS !=------------------------------------------------=! SUBROUTINE check_dims () IF ( nsl < 0 ) THEN CALL fftx_error__ ( \" fft_scalar: cft_1z \" , \" nsl out of range \" , nsl ) END IF END SUBROUTINE check_dims SUBROUTINE lookup () IF ( dfti_first . EQ . . TRUE . ) THEN DO ip = 1 , ndims hand ( ip )% desc => NULL () END DO dfti_first = . FALSE . END IF DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters found = ( nz == zdims ( 1 , ip ) ) !   The initialization in ESSL and FFTW v.3 depends on all three parameters found = found . AND . ( nsl == zdims ( 2 , ip ) ) . AND . ( ldz == zdims ( 3 , ip ) ) IF ( found ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_dfti () if ( ASSOCIATED ( hand ( icurrent )% desc ) ) THEN dfti_status = DftiFreeDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiFreeDescriptor\" , dfti_status STOP ENDIF END IF dfti_status = DftiCreateDescriptor ( hand ( icurrent )% desc , DFTI_DOUBLE , DFTI_COMPLEX , 1 , nz ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DftiCreateDescriptor ' , dfti_status ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_NUMBER_OF_TRANSFORMS , nsl ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_NUMBER_OF_TRANSFORMS ' , dfti_status ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_INPUT_DISTANCE , ldz ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_INPUT_DISTANCE ' , dfti_status ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_PLACEMENT , DFTI_NOT_INPLACE ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_PLACEMENT ' , dfti_status ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_OUTPUT_DISTANCE , ldz ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_OUTPUT_DISTANCE ' , dfti_status ) tscale = 1.0_DP / nz dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_FORWARD_SCALE , tscale ); IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_FORWARD_SCALE ' , dfti_status ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_BACKWARD_SCALE , DBLE ( 1 ) ); IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DFTI_BACKWARD_SCALE ' , dfti_status ) dfti_status = DftiCommitDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) & CALL fftx_error__ ( ' cft_1z ' , ' stopped in DftiCommitDescriptor ' , dfti_status ) zdims ( 1 , icurrent ) = nz ; zdims ( 2 , icurrent ) = nsl ; zdims ( 3 , icurrent ) = ldz ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_dfti END SUBROUTINE cft_1z ! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"x\" and \"y\" direction ! ! ! !=----------------------------------------------------------------------=! ! ! SUBROUTINE cft_2xy ( r , nzl , nx , ny , ldx , ldy , isign , pl2ix ) !     driver routine for nzl 2d complex fft's of lengths nx and ny !     input : r(ldx*ldy)  complex, transform is in-place !     ldx >= nx, ldy >= ny are the physical dimensions of the equivalent !     2d array: r2d(ldx, ldy) (x first dimension, y second dimension) !     (ldx>nx, ldy>ny used on some architectures to reduce memory conflicts) !     pl2ix(nx) (optional) is 1 for columns along y to be transformed !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nzl,ldx) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: isign , ldx , ldy , nx , ny , nzl INTEGER , OPTIONAL , INTENT ( IN ) :: pl2ix (:) COMPLEX ( DP ) :: r ( : ) INTEGER :: i , k , j , err , idir , ip , kk , void REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 4 , ndims ) = - 1 LOGICAL :: dofft ( nfftx ), found INTEGER , PARAMETER :: stdout = 6 #if defined(__OPENMP) INTEGER :: offset INTEGER :: nx_t , ny_t , nzl_t , ldx_t , ldy_t INTEGER :: itid , mytid , ntids INTEGER :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads EXTERNAL :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads #endif TYPE ( DFTI_DESCRIPTOR_ARRAY ), SAVE :: hand ( ndims ) LOGICAL , SAVE :: dfti_first = . TRUE . INTEGER :: dfti_status = 0 dofft ( 1 : nx ) = . TRUE . IF ( PRESENT ( pl2ix ) ) THEN IF ( SIZE ( pl2ix ) < nx ) & CALL fftx_error__ ( ' cft_2xy ' , ' wrong dimension for arg no. 8 ' , 1 ) DO i = 1 , nx IF ( pl2ix ( i ) < 1 ) dofft ( i ) = . FALSE . END DO END IF ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . found ) THEN !   no table exist for these parameters !   initialize a new one CALL init_dfti () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_2xy' ) #endif IF ( isign < 0 ) THEN ! dfti_status = DftiComputeForward ( hand ( ip )% desc , r (:)) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiComputeForward\" , dfti_status STOP ENDIF ! ELSE IF ( isign > 0 ) THEN ! dfti_status = DftiComputeBackward ( hand ( ip )% desc , r (:)) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiComputeBackward\" , dfti_status STOP ENDIF ! END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_2xy' ) #endif RETURN CONTAINS !=------------------------------------------------=! SUBROUTINE check_dims () END SUBROUTINE check_dims SUBROUTINE lookup () IF ( dfti_first . EQ . . TRUE . ) THEN DO ip = 1 , ndims hand ( ip )% desc => NULL () END DO dfti_first = . FALSE . END IF DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters found = ( ny == dims ( 1 , ip ) ) . AND . ( nx == dims ( 3 , ip ) ) found = found . AND . ( ldx == dims ( 2 , ip ) ) . AND . ( nzl == dims ( 4 , ip ) ) IF ( found ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_dfti () if ( ASSOCIATED ( hand ( icurrent )% desc ) ) THEN dfti_status = DftiFreeDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiFreeDescriptor\" , dfti_status STOP ENDIF END IF dfti_status = DftiCreateDescriptor ( hand ( icurrent )% desc , DFTI_DOUBLE , DFTI_COMPLEX , 2 ,( / nx , ny / )) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiCreateDescriptor\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_NUMBER_OF_TRANSFORMS , nzl ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_NUMBER_OF_TRANSFORMS\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_INPUT_DISTANCE , ldx * ldy ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_INPUT_DISTANCE\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_PLACEMENT , DFTI_INPLACE ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_PLACEMENT\" , dfti_status STOP ENDIF tscale = 1.0_DP / ( nx * ny ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_FORWARD_SCALE , tscale ); IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_FORWARD_SCALE\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_BACKWARD_SCALE , DBLE ( 1 ) ); IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_BACKWARD_SCALE\" , dfti_status STOP ENDIF dfti_status = DftiCommitDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiCommitDescriptor\" , dfti_status STOP ENDIF dims ( 1 , icurrent ) = ny ; dims ( 2 , icurrent ) = ldx ; dims ( 3 , icurrent ) = nx ; dims ( 4 , icurrent ) = nzl ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_dfti END SUBROUTINE cft_2xy ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) !     driver routine for 3d complex fft of lengths nx, ny, nz !     input  :  f(ldx*ldy*ldz)  complex, transform is in-place !     ldx >= nx, ldy >= ny, ldz >= nz are the physical dimensions !     of the equivalent 3d array: f3d(ldx,ldy,ldz) !     (ldx>nx, ldy>ny, ldz>nz may be used on some architectures !      to reduce memory conflicts - not implemented for FFTW) !     isign > 0 : f(G) => f(R)   ; isign < 0 : f(R) => f(G) ! !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nz) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , isign COMPLEX ( DP ) :: f (:) INTEGER :: i , k , j , err , idir , ip REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 !   Intel MKL native FFT driver TYPE ( DFTI_DESCRIPTOR_ARRAY ), SAVE :: hand ( ndims ) LOGICAL , SAVE :: dfti_first = . TRUE . INTEGER :: dfti_status = 0 ! CALL check_dims () ! !   Here initialize table only if necessary ! CALL lookup () IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one CALL init_dfti () END IF ! !   Now perform the 3D FFT using the machine specific driver ! IF ( isign < 0 ) THEN ! dfti_status = DftiComputeForward ( hand ( ip )% desc , f ( 1 :)) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiComputeForward\" , dfti_status STOP ENDIF ! ELSE IF ( isign > 0 ) THEN ! dfti_status = DftiComputeBackward ( hand ( ip )% desc , f ( 1 :)) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiComputeBackward\" , dfti_status STOP ENDIF ! END IF RETURN CONTAINS !=------------------------------------------------=! SUBROUTINE check_dims () IF ( nx < 1 ) & call fftx_error__ ( 'cfft3d' , ' nx is less than 1 ' , 1 ) IF ( ny < 1 ) & call fftx_error__ ( 'cfft3d' , ' ny is less than 1 ' , 1 ) IF ( nz < 1 ) & call fftx_error__ ( 'cfft3' , ' nz is less than 1 ' , 1 ) END SUBROUTINE check_dims SUBROUTINE lookup () IF ( dfti_first . EQ . . TRUE . ) THEN DO ip = 1 , ndims hand ( ip )% desc => NULL () END DO dfti_first = . FALSE . END IF ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . & ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO END SUBROUTINE lookup SUBROUTINE init_dfti () if ( ASSOCIATED ( hand ( icurrent )% desc ) ) THEN dfti_status = DftiFreeDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiFreeDescriptor\" , dfti_status STOP ENDIF END IF dfti_status = DftiCreateDescriptor ( hand ( icurrent )% desc , DFTI_DOUBLE , DFTI_COMPLEX , 3 ,( / nx , ny , nz / )) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiCreateDescriptor\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_NUMBER_OF_TRANSFORMS , 1 ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_NUMBER_OF_TRANSFORMS\" , dfti_status STOP ENDIF dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_PLACEMENT , DFTI_INPLACE ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_PLACEMENT\" , dfti_status STOP ENDIF tscale = 1.0_DP / ( nx * ny * nz ) dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_FORWARD_SCALE , tscale ); IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_FORWARD_SCALE\" , dfti_status STOP ENDIF tscale = 1.0_DP dfti_status = DftiSetValue ( hand ( icurrent )% desc , DFTI_BACKWARD_SCALE , tscale ); IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DFTI_BACKWARD_SCALE\" , dfti_status STOP ENDIF dfti_status = DftiCommitDescriptor ( hand ( icurrent )% desc ) IF ( dfti_status /= 0 ) THEN WRITE ( * , * ) \"stopped in DftiCreateDescriptor\" , dfti_status STOP ENDIF dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_dfti END SUBROUTINE cfft3d ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs,  but using sticks! ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3ds ( f , nx , ny , nz , ldx , ldy , ldz , isign , do_fft_x , do_fft_y ) ! implicit none integer :: nx , ny , nz , ldx , ldy , ldz , isign ! complex ( DP ) :: f ( ldx * ldy * ldz ) integer :: do_fft_x (:), do_fft_y (:) ! CALL cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) END SUBROUTINE cfft3ds !=----------------------------------------------------------------------=! END MODULE fft_scalar !=----------------------------------------------------------------------=! #endif","tags":"","loc":"sourcefile/fft_scalar.dfti.f90.html","title":"fft_scalar.DFTI.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #if defined(__ESSL) !=----------------------------------------------------------------------=! MODULE fft_scalar !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding USE fft_param IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_1z , cft_2xy , cfft3d , cfft3ds ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) !   Workspace that is statically allocated is defined here !   in order to avoid multiple copies of the same workspace !   lwork:   Dimension of the work space array (if any) !   ESSL IBM library: see the ESSL manual for DCFT INTEGER , PARAMETER :: lwork = 20000 + ( 2 * nfftx + 256 ) * 64 + 3 * nfftx REAL ( DP ) :: work ( lwork ) !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"z\" ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_1z ( c , nsl , nz , ldz , isign , cout ) !     driver routine for nsl 1d complex fft's of length nz !     ldz >= nz is the distance between sequences to be transformed !     (ldz>nz is used on some architectures to reduce memory conflicts) !     input  :  c(ldz*nsl)   (complex) !     output : cout(ldz*nsl) (complex - NOTA BENE: transform is not in-place!) !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nz, nsl, ldz) are stored and re-used if available INTEGER , INTENT ( IN ) :: isign INTEGER , INTENT ( IN ) :: nsl , nz , ldz COMPLEX ( DP ) :: c (:), cout (:) REAL ( DP ) :: tscale INTEGER :: i , err , idir , ip , void INTEGER , SAVE :: zdims ( 3 , ndims ) = - 1 INTEGER , SAVE :: icurrent = 1 LOGICAL :: done #if defined __HPM INTEGER :: OMP_GET_THREAD_NUM #endif INTEGER :: tid ! ...   Machine-Dependent parameters, work arrays and tables of factors !   ltabl   Dimension of the tables of factors calculated at the !           initialization stage #if defined(__OPENMP) INTEGER :: offset , ldz_t INTEGER :: omp_get_max_threads EXTERNAL :: omp_get_max_threads #endif !   ESSL IBM library: see the ESSL manual for DCFT INTEGER , PARAMETER :: ltabl = 20000 + 3 * nfftx REAL ( DP ), SAVE :: fw_tablez ( ltabl , ndims ) REAL ( DP ), SAVE :: bw_tablez ( ltabl , ndims ) IF ( nsl < 0 ) THEN CALL fftx_error__ ( \" fft_scalar: cft_1z \" , \" nsl out of range \" , nsl ) END IF ! !   Here initialize table only if necessary ! DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters done = ( nz == zdims ( 1 , ip ) ) !   The initialization in ESSL and FFTW v.3 depends on all three parameters done = done . AND . ( nsl == zdims ( 2 , ip ) ) . AND . ( ldz == zdims ( 3 , ip ) ) IF ( done ) EXIT END DO IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one ! WRITE( stdout, fmt=\"('DEBUG cft_1z, reinitializing tables ', I3)\" ) icurrent tscale = 1.0_DP / nz CALL DCFT ( 1 , c ( 1 ), 1 , ldz , cout ( 1 ), 1 , ldz , nz , nsl , 1 , & tscale , fw_tablez ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , c ( 1 ), 1 , ldz , cout ( 1 ), 1 , ldz , nz , nsl , - 1 , & 1.0_DP , bw_tablez ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) zdims ( 1 , icurrent ) = nz ; zdims ( 2 , icurrent ) = nsl ; zdims ( 3 , icurrent ) = ldz ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_1z' ) #endif ! essl uses a different convention for forward/backward transforms ! wrt most other implementations: notice the sign of \"idir\" IF ( isign < 0 ) THEN idir =+ 1 tscale = 1.0_DP / nz CALL DCFT ( 0 , c ( 1 ), 1 , ldz , cout ( 1 ), 1 , ldz , nz , nsl , idir , & tscale , fw_tablez ( 1 , ip ), ltabl , work , lwork ) ELSE IF ( isign > 0 ) THEN idir =- 1 tscale = 1.0_DP CALL DCFT ( 0 , c ( 1 ), 1 , ldz , cout ( 1 ), 1 , ldz , nz , nsl , idir , & tscale , bw_tablez ( 1 , ip ), ltabl , work , lwork ) END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_1z' ) #endif RETURN END SUBROUTINE cft_1z ! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"x\" and \"y\" direction ! ! ! !=----------------------------------------------------------------------=! ! ! SUBROUTINE cft_2xy ( r , nzl , nx , ny , ldx , ldy , isign , pl2ix ) !     driver routine for nzl 2d complex fft's of lengths nx and ny !     input : r(ldx*ldy)  complex, transform is in-place !     ldx >= nx, ldy >= ny are the physical dimensions of the equivalent !     2d array: r2d(ldx, ldy) (x first dimension, y second dimension) !     (ldx>nx, ldy>ny used on some architectures to reduce memory conflicts) !     pl2ix(nx) (optional) is 1 for columns along y to be transformed !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nzl,ldx) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: isign , ldx , ldy , nx , ny , nzl INTEGER , OPTIONAL , INTENT ( IN ) :: pl2ix (:) COMPLEX ( DP ) :: r ( : ) INTEGER :: i , k , j , err , idir , ip , kk , void REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 4 , ndims ) = - 1 LOGICAL :: dofft ( nfftx ), done INTEGER , PARAMETER :: stdout = 6 #if defined __HPM INTEGER :: OMP_GET_THREAD_NUM #endif #if defined(__OPENMP) INTEGER :: offset INTEGER :: nx_t , ny_t , nzl_t , ldx_t , ldy_t INTEGER :: itid , mytid , ntids INTEGER :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads EXTERNAL :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads #endif INTEGER , PARAMETER :: ltabl = 20000 + 3 * nfftx REAL ( DP ), SAVE :: fw_tablex ( ltabl , ndims ), fw_tabley ( ltabl , ndims ) REAL ( DP ), SAVE :: bw_tablex ( ltabl , ndims ), bw_tabley ( ltabl , ndims ) dofft ( 1 : nx ) = . TRUE . IF ( PRESENT ( pl2ix ) ) THEN IF ( SIZE ( pl2ix ) < nx ) & CALL fftx_error__ ( ' cft_2xy ' , ' wrong dimension for arg no. 8 ' , 1 ) DO i = 1 , nx IF ( pl2ix ( i ) < 1 ) dofft ( i ) = . FALSE . END DO END IF ! WRITE( stdout,*) 'DEBUG: ', COUNT( dofft ) ! !   Here initialize table only if necessary ! DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters done = ( ny == dims ( 1 , ip ) ) . AND . ( nx == dims ( 3 , ip ) ) done = done . AND . ( ldx == dims ( 2 , ip ) ) . AND . ( nzl == dims ( 4 , ip ) ) IF ( done ) EXIT END DO IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one ! WRITE( stdout, fmt=\"('DEBUG cft_2xy, reinitializing tables ', I3)\" ) icurrent #if defined(__OPENMP) tscale = 1.0_DP / ( nx * ny ) CALL DCFT ( 1 , r ( 1 ), ldx , 1 , r ( 1 ), ldx , 1 , ny , nx , 1 , 1.0_DP , & fw_tabley ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), ldx , 1 , r ( 1 ), ldx , 1 , ny , nx , - 1 , 1.0_DP , & bw_tabley ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), 1 , ldx , r ( 1 ), 1 , ldx , nx , ny , 1 , & tscale , fw_tablex ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), 1 , ldx , r ( 1 ), 1 , ldx , nx , ny , - 1 , & 1.0_DP , bw_tablex ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) #else tscale = 1.0_DP / ( nx * ny ) CALL DCFT ( 1 , r ( 1 ), ldx , 1 , r ( 1 ), ldx , 1 , ny , 1 , 1 , 1.0_DP , & fw_tabley ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), ldx , 1 , r ( 1 ), ldx , 1 , ny , 1 , - 1 , 1.0_DP , & bw_tabley ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), 1 , ldx , r ( 1 ), 1 , ldx , nx , ny , 1 , & tscale , fw_tablex ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , r ( 1 ), 1 , ldx , r ( 1 ), 1 , ldx , nx , ny , - 1 , & 1.0_DP , bw_tablex ( 1 , icurrent ), ltabl , work ( 1 ), lwork ) #endif dims ( 1 , icurrent ) = ny ; dims ( 2 , icurrent ) = ldx ; dims ( 3 , icurrent ) = nx ; dims ( 4 , icurrent ) = nzl ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_2xy' ) #endif #if defined(__OPENMP) IF ( isign < 0 ) THEN tscale = 1.0_DP / ( nx * ny ) do k = 1 , nzl kk = 1 + ( k - 1 ) * ldx * ldy CALL DCFT ( 0 , r ( kk ), 1 , ldx , r ( kk ), 1 , ldx , nx , ny , & 1 , tscale , fw_tablex ( 1 , ip ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 0 , r ( kk ), ldx , 1 , r ( kk ), ldx , 1 , ny , nx , & 1 , 1.0_DP , fw_tabley ( 1 , ip ), ltabl , work ( 1 ), lwork ) end do ELSE IF ( isign > 0 ) THEN DO k = 1 , nzl kk = 1 + ( k - 1 ) * ldx * ldy CALL DCFT ( 0 , r ( kk ), ldx , 1 , r ( kk ), ldx , 1 , ny , nx , & - 1 , 1.0_DP , bw_tabley ( 1 , ip ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 0 , r ( kk ), 1 , ldx , r ( kk ), 1 , ldx , nx , ny , & - 1 , 1.0_DP , bw_tablex ( 1 , ip ), ltabl , work ( 1 ), lwork ) END DO END IF #else IF ( isign < 0 ) THEN idir = 1 tscale = 1.0_DP / ( nx * ny ) do k = 1 , nzl kk = 1 + ( k - 1 ) * ldx * ldy CALL DCFT ( 0 , r ( kk ), 1 , ldx , r ( kk ), 1 , ldx , nx , ny , idir , & tscale , fw_tablex ( 1 , ip ), ltabl , work ( 1 ), lwork ) do i = 1 , nx IF ( dofft ( i ) ) THEN kk = i + ( k - 1 ) * ldx * ldy call DCFT ( 0 , r ( kk ), ldx , 1 , r ( kk ), ldx , 1 , ny , 1 , & idir , 1.0_DP , fw_tabley ( 1 , ip ), ltabl , work ( 1 ), lwork ) END IF end do end do ELSE IF ( isign > 0 ) THEN idir = - 1 DO k = 1 , nzl do i = 1 , nx IF ( dofft ( i ) ) THEN kk = i + ( k - 1 ) * ldx * ldy call DCFT ( 0 , r ( kk ), ldx , 1 , r ( kk ), ldx , 1 , ny , 1 , & idir , 1.0_DP , bw_tabley ( 1 , ip ), ltabl , work ( 1 ), lwork ) END IF end do kk = 1 + ( k - 1 ) * ldx * ldy CALL DCFT ( 0 , r ( kk ), 1 , ldx , r ( kk ), 1 , ldx , nx , ny , idir , & 1.0_DP , bw_tablex ( 1 , ip ), ltabl , work ( 1 ), lwork ) END DO END IF #endif #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_2xy' ) #endif RETURN END SUBROUTINE cft_2xy ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) !     driver routine for 3d complex fft of lengths nx, ny, nz !     input  :  f(ldx*ldy*ldz)  complex, transform is in-place !     ldx >= nx, ldy >= ny, ldz >= nz are the physical dimensions !     of the equivalent 3d array: f3d(ldx,ldy,ldz) !     (ldx>nx, ldy>ny, ldz>nz may be used on some architectures !      to reduce memory conflicts - not implemented for FFTW) !     isign > 0 : f(G) => f(R)   ; isign < 0 : f(R) => f(G) ! !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nz) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , isign COMPLEX ( DP ) :: f (:) INTEGER :: i , k , j , err , idir , ip REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 IF ( nx < 1 ) & call fftx_error__ ( 'cfft3d' , ' nx is less than 1 ' , 1 ) IF ( ny < 1 ) & call fftx_error__ ( 'cfft3d' , ' ny is less than 1 ' , 1 ) IF ( nz < 1 ) & call fftx_error__ ( 'cfft3' , ' nz is less than 1 ' , 1 ) ! !   Here initialize table only if necessary ! ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . & ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one ! no initialization for 3d FFT's from ESSL dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the 3D FFT using the machine specific driver ! IF ( isign < 0 ) THEN tscale = 1.0_DP / ( nx * ny * nz ) idir = + 1 ELSE IF ( isign > 0 ) THEN tscale = 1.0_DP idir = - 1 END IF IF ( isign /= 0 ) CALL dcft3 ( f ( 1 ), ldx , ldx * ldy , f ( 1 ), ldx , ldx * ldy , & nx , ny , nz , idir , tscale , work ( 1 ), lwork ) RETURN END SUBROUTINE cfft3d ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs,  but using sticks! ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3ds ( f , nx , ny , nz , ldx , ldy , ldz , isign , & do_fft_x , do_fft_y ) ! !     driver routine for 3d complex \"reduced\" fft - see cfft3d !     The 3D fft are computed only on lines and planes which have !     non zero elements. These lines and planes are defined by !     the two integer vectors do_fft_x(ldy*nz) and do_fft_y(nz) !     (1 = perform fft, 0 = do not perform fft) !     This routine is implemented only for fftw, essl, acml !     If not implemented, cfft3d is called instead ! !---------------------------------------------------------------------- ! implicit none integer :: nx , ny , nz , ldx , ldy , ldz , isign ! !   logical dimensions of the fft !   physical dimensions of the f array !   sign of the transformation complex ( DP ) :: f ( ldx * ldy * ldz ) integer :: do_fft_x (:), do_fft_y (:) ! integer :: m , incx1 , incx2 INTEGER :: i , k , j , err , idir , ip , ii , jj REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 INTEGER , PARAMETER :: ltabl = 20000 + 3 * nfftx REAL ( DP ), SAVE :: fw_table ( ltabl , 3 , ndims ) REAL ( DP ), SAVE :: bw_table ( ltabl , 3 , ndims ) tscale = 1.0_DP ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',6I6)\") nx, ny, nz, ldx, ldy, ldz ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',24I2)\") do_fft_x ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',24I2)\") do_fft_y IF ( ny /= ldy ) & CALL fftx_error__ ( ' cfft3ds ' , ' wrong dimensions: ny /= ldy ' , 1 ) ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one ! ! ESSL sign convention for fft's is the opposite of the \"usual\" one ! tscale = 1.0_DP !  x - direction incx1 = 1 ; incx2 = ldx ; m = 1 CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nx , m , 1 , 1.0_DP , & fw_table ( 1 , 1 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nx , m , - 1 , 1.0_DP , & bw_table ( 1 , 1 , icurrent ), ltabl , work ( 1 ), lwork ) !  y - direction incx1 = ldx ; incx2 = 1 ; m = nx ; CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , ny , m , 1 , 1.0_DP , & fw_table ( 1 , 2 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , ny , m , - 1 , 1.0_DP , & bw_table ( 1 , 2 , icurrent ), ltabl , work ( 1 ), lwork ) !  z - direction incx1 = ldx * ldy ; incx2 = 1 ; m = ldx * ny CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nz , m , 1 , 1.0_DP , & fw_table ( 1 , 3 , icurrent ), ltabl , work ( 1 ), lwork ) CALL DCFT ( 1 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nz , m , - 1 , 1.0_DP , & bw_table ( 1 , 3 , icurrent ), ltabl , work ( 1 ), lwork ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF IF ( isign > 0 ) THEN ! !  i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) THEN call dcft ( 0 , f ( ii ), incx1 , incx2 , f ( ii ), incx1 , incx2 , nx , m , & - isign , 1.0_DP , bw_table ( 1 , 1 , ip ), ltabl , work ( 1 ), lwork ) endif enddo enddo ! !  ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call dcft ( 0 , f ( ii ), incx1 , incx2 , f ( ii ), incx1 , incx2 , nx , m , & - isign , 1.0_DP , bw_table ( 1 , 2 , ip ), ltabl , work ( 1 ), lwork ) endif enddo ! !     ... k-direction ! incx1 = ldx * ldy ; incx2 = 1 ; m = ldx * ny call dcft ( 0 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nz , m , & - isign , 1.0_DP , bw_table ( 1 , 3 , ip ), ltabl , work ( 1 ), lwork ) ELSE ! !     ... k-direction ! incx1 = ldx * ny ; incx2 = 1 ; m = ldx * ny call dcft ( 0 , f ( 1 ), incx1 , incx2 , f ( 1 ), incx1 , incx2 , nz , m , & - isign , 1.0_DP , fw_table ( 1 , 3 , ip ), ltabl , work ( 1 ), lwork ) ! !     ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call dcft ( 0 , f ( ii ), incx1 , incx2 , f ( ii ), incx1 , incx2 , ny , m , & - isign , 1.0_DP , fw_table ( 1 , 2 , ip ), ltabl , work ( 1 ), lwork ) endif enddo ! !     i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) then call dcft ( 0 , f ( ii ), incx1 , incx2 , f ( ii ), incx1 , incx2 , nx , m , & - isign , 1.0_DP , fw_table ( 1 , 1 , ip ), ltabl , work ( 1 ), lwork ) endif enddo enddo call DSCAL ( 2 * ldx * ldy * nz , 1.0_DP / ( nx * ny * nz ), f ( 1 ), 1 ) END IF RETURN END SUBROUTINE cfft3ds !=----------------------------------------------------------------------=! END MODULE fft_scalar !=----------------------------------------------------------------------=! #endif","tags":"","loc":"sourcefile/fft_scalar.essl.f90.html","title":"fft_scalar.ESSL.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #include \"fft_defs.h\" #if defined(__FFTW3) #include \"fft_scalar.FFTW3.f90\" #elif defined(__DFTI) #include \"fft_scalar.DFTI.f90\" #elif defined(__ESSL) || defined(__LINUX_ESSL) #include \"fft_scalar.ESSL.f90\" #elif defined(__SX6) #include \"fft_scalar.SX6.f90\" #else #include \"fft_scalar.FFTW.f90\" #endif #if defined(_DO_NOT_DEFINE_ME_) ! ??? MODULE fft_scalar USE fft_param END MODULE fft_scalar #endif","tags":"","loc":"sourcefile/fft_scalar.f90.html","title":"fft_scalar.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #if defined(__FFTW) !=----------------------------------------------------------------------=! MODULE fft_scalar !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding USE fft_param IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_1z , cft_2xy , cfft3d , cfft3ds ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"z\" ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_1z ( c , nsl , nz , ldz , isign , cout ) !     driver routine for nsl 1d complex fft's of length nz !     ldz >= nz is the distance between sequences to be transformed !     (ldz>nz is used on some architectures to reduce memory conflicts) !     input  :  c(ldz*nsl)   (complex) !     output : cout(ldz*nsl) (complex - NOTA BENE: transform is not in-place!) !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nz, nsl, ldz) are stored and re-used if available INTEGER , INTENT ( IN ) :: isign INTEGER , INTENT ( IN ) :: nsl , nz , ldz COMPLEX ( DP ) :: c (:), cout (:) REAL ( DP ) :: tscale INTEGER :: i , err , idir , ip , void INTEGER , SAVE :: zdims ( 3 , ndims ) = - 1 INTEGER , SAVE :: icurrent = 1 LOGICAL :: found #if defined __HPM INTEGER :: OMP_GET_THREAD_NUM #endif INTEGER :: tid #if defined(__OPENMP) INTEGER :: offset , ldz_t INTEGER :: omp_get_max_threads EXTERNAL :: omp_get_max_threads #endif !   Pointers to the \"C\" structures containing FFT factors ( PLAN ) !   C_POINTER is defined in include/fft_defs.h !   for 32bit executables, C_POINTER is integer(4) !   for 64bit executables, C_POINTER is integer(8) C_POINTER , SAVE :: fw_planz ( ndims ) = 0 C_POINTER , SAVE :: bw_planz ( ndims ) = 0 IF ( nsl < 0 ) THEN CALL fftx_error__ ( \" fft_scalar: cft_1z \" , \" nsl out of range \" , nsl ) END IF ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . found ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_1z' ) #endif #if defined(__OPENMP) ldz_t = ldz ! IF ( isign < 0 ) THEN !$omp parallel default(none) private(tid,offset,i,tscale) shared(c,isign,nsl,fw_planz,ip,nz,cout,ldz) & !$omp &        firstprivate(ldz_t) !$omp do DO i = 1 , nsl offset = 1 + (( i - 1 ) * ldz_t ) CALL FFT_Z_STICK_SINGLE ( fw_planz ( ip ), c ( offset ), ldz_t ) END DO !$omp end do !$omp end parallel tscale = 1.0_DP / nz cout ( 1 : ldz * nsl ) = c ( 1 : ldz * nsl ) * tscale ELSE IF ( isign > 0 ) THEN !$omp parallel default(none) private(tid,offset,i) shared(c,isign,nsl,bw_planz,ip,cout,ldz) & !$omp &        firstprivate(ldz_t) !$omp do DO i = 1 , nsl offset = 1 + (( i - 1 ) * ldz_t ) CALL FFT_Z_STICK_SINGLE ( bw_planz ( ip ), c ( offset ), ldz_t ) END DO !$omp end do !$omp workshare cout ( 1 : ldz * nsl ) = c ( 1 : ldz * nsl ) !$omp end workshare !$omp end parallel END IF #else IF ( isign < 0 ) THEN CALL FFT_Z_STICK ( fw_planz ( ip ), c ( 1 ), ldz , nsl ) tscale = 1.0_DP / nz cout ( 1 : ldz * nsl ) = c ( 1 : ldz * nsl ) * tscale ELSE IF ( isign > 0 ) THEN CALL FFT_Z_STICK ( bw_planz ( ip ), c ( 1 ), ldz , nsl ) cout ( 1 : ldz * nsl ) = c ( 1 : ldz * nsl ) END IF #endif #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_1z' ) #endif RETURN CONTAINS SUBROUTINE lookup () DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters found = ( nz == zdims ( 1 , ip ) ) IF ( found ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_plan () IF ( fw_planz ( icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_planz ( icurrent ) ) IF ( bw_planz ( icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_planz ( icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_planz ( icurrent ), nz , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_planz ( icurrent ), nz , idir ) zdims ( 1 , icurrent ) = nz ; zdims ( 2 , icurrent ) = nsl ; zdims ( 3 , icurrent ) = ldz ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cft_1z ! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"x\" and \"y\" direction ! ! ! !=----------------------------------------------------------------------=! ! ! SUBROUTINE cft_2xy ( r , nzl , nx , ny , ldx , ldy , isign , pl2ix ) !     driver routine for nzl 2d complex fft's of lengths nx and ny !     input : r(ldx*ldy)  complex, transform is in-place !     ldx >= nx, ldy >= ny are the physical dimensions of the equivalent !     2d array: r2d(ldx, ldy) (x first dimension, y second dimension) !     (ldx>nx, ldy>ny used on some architectures to reduce memory conflicts) !     pl2ix(nx) (optional) is 1 for columns along y to be transformed !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nzl,ldx) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: isign , ldx , ldy , nx , ny , nzl INTEGER , OPTIONAL , INTENT ( IN ) :: pl2ix (:) COMPLEX ( DP ) :: r ( : ) INTEGER :: i , k , j , err , idir , ip , kk , void REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 4 , ndims ) = - 1 LOGICAL :: dofft ( nfftx ), found INTEGER , PARAMETER :: stdout = 6 #if defined __HPM INTEGER :: OMP_GET_THREAD_NUM #endif #if defined(__OPENMP) INTEGER :: offset INTEGER :: nx_t , ny_t , nzl_t , ldx_t , ldy_t INTEGER :: itid , mytid , ntids INTEGER :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads EXTERNAL :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads #endif #if defined(__FFTW_ALL_XY_PLANES) C_POINTER , SAVE :: fw_plan_2d ( ndims ) = 0 C_POINTER , SAVE :: bw_plan_2d ( ndims ) = 0 #else C_POINTER , SAVE :: fw_plan ( 2 , ndims ) = 0 C_POINTER , SAVE :: bw_plan ( 2 , ndims ) = 0 #endif dofft ( 1 : nx ) = . TRUE . IF ( PRESENT ( pl2ix ) ) THEN IF ( SIZE ( pl2ix ) < nx ) & CALL fftx_error__ ( ' cft_2xy ' , ' wrong dimension for arg no. 8 ' , 1 ) DO i = 1 , nx IF ( pl2ix ( i ) < 1 ) dofft ( i ) = . FALSE . END DO END IF ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . found ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_2xy' ) #endif #if defined(__FFTW_ALL_XY_PLANES) IF ( isign < 0 ) THEN ! tscale = 1.0_DP / ( nx * ny ) ! CALL fftw_inplace_drv_2d ( fw_plan_2d ( ip ), nzl , r ( 1 ), 1 , ldx * ldy ) CALL ZDSCAL ( ldx * ldy * nzl , tscale , r ( 1 ), 1 ) ! ELSE IF ( isign > 0 ) THEN ! CALL fftw_inplace_drv_2d ( bw_plan_2d ( ip ), nzl , r ( 1 ), 1 , ldx * ldy ) ! END IF #elif defined(__OPENMP) nx_t = nx ny_t = ny nzl_t = nzl ldx_t = ldx ldy_t = ldy ! IF ( isign < 0 ) THEN ! tscale = 1.0_DP / ( nx * ny ) ! !$omp parallel default(none) private(offset,itid,mytid,ntids,k,j,i)  shared(r,dofft,ip,fw_plan,nzl,nx,ny,ldx,ldy,tscale)  & !$omp & firstprivate(nx_t, ny_t, nzl_t, ldx_t, ldy_t) !$omp do DO i = 1 , nzl offset = 1 + (( i - 1 ) * ( ldx_t * ldy_t )) CALL FFT_X_STICK_SINGLE ( fw_plan ( 1 , ip ), r ( offset ), nx_t , ny_t , nzl_t , ldx_t , ldy_t ) END DO !$omp end do mytid = omp_get_thread_num () ! take the thread ID ntids = omp_get_num_threads () ! take the number of threads itid = 0 do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN IF ( itid == mytid ) THEN j = i + ldx_t * ldy_t * ( k - 1 ) call FFT_Y_STICK ( fw_plan ( 2 , ip ), r ( j ), ny_t , ldx_t ) END IF itid = MOD ( itid + 1 , ntids ) END IF end do end do !$omp barrier !$omp workshare r = r * tscale !$omp end workshare !$omp end parallel ! ELSE IF ( isign > 0 ) THEN ! !$omp parallel default(none) private(offset,itid,mytid,ntids,k,j,i) shared(r,nx,nzl,dofft,ip,bw_plan) & !$omp & firstprivate(nx_t, ny_t, nzl_t, ldx_t, ldy_t) mytid = omp_get_thread_num () ! take the thread ID ntids = omp_get_num_threads () ! take the number of threads itid = 0 do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN IF ( itid == mytid ) THEN j = i + ldx_t * ldy_t * ( k - 1 ) call FFT_Y_STICK ( bw_plan ( 2 , ip ), r ( j ), ny_t , ldx_t ) END IF itid = MOD ( itid + 1 , ntids ) END IF end do end do !$omp barrier !$omp do DO i = 1 , nzl offset = 1 + (( i - 1 ) * ( ldx_t * ldy_t )) CALL FFT_X_STICK_SINGLE ( bw_plan ( 1 , ip ), r ( offset ), nx_t , ny_t , nzl_t , ldx_t , ldy_t ) END DO !$omp end do !$omp end parallel ! END IF #else IF ( isign < 0 ) THEN CALL FFT_X_STICK ( fw_plan ( 1 , ip ), r ( 1 ), nx , ny , nzl , ldx , ldy ) do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN j = i + ldx * ldy * ( k - 1 ) call FFT_Y_STICK ( fw_plan ( 2 , ip ), r ( j ), ny , ldx ) END IF end do end do tscale = 1.0_DP / ( nx * ny ) CALL ZDSCAL ( ldx * ldy * nzl , tscale , r ( 1 ), 1 ) ELSE IF ( isign > 0 ) THEN do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN j = i + ldx * ldy * ( k - 1 ) call FFT_Y_STICK ( bw_plan ( 2 , ip ), r ( j ), ny , ldx ) END IF end do end do CALL FFT_X_STICK ( bw_plan ( 1 , ip ), r ( 1 ), nx , ny , nzl , ldx , ldy ) END IF #endif #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_2xy' ) #endif RETURN CONTAINS SUBROUTINE lookup () DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters found = ( ny == dims ( 1 , ip ) ) . AND . ( nx == dims ( 3 , ip ) ) found = found . AND . ( ldx == dims ( 2 , ip ) ) . AND . ( nzl == dims ( 4 , ip ) ) IF ( found ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_plan () #if defined __FFTW_ALL_XY_PLANES IF ( fw_plan_2d ( icurrent ) /= 0 ) CALL DESTROY_PLAN_2D ( fw_plan_2d ( icurrent ) ) IF ( bw_plan_2d ( icurrent ) /= 0 ) CALL DESTROY_PLAN_2D ( bw_plan_2d ( icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_2D ( fw_plan_2d ( icurrent ), nx , ny , idir ) idir = 1 ; CALL CREATE_PLAN_2D ( bw_plan_2d ( icurrent ), nx , ny , idir ) #else IF ( fw_plan ( 2 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_plan ( 2 , icurrent ) ) IF ( bw_plan ( 2 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_plan ( 2 , icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_plan ( 2 , icurrent ), ny , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_plan ( 2 , icurrent ), ny , idir ) IF ( fw_plan ( 1 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_plan ( 1 , icurrent ) ) IF ( bw_plan ( 1 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_plan ( 1 , icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_plan ( 1 , icurrent ), nx , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_plan ( 1 , icurrent ), nx , idir ) #endif dims ( 1 , icurrent ) = ny ; dims ( 2 , icurrent ) = ldx ; dims ( 3 , icurrent ) = nx ; dims ( 4 , icurrent ) = nzl ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cft_2xy ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) !     driver routine for 3d complex fft of lengths nx, ny, nz !     input  :  f(ldx*ldy*ldz)  complex, transform is in-place !     ldx >= nx, ldy >= ny, ldz >= nz are the physical dimensions !     of the equivalent 3d array: f3d(ldx,ldy,ldz) !     (ldx>nx, ldy>ny, ldz>nz may be used on some architectures !      to reduce memory conflicts - not implemented for FFTW) !     isign > 0 : f(G) => f(R)   ; isign < 0 : f(R) => f(G) ! !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nz) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , isign COMPLEX ( DP ) :: f (:) INTEGER :: i , k , j , err , idir , ip REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 C_POINTER , save :: fw_plan ( ndims ) = 0 C_POINTER , save :: bw_plan ( ndims ) = 0 IF ( nx < 1 ) & call fftx_error__ ( 'cfft3d' , ' nx is less than 1 ' , 1 ) IF ( ny < 1 ) & call fftx_error__ ( 'cfft3d' , ' ny is less than 1 ' , 1 ) IF ( nz < 1 ) & call fftx_error__ ( 'cfft3' , ' nz is less than 1 ' , 1 ) ! !   Here initialize table only if necessary ! CALL lookup () IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the 3D FFT using the machine specific driver ! IF ( isign < 0 ) THEN call FFTW_INPLACE_DRV_3D ( fw_plan ( ip ), 1 , f ( 1 ), 1 , 1 ) tscale = 1.0_DP / DBLE ( nx * ny * nz ) call ZDSCAL ( nx * ny * nz , tscale , f ( 1 ), 1 ) ELSE IF ( isign > 0 ) THEN call FFTW_INPLACE_DRV_3D ( bw_plan ( ip ), 1 , f ( 1 ), 1 , 1 ) END IF RETURN CONTAINS SUBROUTINE lookup () ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . & ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO END SUBROUTINE lookup SUBROUTINE init_plan () IF ( nx /= ldx . or . ny /= ldy . or . nz /= ldz ) & call fftx_error__ ( 'cfft3' , 'not implemented' , 1 ) IF ( fw_plan ( icurrent ) /= 0 ) CALL DESTROY_PLAN_3D ( fw_plan ( icurrent ) ) IF ( bw_plan ( icurrent ) /= 0 ) CALL DESTROY_PLAN_3D ( bw_plan ( icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_3D ( fw_plan ( icurrent ), nx , ny , nz , idir ) idir = 1 ; CALL CREATE_PLAN_3D ( bw_plan ( icurrent ), nx , ny , nz , idir ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cfft3d ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs,  but using sticks! ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3ds ( f , nx , ny , nz , ldx , ldy , ldz , isign , & do_fft_x , do_fft_y ) ! !     driver routine for 3d complex \"reduced\" fft - see cfft3d !     The 3D fft are computed only on lines and planes which have !     non zero elements. These lines and planes are defined by !     the two integer vectors do_fft_x(ldy*nz) and do_fft_y(nz) !     (1 = perform fft, 0 = do not perform fft) !     This routine is implemented only for fftw, essl, acml !     If not implemented, cfft3d is called instead ! !---------------------------------------------------------------------- ! implicit none integer :: nx , ny , nz , ldx , ldy , ldz , isign ! !   logical dimensions of the fft !   physical dimensions of the f array !   sign of the transformation complex ( DP ) :: f ( ldx * ldy * ldz ) integer :: do_fft_x (:), do_fft_y (:) ! integer :: m , incx1 , incx2 INTEGER :: i , k , j , err , idir , ip , ii , jj REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 C_POINTER , SAVE :: fw_plan ( 3 , ndims ) = 0 C_POINTER , SAVE :: bw_plan ( 3 , ndims ) = 0 tscale = 1.0_DP IF ( ny /= ldy ) & CALL fftx_error__ ( ' cfft3ds ' , ' wrong dimensions: ny /= ldy ' , 1 ) CALL lookup () IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF IF ( isign > 0 ) THEN ! !  i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) THEN call FFTW_INPLACE_DRV_1D ( bw_plan ( 1 , ip ), m , f ( ii ), incx1 , incx2 ) endif enddo enddo ! !  ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call FFTW_INPLACE_DRV_1D ( bw_plan ( 2 , ip ), m , f ( ii ), incx1 , incx2 ) endif enddo ! !     ... k-direction ! incx1 = ldx * ldy ; incx2 = 1 ; m = ldx * ny call FFTW_INPLACE_DRV_1D ( bw_plan ( 3 , ip ), m , f ( 1 ), incx1 , incx2 ) ELSE ! !     ... k-direction ! incx1 = ldx * ny ; incx2 = 1 ; m = ldx * ny call FFTW_INPLACE_DRV_1D ( fw_plan ( 3 , ip ), m , f ( 1 ), incx1 , incx2 ) ! !     ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call FFTW_INPLACE_DRV_1D ( fw_plan ( 2 , ip ), m , f ( ii ), incx1 , incx2 ) endif enddo ! !     i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) then call FFTW_INPLACE_DRV_1D ( fw_plan ( 1 , ip ), m , f ( ii ), incx1 , incx2 ) endif enddo enddo call DSCAL ( 2 * ldx * ldy * nz , 1.0_DP / ( nx * ny * nz ), f ( 1 ), 1 ) END IF RETURN CONTAINS SUBROUTINE lookup () ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO END SUBROUTINE lookup SUBROUTINE init_plan () IF ( fw_plan ( 1 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_plan ( 1 , icurrent ) ) IF ( bw_plan ( 1 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_plan ( 1 , icurrent ) ) IF ( fw_plan ( 2 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_plan ( 2 , icurrent ) ) IF ( bw_plan ( 2 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_plan ( 2 , icurrent ) ) IF ( fw_plan ( 3 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( fw_plan ( 3 , icurrent ) ) IF ( bw_plan ( 3 , icurrent ) /= 0 ) CALL DESTROY_PLAN_1D ( bw_plan ( 3 , icurrent ) ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_plan ( 1 , icurrent ), nx , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_plan ( 1 , icurrent ), nx , idir ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_plan ( 2 , icurrent ), ny , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_plan ( 2 , icurrent ), ny , idir ) idir = - 1 ; CALL CREATE_PLAN_1D ( fw_plan ( 3 , icurrent ), nz , idir ) idir = 1 ; CALL CREATE_PLAN_1D ( bw_plan ( 3 , icurrent ), nz , idir ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cfft3ds !=----------------------------------------------------------------------=! END MODULE fft_scalar !=----------------------------------------------------------------------=! #endif","tags":"","loc":"sourcefile/fft_scalar.fftw.f90.html","title":"fft_scalar.FFTW.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #if defined(__FFTW3) !=----------------------------------------------------------------------=! MODULE fft_scalar !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding USE fft_param IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_1z , cft_2xy , cfft3d , cfft3ds ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) #if defined(__OPENMP) #include \"fftw3.f03\" #else #include \"fftw3.f\" #endif !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"z\" ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_1z ( c , nsl , nz , ldz , isign , cout ) !     driver routine for nsl 1d complex fft's of length nz !     ldz >= nz is the distance between sequences to be transformed !     (ldz>nz is used on some architectures to reduce memory conflicts) !     input  :  c(ldz*nsl)   (complex) !     output : cout(ldz*nsl) (complex - NOTA BENE: transform is not in-place!) !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nz, nsl, ldz) are stored and re-used if available INTEGER , INTENT ( IN ) :: isign INTEGER , INTENT ( IN ) :: nsl , nz , ldz COMPLEX ( DP ) :: c (:), cout (:) REAL ( DP ) :: tscale INTEGER :: i , err , idir , ip , void INTEGER , SAVE :: zdims ( 3 , ndims ) = - 1 INTEGER , SAVE :: icurrent = 1 LOGICAL :: done INTEGER :: tid #if defined(__OPENMP) INTEGER :: offset , ldz_t INTEGER :: omp_get_max_threads EXTERNAL :: omp_get_max_threads #endif !   Pointers to the \"C\" structures containing FFT factors ( PLAN ) !   C_POINTER is defined in include/fft_defs.h !   for 32bit executables, C_POINTER is integer(4) !   for 64bit executables, C_POINTER is integer(8) C_POINTER , SAVE :: fw_planz ( ndims ) = 0 C_POINTER , SAVE :: bw_planz ( ndims ) = 0 IF ( nsl < 0 ) THEN CALL fftx_error__ ( \" fft_scalar: cft_1z \" , \" nsl out of range \" , nsl ) END IF ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_1z' ) #endif IF ( isign < 0 ) THEN CALL dfftw_execute_dft ( fw_planz ( ip ), c , cout ) tscale = 1.0_DP / nz cout ( 1 : ldz * nsl ) = cout ( 1 : ldz * nsl ) * tscale ELSE IF ( isign > 0 ) THEN CALL dfftw_execute_dft ( bw_planz ( ip ), c , cout ) END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_1z' ) #endif RETURN CONTAINS SUBROUTINE lookup () ! lookup for stored plan DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters !   The initialization in ESSL and FFTW v.3 depends on all three parameters done = ( nz == zdims ( 1 , ip ) ) done = done . AND . ( nsl == zdims ( 2 , ip ) ) . AND . ( ldz == zdims ( 3 , ip ) ) IF ( done ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_plan () #if defined(__OPENMP) CALL dfftw_cleanup_threads () void = fftw_init_threads () CALL dfftw_plan_with_nthreads ( omp_get_max_threads ()) #endif IF ( fw_planz ( icurrent ) /= 0 ) CALL dfftw_destroy_plan ( fw_planz ( icurrent ) ) IF ( bw_planz ( icurrent ) /= 0 ) CALL dfftw_destroy_plan ( bw_planz ( icurrent ) ) idir = - 1 CALL dfftw_plan_many_dft ( fw_planz ( icurrent ), 1 , nz , nsl , c , & ( / SIZE ( c ) / ), 1 , ldz , cout , ( / SIZE ( cout ) / ), 1 , ldz , idir , FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_planz ( icurrent ), 1 , nz , nsl , c , & ( / SIZE ( c ) / ), 1 , ldz , cout , ( / SIZE ( cout ) / ), 1 , ldz , idir , FFTW_ESTIMATE ) zdims ( 1 , icurrent ) = nz ; zdims ( 2 , icurrent ) = nsl ; zdims ( 3 , icurrent ) = ldz ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cft_1z ! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"x\" and \"y\" direction ! ! ! !=----------------------------------------------------------------------=! ! ! SUBROUTINE cft_2xy ( r , nzl , nx , ny , ldx , ldy , isign , pl2ix ) !     driver routine for nzl 2d complex fft's of lengths nx and ny !     input : r(ldx*ldy)  complex, transform is in-place !     ldx >= nx, ldy >= ny are the physical dimensions of the equivalent !     2d array: r2d(ldx, ldy) (x first dimension, y second dimension) !     (ldx>nx, ldy>ny used on some architectures to reduce memory conflicts) !     pl2ix(nx) (optional) is 1 for columns along y to be transformed !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nzl,ldx) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: isign , ldx , ldy , nx , ny , nzl INTEGER , OPTIONAL , INTENT ( IN ) :: pl2ix (:) COMPLEX ( DP ) :: r ( : ) INTEGER :: i , k , j , err , idir , ip , kk , void REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 4 , ndims ) = - 1 LOGICAL :: dofft ( nfftx ), done INTEGER , PARAMETER :: stdout = 6 #if defined __HPM INTEGER :: OMP_GET_THREAD_NUM #endif #if defined(__OPENMP) INTEGER :: offset INTEGER :: nx_t , ny_t , nzl_t , ldx_t , ldy_t INTEGER :: itid , mytid , ntids INTEGER :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads EXTERNAL :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads #endif C_POINTER , SAVE :: fw_plan ( 2 , ndims ) = 0 C_POINTER , SAVE :: bw_plan ( 2 , ndims ) = 0 dofft ( 1 : nx ) = . TRUE . IF ( PRESENT ( pl2ix ) ) THEN IF ( SIZE ( pl2ix ) < nx ) & CALL fftx_error__ ( ' cft_2xy ' , ' wrong dimension for arg no. 8 ' , 1 ) DO i = 1 , nx IF ( pl2ix ( i ) < 1 ) dofft ( i ) = . FALSE . END DO END IF ! !   Here initialize table only if necessary ! CALL lookup () IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_2xy' ) #endif IF ( ldx /= nx . OR . ldy /= ny ) THEN IF ( isign < 0 ) THEN do j = 0 , nzl - 1 CALL dfftw_execute_dft ( fw_plan ( 1 , ip ), & r ( 1 + j * ldx * ldy :), r ( 1 + j * ldx * ldy :)) end do do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN j = i + ldx * ldy * ( k - 1 ) call dfftw_execute_dft ( fw_plan ( 2 , ip ), r ( j :), r ( j :)) END IF end do end do tscale = 1.0_DP / ( nx * ny ) CALL ZDSCAL ( ldx * ldy * nzl , tscale , r ( 1 ), 1 ) ELSE IF ( isign > 0 ) THEN do i = 1 , nx do k = 1 , nzl IF ( dofft ( i ) ) THEN j = i + ldx * ldy * ( k - 1 ) call dfftw_execute_dft ( bw_plan ( 2 , ip ), r ( j :), r ( j :)) END IF end do end do do j = 0 , nzl - 1 CALL dfftw_execute_dft ( bw_plan ( 1 , ip ), & r ( 1 + j * ldx * ldy :), r ( 1 + j * ldx * ldy :)) end do END IF ELSE IF ( isign < 0 ) THEN call dfftw_execute_dft ( fw_plan ( 1 , ip ), r ( 1 :), r ( 1 :)) tscale = 1.0_DP / ( nx * ny ) CALL ZDSCAL ( ldx * ldy * nzl , tscale , r ( 1 ), 1 ) ELSE IF ( isign > 0 ) THEN call dfftw_execute_dft ( bw_plan ( 1 , ip ), r ( 1 :), r ( 1 :)) END IF END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_2xy' ) #endif RETURN CONTAINS SUBROUTINE lookup () DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters done = ( ny == dims ( 1 , ip ) ) . AND . ( nx == dims ( 3 , ip ) ) done = done . AND . ( ldx == dims ( 2 , ip ) ) . AND . ( nzl == dims ( 4 , ip ) ) IF ( done ) EXIT END DO END SUBROUTINE lookup SUBROUTINE init_plan () #if defined(__OPENMP) CALL dfftw_cleanup_threads () void = fftw_init_threads () CALL dfftw_plan_with_nthreads ( omp_get_max_threads ()) #endif IF ( ldx /= nx . OR . ldy /= ny ) THEN IF ( fw_plan ( 2 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( fw_plan ( 2 , icurrent ) ) IF ( bw_plan ( 2 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( bw_plan ( 2 , icurrent ) ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 2 , icurrent ), 1 , ny , 1 , r ( 1 :), & ( / ldx * ldy / ), ldx , 1 , r ( 1 :), ( / ldx * ldy / ), ldx , 1 , idir , & FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 2 , icurrent ), 1 , ny , 1 , r ( 1 :), & ( / ldx * ldy / ), ldx , 1 , r ( 1 :), ( / ldx * ldy / ), ldx , 1 , idir , & FFTW_ESTIMATE ) IF ( fw_plan ( 1 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( fw_plan ( 1 , icurrent ) ) IF ( bw_plan ( 1 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( bw_plan ( 1 , icurrent ) ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 1 , icurrent ), 1 , nx , ny , r ( 1 :), & ( / ldx * ldy / ), 1 , ldx , r ( 1 :), ( / ldx * ldy / ), 1 , ldx , idir , & FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 1 , icurrent ), 1 , nx , ny , r ( 1 :), & ( / ldx * ldy / ), 1 , ldx , r ( 1 :), ( / ldx * ldy / ), 1 , ldx , idir , & FFTW_ESTIMATE ) ELSE IF ( fw_plan ( 1 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( fw_plan ( 1 , icurrent ) ) IF ( bw_plan ( 1 , icurrent ) /= 0 ) CALL dfftw_destroy_plan ( bw_plan ( 1 , icurrent ) ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 1 , icurrent ), 2 , ( / nx , ny / ), nzl ,& r ( 1 :), ( / nx , ny / ), 1 , nx * ny , r ( 1 :), ( / nx , ny / ), 1 , nx * ny , idir ,& FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 1 , icurrent ), 2 , ( / nx , ny / ), nzl ,& r ( 1 :), ( / nx , ny / ), 1 , nx * ny , r ( 1 :), ( / nx , ny / ), 1 , nx * ny , idir ,& FFTW_ESTIMATE ) END IF dims ( 1 , icurrent ) = ny ; dims ( 2 , icurrent ) = ldx ; dims ( 3 , icurrent ) = nx ; dims ( 4 , icurrent ) = nzl ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cft_2xy ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) !     driver routine for 3d complex fft of lengths nx, ny, nz !     input  :  f(ldx*ldy*ldz)  complex, transform is in-place !     ldx >= nx, ldy >= ny, ldz >= nz are the physical dimensions !     of the equivalent 3d array: f3d(ldx,ldy,ldz) !     (ldx>nx, ldy>ny, ldz>nz may be used on some architectures !      to reduce memory conflicts - not implemented for FFTW) !     isign > 0 : f(G) => f(R)   ; isign < 0 : f(R) => f(G) ! !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nz) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , isign COMPLEX ( DP ) :: f (:) INTEGER :: i , k , j , err , idir , ip REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 C_POINTER , save :: fw_plan ( ndims ) = 0 C_POINTER , save :: bw_plan ( ndims ) = 0 IF ( nx < 1 ) & call fftx_error__ ( 'cfft3d' , ' nx is less than 1 ' , 1 ) IF ( ny < 1 ) & call fftx_error__ ( 'cfft3d' , ' ny is less than 1 ' , 1 ) IF ( nz < 1 ) & call fftx_error__ ( 'cfft3' , ' nz is less than 1 ' , 1 ) ! !   Here initialize table only if necessary ! CALL lookup () IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF ! !   Now perform the 3D FFT using the machine specific driver ! IF ( isign < 0 ) THEN call dfftw_execute_dft ( fw_plan ( ip ), f ( 1 :), f ( 1 :)) tscale = 1.0_DP / DBLE ( nx * ny * nz ) call ZDSCAL ( nx * ny * nz , tscale , f ( 1 ), 1 ) ELSE IF ( isign > 0 ) THEN call dfftw_execute_dft ( bw_plan ( ip ), f ( 1 :), f ( 1 :)) END IF RETURN CONTAINS SUBROUTINE lookup () ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . & ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO END SUBROUTINE lookup SUBROUTINE init_plan () IF ( nx /= ldx . or . ny /= ldy . or . nz /= ldz ) & call fftx_error__ ( 'cfft3' , 'not implemented' , 3 ) IF ( fw_plan ( icurrent ) /= 0 ) CALL dfftw_destroy_plan ( fw_plan ( icurrent ) ) IF ( bw_plan ( icurrent ) /= 0 ) CALL dfftw_destroy_plan ( bw_plan ( icurrent ) ) idir = - 1 CALL dfftw_plan_dft_3d ( fw_plan ( icurrent ), nx , ny , nz , f ( 1 :), & f ( 1 :), idir , FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_dft_3d ( bw_plan ( icurrent ), nx , ny , nz , f ( 1 :), & f ( 1 :), idir , FFTW_ESTIMATE ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cfft3d ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs,  but using sticks! ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3ds ( f , nx , ny , nz , ldx , ldy , ldz , isign , & do_fft_x , do_fft_y ) ! !     driver routine for 3d complex \"reduced\" fft - see cfft3d !     The 3D fft are computed only on lines and planes which have !     non zero elements. These lines and planes are defined by !     the two integer vectors do_fft_x(ldy*nz) and do_fft_y(nz) !     (1 = perform fft, 0 = do not perform fft) !     This routine is implemented only for fftw, essl, acml !     If not implemented, cfft3d is called instead ! !---------------------------------------------------------------------- ! implicit none integer :: nx , ny , nz , ldx , ldy , ldz , isign ! !   logical dimensions of the fft !   physical dimensions of the f array !   sign of the transformation complex ( DP ) :: f ( ldx * ldy * ldz ) integer :: do_fft_x (:), do_fft_y (:) ! integer :: m , incx1 , incx2 INTEGER :: i , k , j , err , idir , ip , ii , jj REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 C_POINTER , SAVE :: fw_plan ( 3 , ndims ) = 0 C_POINTER , SAVE :: bw_plan ( 3 , ndims ) = 0 tscale = 1.0_DP ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',6I6)\") nx, ny, nz, ldx, ldy, ldz ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',24I2)\") do_fft_x ! WRITE( stdout, fmt=\"('DEBUG cfft3ds :',24I2)\") do_fft_y IF ( ny /= ldy ) & CALL fftx_error__ ( ' cfft3ds ' , ' wrong dimensions: ny /= ldy ' , 1 ) CALL lookup () IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one CALL init_plan () END IF IF ( isign > 0 ) THEN ! !  i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) THEN call dfftw_execute_dft ( bw_plan ( 1 , ip ), f ( ii : ), f ( ii : ) ) endif enddo enddo ! !  ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call dfftw_execute_dft ( bw_plan ( 2 , ip ), f ( ii : ), f ( ii : ) ) endif enddo ! !     ... k-direction ! incx1 = ldx * ldy ; incx2 = 1 ; m = ldx * ny call dfftw_execute_dft ( bw_plan ( 3 , ip ), f ( 1 :), f ( 1 :) ) ELSE ! !     ... k-direction ! incx1 = ldx * ny ; incx2 = 1 ; m = ldx * ny call dfftw_execute_dft ( fw_plan ( 3 , ip ), f ( 1 :), f ( 1 :) ) ! !     ... j-direction ... ! incx1 = ldx ; incx2 = 1 ; m = nx do k = 1 , nz ii = 1 + ldx * ldy * ( k - 1 ) if ( do_fft_y ( k ) == 1 ) then call dfftw_execute_dft ( fw_plan ( 2 , ip ), f ( ii : ), f ( ii : ) ) endif enddo ! !     i - direction ... ! incx1 = 1 ; incx2 = ldx ; m = 1 do k = 1 , nz do j = 1 , ny jj = j + ( k - 1 ) * ldy ii = 1 + ldx * ( jj - 1 ) if ( do_fft_x ( jj ) == 1 ) then call dfftw_execute_dft ( fw_plan ( 1 , ip ), f ( ii : ), f ( ii : ) ) endif enddo enddo call DSCAL ( 2 * ldx * ldy * nz , 1.0_DP / ( nx * ny * nz ), f ( 1 ), 1 ) END IF RETURN CONTAINS SUBROUTINE lookup () ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO END SUBROUTINE lookup SUBROUTINE init_plan () IF ( fw_plan ( 1 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( fw_plan ( 1 , icurrent ) ) IF ( bw_plan ( 1 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( bw_plan ( 1 , icurrent ) ) IF ( fw_plan ( 2 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( fw_plan ( 2 , icurrent ) ) IF ( bw_plan ( 2 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( bw_plan ( 2 , icurrent ) ) IF ( fw_plan ( 3 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( fw_plan ( 3 , icurrent ) ) IF ( bw_plan ( 3 , icurrent ) /= 0 ) & CALL dfftw_destroy_plan ( bw_plan ( 3 , icurrent ) ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 1 , icurrent ), & 1 , nx , 1 , f ( 1 :), ( / ldx , ldy , ldz / ), 1 , ldx , & f ( 1 :), ( / ldx , ldy , ldz / ), 1 , ldx , idir , FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 1 , icurrent ), & 1 , nx , 1 , f ( 1 :), ( / ldx , ldy , ldz / ), 1 , ldx , & f ( 1 :), ( / ldx , ldy , ldz / ), 1 , ldx , idir , FFTW_ESTIMATE ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 2 , icurrent ), & 1 , ny , nx , f ( 1 :), ( / ldx , ldy , ldz / ), ldx , 1 , & f ( 1 :), ( / ldx , ldy , ldz / ), ldx , 1 , idir , FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 2 , icurrent ), & 1 , ny , nx , f ( 1 :), ( / ldx , ldy , ldz / ), ldx , 1 , & f ( 1 :), ( / ldx , ldy , ldz / ), ldx , 1 , idir , FFTW_ESTIMATE ) idir = - 1 CALL dfftw_plan_many_dft ( fw_plan ( 3 , icurrent ), & 1 , nz , nx * ny , f ( 1 :), ( / ldx , ldy , ldz / ), ldx * ldy , 1 , & f ( 1 :), ( / ldx , ldy , ldz / ), ldx * ldy , 1 , idir , FFTW_ESTIMATE ) idir = 1 CALL dfftw_plan_many_dft ( bw_plan ( 3 , icurrent ), & 1 , nz , nx * ny , f ( 1 :), ( / ldx , ldy , ldz / ), ldx * ldy , 1 , & f ( 1 :), ( / ldx , ldy , ldz / ), ldx * ldy , 1 , idir , FFTW_ESTIMATE ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END SUBROUTINE init_plan END SUBROUTINE cfft3ds !=----------------------------------------------------------------------=! END MODULE fft_scalar !=----------------------------------------------------------------------=! #endif","tags":"","loc":"sourcefile/fft_scalar.fftw3.f90.html","title":"fft_scalar.FFTW3.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #if defined(__SX6) !=----------------------------------------------------------------------=! MODULE fft_scalar !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_1z , cft_2xy , cfft3d , cfft3ds ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) !   ndims   Number of different FFT tables that the module !           could keep into memory without reinitialization !   nfftx   Max allowed fft dimension INTEGER , PARAMETER :: ndims = 3 , nfftx = 2049 !   Workspace that is statically allocated is defined here !   in order to avoid multiple copies of the same workspace !   lwork:   Dimension of the work space array (if any) !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"z\" ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_1z ( c , nsl , nz , ldz , isign , cout ) !     driver routine for nsl 1d complex fft's of length nz !     ldz >= nz is the distance between sequences to be transformed !     (ldz>nz is used on some architectures to reduce memory conflicts) !     input  :  c(ldz*nsl)   (complex) !     output : cout(ldz*nsl) (complex - NOTA BENE: transform is not in-place!) !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nz, nsl, ldz) are stored and re-used if available INTEGER , INTENT ( IN ) :: isign INTEGER , INTENT ( IN ) :: nsl , nz , ldz COMPLEX ( DP ) :: c (:), cout (:) REAL ( DP ) :: tscale INTEGER :: i , err , idir , ip , void INTEGER , SAVE :: zdims ( 3 , ndims ) = - 1 INTEGER , SAVE :: icurrent = 1 LOGICAL :: done INTEGER :: tid ! ...   Machine-Dependent parameters, work arrays and tables of factors !   ltabl   Dimension of the tables of factors calculated at the !           initialization stage #if defined(__OPENMP) INTEGER :: offset , ldz_t INTEGER :: omp_get_max_threads EXTERNAL :: omp_get_max_threads #endif !   NEC MathKeisan INTEGER , PARAMETER :: ltabl = 2 * nfftx + 64 REAL ( DP ), SAVE :: tablez ( ltabl , ndims ) REAL ( DP ) :: work ( 4 * nz * nsl ) COMPLEX ( DP ) :: DUMMY INTEGER , SAVE :: isys = 1 IF ( nsl < 0 ) THEN CALL fftx_error__ ( \" fft_scalar: cft_1z \" , \" nsl out of range \" , nsl ) END IF ! !   Here initialize table only if necessary ! DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters done = ( nz == zdims ( 1 , ip ) ) IF ( done ) EXIT END DO IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one ! WRITE( stdout, fmt=\"('DEBUG cft_1z, reinitializing tables ', I3)\" ) icurrent CALL ZZFFTM ( 0 , nz , 1 , 1.0_DP , DUMMY , ldz , DUMMY , ldz , & tablez ( 1 , icurrent ), work , isys ) zdims ( 1 , icurrent ) = nz ; zdims ( 2 , icurrent ) = nsl ; zdims ( 3 , icurrent ) = ldz ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_1z' ) #endif IF ( isign < 0 ) THEN idir = - 1 tscale = 1.0_DP / nz ELSE IF ( isign > 0 ) THEN idir = 1 tscale = 1.0_DP END IF IF ( isign /= 0 ) CALL ZZFFTM ( idir , nz , nsl , tscale , c ( 1 ), ldz , & cout ( 1 ), ldz , tablez ( 1 , ip ), work , isys ) #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_1z' ) #endif RETURN END SUBROUTINE cft_1z ! ! !=----------------------------------------------------------------------=! ! ! ! !         FFT along \"x\" and \"y\" direction ! ! ! !=----------------------------------------------------------------------=! ! ! SUBROUTINE cft_2xy ( r , nzl , nx , ny , ldx , ldy , isign , pl2ix ) !     driver routine for nzl 2d complex fft's of lengths nx and ny !     input : r(ldx*ldy)  complex, transform is in-place !     ldx >= nx, ldy >= ny are the physical dimensions of the equivalent !     2d array: r2d(ldx, ldy) (x first dimension, y second dimension) !     (ldx>nx, ldy>ny used on some architectures to reduce memory conflicts) !     pl2ix(nx) (optional) is 1 for columns along y to be transformed !     isign > 0 : forward (f(G)=>f(R)), isign <0 backward (f(R) => f(G)) !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nzl,ldx) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: isign , ldx , ldy , nx , ny , nzl INTEGER , OPTIONAL , INTENT ( IN ) :: pl2ix (:) COMPLEX ( DP ) :: r ( : ) INTEGER :: i , k , j , err , idir , ip , kk , void REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 4 , ndims ) = - 1 LOGICAL :: dofft ( nfftx ), done INTEGER , PARAMETER :: stdout = 6 #if defined(__OPENMP) INTEGER :: offset INTEGER :: nx_t , ny_t , nzl_t , ldx_t , ldy_t INTEGER :: itid , mytid , ntids INTEGER :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads EXTERNAL :: omp_get_thread_num , omp_get_num_threads , omp_get_max_threads #endif INTEGER , PARAMETER :: ltabl = 2 * nfftx + 64 REAL ( DP ), SAVE :: tablex ( ltabl , ndims ), tabley ( ltabl , ndims ) REAL ( DP ) :: work ( 4 * nx * ny ) COMPLEX ( DP ) :: XY ( ldx * ny ) COMPLEX ( DP ) :: DUMMY INTEGER , SAVE :: isys = 1 dofft ( 1 : nx ) = . TRUE . IF ( PRESENT ( pl2ix ) ) THEN IF ( SIZE ( pl2ix ) < nx ) & CALL fftx_error__ ( ' cft_2xy ' , ' wrong dimension for arg no. 8 ' , 1 ) DO i = 1 , nx IF ( pl2ix ( i ) < 1 ) dofft ( i ) = . FALSE . END DO END IF ! WRITE( stdout,*) 'DEBUG: ', COUNT( dofft ) ! !   Here initialize table only if necessary ! DO ip = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters done = ( ny == dims ( 1 , ip ) ) . AND . ( nx == dims ( 3 , ip ) ) done = done . AND . ( ldx == dims ( 2 , ip ) ) . AND . ( nzl == dims ( 4 , ip ) ) IF ( done ) EXIT END DO IF ( . NOT . done ) THEN !   no table exist for these parameters !   initialize a new one ! WRITE( stdout, fmt=\"('DEBUG cft_2xy, reinitializing tables ', I3)\" ) icurrent CALL ZZFFT ( 0 , ny , 1.0_DP , DUMMY , DUMMY , & tabley ( 1 , icurrent ), work , isys ) CALL ZZFFTM ( 0 , nx , 1 , 1.0_DP , DUMMY , ldx , DUMMY , ldx , & tablex ( 1 , icurrent ), work , isys ) dims ( 1 , icurrent ) = ny ; dims ( 2 , icurrent ) = ldx ; dims ( 3 , icurrent ) = nx ; dims ( 4 , icurrent ) = nzl ; ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the FFTs using machine specific drivers ! #if defined(__FFT_CLOCKS) CALL start_clock ( 'cft_2xy' ) #endif IF ( isign < 0 ) THEN idir = - 1 tscale = 1.0_DP / ( nx * ny ) DO k = 0 , nzl - 1 kk = k * ldx * ldy ! FORWARD: ny FFTs in the X direction CALL ZZFFTM ( idir , nx , ny , tscale , r ( kk + 1 ), ldx , r ( kk + 1 ), ldx , & tablex ( 1 , ip ), work ( 1 ), isys ) ! FORWARD: nx FFTs in the Y direction DO i = 1 , nx IF ( dofft ( i ) ) THEN DO j = 0 , ny - 1 XY ( j + 1 ) = r ( i + ( j ) * ldx + kk ) END DO CALL ZZFFT ( idir , ny , 1.0_DP , XY , XY , tabley ( 1 , ip ), & work ( 1 ), isys ) DO j = 0 , ny - 1 r ( i + ( j ) * ldx + kk ) = XY ( j + 1 ) END DO END IF END DO END DO ELSE IF ( isign > 0 ) THEN idir = 1 tscale = 1.0_DP DO k = 0 , nzl - 1 ! BACKWARD: nx FFTs in the Y direction kk = ( k ) * ldx * ldy DO i = 1 , nx IF ( dofft ( i ) ) THEN DO j = 0 , ny - 1 XY ( j + 1 ) = r ( i + ( j ) * ldx + kk ) END DO CALL ZZFFT ( idir , ny , 1.0_DP , XY , XY , tabley ( 1 , ip ), & work ( 1 ), isys ) DO j = 0 , ny - 1 r ( i + ( j ) * ldx + kk ) = XY ( j + 1 ) END DO END IF END DO ! BACKWARD: ny FFTs in the X direction CALL ZZFFTM ( idir , nx , ny , tscale , r ( kk + 1 ), ldx , r ( kk + 1 ), ldx , & tablex ( 1 , ip ), work ( 1 ), isys ) END DO END IF #if defined(__FFT_CLOCKS) CALL stop_clock ( 'cft_2xy' ) #endif RETURN END SUBROUTINE cft_2xy ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) !     driver routine for 3d complex fft of lengths nx, ny, nz !     input  :  f(ldx*ldy*ldz)  complex, transform is in-place !     ldx >= nx, ldy >= ny, ldz >= nz are the physical dimensions !     of the equivalent 3d array: f3d(ldx,ldy,ldz) !     (ldx>nx, ldy>ny, ldz>nz may be used on some architectures !      to reduce memory conflicts - not implemented for FFTW) !     isign > 0 : f(G) => f(R)   ; isign < 0 : f(R) => f(G) ! !     Up to \"ndims\" initializations (for different combinations of input !     parameters nx,ny,nz) are stored and re-used if available IMPLICIT NONE INTEGER , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , isign COMPLEX ( DP ) :: f (:) INTEGER :: i , k , j , err , idir , ip REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 INTEGER , PARAMETER :: ltabl = 60 INTEGER , PARAMETER :: lwork = 195 + 6 * nfftx INTEGER , SAVE :: iw0 ( ltabl , ndims ) INTEGER :: k_off , kj_offset REAL ( DP ), SAVE :: auxp ( lwork , ndims ) ! not sure whether auxp is work space or not COMPLEX ( DP ), DIMENSION (:), ALLOCATABLE :: cw2 COMPLEX ( DP ) :: f_out ( size ( f )) #if defined(ASL) && defined(MICRO) INTEGER :: nbtasks COMMON / NEC_ASL_PARA / nbtasks #endif IF ( nx < 1 ) & call fftx_error__ ( 'cfft3d' , ' nx is less than 1 ' , 1 ) IF ( ny < 1 ) & call fftx_error__ ( 'cfft3d' , ' ny is less than 1 ' , 1 ) IF ( nz < 1 ) & call fftx_error__ ( 'cfft3' , ' nz is less than 1 ' , 1 ) #if defined(ASL) ALLOCATE ( cw2 ( ldx * ldy * ldz )) CALL zfc3cl ( f ( 1 ), nx , ny , nz , ldx , ldy , ldz , err ) #else ALLOCATE ( cw2 ( 6 * ldx * ldy * ldz )) #endif ! !   Here initialize table only if necessary ! ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . & ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) ) THEN ip = i EXIT END IF END DO IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one #if defined(ASL) #if defined(MICRO) CALL hfc3fb ( nx , ny , nz , f ( 1 ) , ldx , ldy , ldz , 0 , & iw0 ( 1 , icurrent ), auxp ( 1 , icurrent ), cw2 ( 1 ), nbtasks , err ) #else CALL zfc3fb ( nx , ny , nz , f ( 1 ), ldx , ldy , ldz , 0 , & iw0 ( 1 , icurrent ), auxp ( 1 , icurrent ), cw2 ( 1 ), err ) #endif #else ! for some reason the error variable is not set by this driver on NEC SX machines err = 0 CALL ZZFFT3D ( 0 , nx , ny , nz , 1.0_DP , f ( 1 ), ldx , ldy , & & f ( 1 ), ldx , ldy , auxp ( 1 , icurrent ), cw2 ( 1 ), err ) #endif IF ( err /= 0 ) CALL fftx_error__ ( 'cfft3d' , 'FFT init returned an error ' , err ) dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny ; dims ( 3 , icurrent ) = nz ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !   Now perform the 3D FFT using the machine specific driver ! #if defined(ASL) #if defined(MICRO) CALL hfc3bf ( nx , ny , nz , f ( 1 ), ldx , ldy , ldz , & - isign , iw0 ( 1 , ip ), auxp ( 1 , ip ), cw2 ( 1 ), nbtasks , err ) #else CALL zfc3bf ( nx , ny , nz , f ( 1 ), ldx , ldy , ldz , & - isign , iw0 ( 1 , ip ), auxp ( 1 , ip ), cw2 ( 1 ), err ) #endif IF ( isign < 0 ) THEN tscale = 1.0_DP / DBLE ( nx * ny * nz ) call ZDSCAL ( ldx * ldy * ldz , tscale , f ( 1 ), 1 ) END IF #else ! for some reason the error variable is not set by this driver on NEC SX machines err = 0 tscale = 1.0_DP IF ( isign < 0 ) THEN tscale = tscale / DBLE ( nx * ny * nz ) END IF CALL ZZFFT3D ( isign , nx , ny , nz , tscale , f ( 1 ), ldx , ldy , & f_out ( 1 ), ldx , ldy , auxp ( 1 , ip ), cw2 ( 1 ), err ) !$omp parallel do private(j,i,k_off,kj_offset) do k = 1 , nz k_off = ( k - 1 ) * ldx * ldy do j = 1 , ny kj_offset = ( j - 1 ) * ldx + k_off do i = 1 , nx f ( i + kj_offset ) = f_out ( i + kj_offset ) end do end do end do !$omp end parallel do #endif IF ( err /= 0 ) CALL fftx_error__ ( 'cfft3d' , 'FFT returned an error ' , err ) DEALLOCATE ( cw2 ) RETURN END SUBROUTINE cfft3d ! !=----------------------------------------------------------------------=! ! ! ! !         3D scalar FFTs,  but using sticks! ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cfft3ds ( f , nx , ny , nz , ldx , ldy , ldz , isign , & do_fft_x , do_fft_y ) ! !     driver routine for 3d complex \"reduced\" fft - see cfft3d !     The 3D fft are computed only on lines and planes which have !     non zero elements. These lines and planes are defined by !     the two integer vectors do_fft_x(ldy*nz) and do_fft_y(nz) !     (1 = perform fft, 0 = do not perform fft) !     This routine is implemented only for fftw, essl, acml !     If not implemented, cfft3d is called instead ! !---------------------------------------------------------------------- ! implicit none integer :: nx , ny , nz , ldx , ldy , ldz , isign ! !   logical dimensions of the fft !   physical dimensions of the f array !   sign of the transformation complex ( DP ) :: f ( ldx * ldy * ldz ) integer :: do_fft_x (:), do_fft_y (:) ! integer :: m , incx1 , incx2 INTEGER :: i , k , j , err , idir , ip , ii , jj REAL ( DP ) :: tscale INTEGER , SAVE :: icurrent = 1 INTEGER , SAVE :: dims ( 3 , ndims ) = - 1 CALL cfft3d ( f , nx , ny , nz , ldx , ldy , ldz , isign ) RETURN END SUBROUTINE cfft3ds !=----------------------------------------------------------------------=! END MODULE fft_scalar !=----------------------------------------------------------------------=! #endif","tags":"","loc":"sourcefile/fft_scalar.sx6.f90.html","title":"fft_scalar.SX6.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !--------------------------------------------------------------------------! ! FFT scalar drivers Module - contains machine-dependent routines for      ! ! FFTW, FFTW3, ESSL (both 3d for serial execution and 1d+2d FFTs for       ! ! parallel execution; NEC ASL libraries (3d only, no parallel execution)   ! ! Written by Carlo Cavazzoni, modified by P. Giannozzi, contributions      ! ! by Martin Hilgemans, Guido Roma, Pascal Thibaudeau, Stephane Lefranc,    ! ! Nicolas Lacorne, Filippo Spiga, Nicola Varini - Last update Jul 2015     ! !--------------------------------------------------------------------------! #include \"fft_defs.h\" !=----------------------------------------------------------------------=! MODULE fft_smallbox !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding IMPLICIT NONE SAVE PRIVATE PUBLIC :: cft_b , cft_b_omp_init , cft_b_omp ! ...   Local Parameter INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) !   ndims   Number of different FFT tables that the module !           could keep into memory without reinitialization INTEGER , PARAMETER :: ndims = 3 !   Workspace that is statically allocated is defined here !   in order to avoid multiple copies of the same workspace !   lwork:   Dimension of the work space array (if any) INTEGER :: cft_b_dims ( 4 ) !$omp threadprivate (cft_b_dims) C_POINTER :: cft_b_bw_planz = 0 !$omp threadprivate (cft_b_bw_planz) C_POINTER :: cft_b_bw_planx = 0 !$omp threadprivate (cft_b_bw_planx) C_POINTER :: cft_b_bw_plany = 0 !$omp threadprivate (cft_b_bw_plany) !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !=----------------------------------------------------------------------=! ! ! ! !         3D parallel FFT on sub-grids ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_b ( f , nx , ny , nz , ldx , ldy , ldz , imin3 , imax3 , sgn ) !     driver routine for 3d complex fft's on box grid, parallel case !     fft along xy is done only on planes that correspond to dense grid !     planes on the current processor, i.e. planes with imin3 <= nz <= imax3 !     implemented for essl, fftw, scsl, complib, only for sgn=1 (f(R) => f(G)) !     (beware: here the \"essl\" convention for the sign of the fft is used!) ! implicit none integer nx , ny , nz , ldx , ldy , ldz , imin3 , imax3 , sgn complex ( dp ) :: f (:) integer isign , naux , ibid , nplanes , nstart , k real ( DP ) :: tscale integer :: ip , i integer , save :: icurrent = 1 integer , save :: dims ( 4 , ndims ) = - 1 C_POINTER , save :: bw_planz ( ndims ) = 0 C_POINTER , save :: bw_planx ( ndims ) = 0 C_POINTER , save :: bw_plany ( ndims ) = 0 C_POINTER , save :: bw_planxy ( ndims ) = 0 isign = - sgn tscale = 1.0_DP if ( isign > 0 ) then call fftx_error__ ( 'cft_b' , 'not implemented' , isign ) end if ! ! 2d fft on xy planes - only needed planes are transformed ! note that all others are left in an unusable state ! nplanes = imax3 - imin3 + 1 nstart = ( imin3 - 1 ) * ldx * ldy + 1 ! !   Here initialize table only if necessary ! ip = - 1 DO i = 1 , ndims !   first check if there is already a table initialized !   for this combination of parameters IF ( ( nx == dims ( 1 , i ) ) . and . ( ny == dims ( 2 , i ) ) . and . & ( nz == dims ( 3 , i ) ) . and . ( nplanes == dims ( 4 , i ) ) ) THEN ip = i EXIT END IF END DO IF ( ip == - 1 ) THEN !   no table exist for these parameters !   initialize a new one if ( bw_planz ( icurrent ) /= 0 ) & call DESTROY_PLAN_1D ( bw_planz ( icurrent ) ) call CREATE_PLAN_1D ( bw_planz ( icurrent ), nz , 1 ) if ( bw_planx ( icurrent ) /= 0 ) & call DESTROY_PLAN_1D ( bw_planx ( icurrent ) ) call CREATE_PLAN_1D ( bw_planx ( icurrent ), nx , 1 ) if ( bw_plany ( icurrent ) /= 0 ) & call DESTROY_PLAN_1D ( bw_plany ( icurrent ) ) call CREATE_PLAN_1D ( bw_plany ( icurrent ), ny , 1 ) if ( bw_planxy ( icurrent ) /= 0 ) & call DESTROY_PLAN_2D ( bw_planxy ( icurrent ) ) call CREATE_PLAN_2D ( bw_planxy ( icurrent ), nx , ny , 1 ) ! dims ( 1 , icurrent ) = nx ; dims ( 2 , icurrent ) = ny dims ( 3 , icurrent ) = nz ; dims ( 4 , icurrent ) = nplanes ip = icurrent icurrent = MOD ( icurrent , ndims ) + 1 END IF ! !  fft along Z ! call FFTW_INPLACE_DRV_1D ( bw_planz ( ip ), ldx * ldy , f ( 1 ), ldx * ldy , 1 ) ! !  fft along Y !  fft along X ! do k = imin3 , imax3 call FFTW_INPLACE_DRV_1D ( bw_plany ( ip ), nx , f (( k - 1 ) * ldx * ldy + 1 ), ldx , 1 ) call FFTW_INPLACE_DRV_1D ( bw_planx ( ip ), ny , f (( k - 1 ) * ldx * ldy + 1 ), 1 , ldx ) end do RETURN END SUBROUTINE cft_b ! !=----------------------------------------------------------------------=! ! ! ! !   3D parallel FFT on sub-grids, to be called inside OpenMP region ! ! ! !=----------------------------------------------------------------------=! ! SUBROUTINE cft_b_omp_init ( nx , ny , nz ) !     driver routine for 3d complex fft's on box grid, init subroutine ! implicit none integer , INTENT ( IN ) :: nx , ny , nz ! !   Here initialize table ! !$omp parallel IF ( cft_b_bw_planz == 0 ) THEN CALL CREATE_PLAN_1D ( cft_b_bw_planz , nz , 1 ) cft_b_dims ( 3 ) = nz END IF IF ( cft_b_bw_planx == 0 ) THEN CALL CREATE_PLAN_1D ( cft_b_bw_planx , nx , 1 ) cft_b_dims ( 1 ) = nx END IF IF ( cft_b_bw_plany == 0 ) THEN CALL CREATE_PLAN_1D ( cft_b_bw_plany , ny , 1 ) cft_b_dims ( 2 ) = ny END IF !$omp end parallel RETURN END SUBROUTINE cft_b_omp_init SUBROUTINE cft_b_omp ( f , nx , ny , nz , ldx , ldy , ldz , imin3 , imax3 , sgn ) !     driver routine for 3d complex fft's on box grid, parallel (MPI+OpenMP) case !     fft along xy is done only on planes that correspond to dense grid !     planes on the current processor, i.e. planes with imin3 <= nz <= imax3 !     implemented ONLY for internal fftw, and only for sgn=1 (f(R) => f(G)) !     (beware: here the \"essl\" convention for the sign of the fft is used!) ! !     This driver is meant for calls inside parallel OpenMP sections ! implicit none integer , INTENT ( IN ) :: nx , ny , nz , ldx , ldy , ldz , imin3 , imax3 , sgn complex ( dp ) :: f (:) INTEGER , SAVE :: k !$omp threadprivate (k) if ( - sgn > 0 ) then CALL fftx_error__ ( 'cft_b_omp' , 'forward transform not implemented' , 1 ) end if IF ( ( cft_b_bw_planz == 0 ) . or . ( cft_b_bw_planx == 0 ) . or . ( cft_b_bw_plany == 0 ) ) THEN CALL fftx_error__ ( 'cft_b_omp' , 'plan not initialized' , 1 ) END IF !  consistency check IF ( ( nx /= cft_b_dims ( 1 ) ) . or . ( ny /= cft_b_dims ( 2 ) ) . or . ( nz /= cft_b_dims ( 3 ) ) ) THEN CALL fftx_error__ ( 'cft_b_omp' , 'dimensions are inconsistent with the existing plan' , 1 ) END IF !  fft along Z ! call FFTW_INPLACE_DRV_1D ( cft_b_bw_planz , ldx * ldy , f ( 1 ), ldx * ldy , 1 ) ! !  fft along Y !  fft along X ! do k = imin3 , imax3 call FFTW_INPLACE_DRV_1D ( cft_b_bw_plany , nx , f (( k - 1 ) * ldx * ldy + 1 ), ldx , 1 ) call FFTW_INPLACE_DRV_1D ( cft_b_bw_planx , ny , f (( k - 1 ) * ldx * ldy + 1 ), 1 , ldx ) end do RETURN END SUBROUTINE cft_b_omp !=----------------------------------------------------------------------=! END MODULE fft_smallbox !=----------------------------------------------------------------------=!","tags":"","loc":"sourcefile/fft_smallbox.f90.html","title":"fft_smallbox.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! #include \"fft_defs.h\" !=----------------------------------------------------------------------=! MODULE fft_support !=----------------------------------------------------------------------=! USE , intrinsic :: iso_c_binding IMPLICIT NONE SAVE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) PRIVATE PUBLIC :: good_fft_dimension , allowed , good_fft_order !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! !         FFT support Functions/Subroutines ! !=----------------------------------------------------------------------=! ! ! integer function good_fft_dimension ( n ) ! ! Determines the optimal maximum dimensions of fft arrays ! Useful on some machines to avoid memory conflicts ! IMPLICIT NONE INTEGER :: n , nx REAL ( DP ) :: log2n ! ! this is the default: max dimension = fft dimension nx = n ! #if defined(__ESSL) || defined(__LINUX_ESSL) log2n = LOG ( dble ( n ) ) / LOG ( 2.0_DP ) ! log2n is the logarithm of n in base 2 IF ( ABS ( NINT ( log2n ) - log2n ) < 1.0 d - 8 ) nx = n + 1 ! if n is a power of 2 (log2n is integer) increase dimension by 1 #elif defined(__SX6) ! if ( mod ( n , 2 ) == 0 ) nx = n + 1 ! for nec vector machines: if n is even increase dimension by 1 ! #endif ! good_fft_dimension = nx return end function good_fft_dimension !=----------------------------------------------------------------------=! function allowed ( nr ) ! find if the fft dimension is a good one ! a \"bad one\" is either not implemented (as on IBM with ESSL) ! or implemented but with awful performances (most other cases) implicit none integer :: nr logical :: allowed integer :: pwr ( 5 ) integer :: mr , i , fac , p , maxpwr integer :: factors ( 5 ) = ( / 2 , 3 , 5 , 7 , 11 / ) ! find the factors of the fft dimension mr = nr pwr = 0 factors_loop : do i = 1 , 5 fac = factors ( i ) maxpwr = NINT ( LOG ( DBLE ( mr ) ) / LOG ( DBLE ( fac ) ) ) + 1 do p = 1 , maxpwr if ( mr == 1 ) EXIT factors_loop if ( MOD ( mr , fac ) == 0 ) then mr = mr / fac pwr ( i ) = pwr ( i ) + 1 endif enddo end do factors_loop IF ( nr /= ( mr * 2 ** pwr ( 1 ) * 3 ** pwr ( 2 ) * 5 ** pwr ( 3 ) * 7 ** pwr ( 4 ) * 11 ** pwr ( 5 ) ) ) & CALL fftx_error__ ( ' allowed ' , ' what ?!? ' , 1 ) if ( mr /= 1 ) then ! fft dimension contains factors > 11 : no good in any case allowed = . false . else #if defined(__ESSL) || defined(__LINUX_ESSL) ! IBM machines with essl libraries allowed = ( pwr ( 1 ) >= 1 ) . and . ( pwr ( 2 ) <= 2 ) . and . ( pwr ( 3 ) <= 1 ) . and . & ( pwr ( 4 ) <= 1 ) . and . ( pwr ( 5 ) <= 1 ) . and . & ( ( ( pwr ( 2 ) == 0 ) . and . ( pwr ( 3 ) + pwr ( 4 ) + pwr ( 5 ) ) <= 2 ) . or . & ( ( pwr ( 2 ) /= 0 ) . and . ( pwr ( 3 ) + pwr ( 4 ) + pwr ( 5 ) ) <= 1 ) ) #else ! fftw and all other cases: no factors 7 and 11 allowed = ( ( pwr ( 4 ) == 0 ) . and . ( pwr ( 5 ) == 0 ) ) #endif endif return end function allowed !=----------------------------------------------------------------------=! INTEGER FUNCTION good_fft_order ( nr , np ) ! !    This function find a \"good\" fft order value greater or equal to \"nr\" ! !    nr  (input) tentative order n of a fft ! !    np  (optional input) if present restrict the search of the order !        in the ensemble of multiples of np ! !    Output: the same if n is a good number !         the closest higher number that is good !         an fft order is not good if not implemented (as on IBM with ESSL) !         or implemented but with awful performances (most other cases) ! USE fft_param IMPLICIT NONE INTEGER , INTENT ( IN ) :: nr INTEGER , OPTIONAL , INTENT ( IN ) :: np INTEGER :: new new = nr IF ( PRESENT ( np ) ) THEN DO WHILE ( ( ( . NOT . allowed ( new ) ) . OR . ( MOD ( new , np ) /= 0 ) ) . AND . ( new <= nfftx ) ) new = new + 1 END DO ELSE DO WHILE ( ( . NOT . allowed ( new ) ) . AND . ( new <= nfftx ) ) new = new + 1 END DO END IF IF ( new > nfftx ) & CALL fftx_error__ ( ' good_fft_order ' , ' fft order too large ' , new ) good_fft_order = new RETURN END FUNCTION good_fft_order !=----------------------------------------------------------------------=! END MODULE fft_support !=----------------------------------------------------------------------=!","tags":"","loc":"sourcefile/fft_support.f90.html","title":"fft_support.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! MODULE fft_types IMPLICIT NONE SAVE INTEGER :: stdout = 6 TYPE fft_dlay_descriptor INTEGER :: nst ! total number of sticks INTEGER , POINTER :: nsp (:) ! number of sticks per processor ( potential ) ! using proc index starting from 1 !! ! on proc mpime -> nsp( mpime + 1 ) INTEGER , POINTER :: nsw (:) ! number of sticks per processor ( wave func ) ! using proc index as above INTEGER :: nr1 = 0 ! INTEGER :: nr2 = 0 ! effective FFT dimensions of the 3D grid (global) INTEGER :: nr3 = 0 ! INTEGER :: nr1x = 0 ! FFT grids leading dimensions INTEGER :: nr2x = 0 ! dimensions of the arrays for the 3D grid (global) INTEGER :: nr3x = 0 ! may differ from nr1 ,nr2 ,nr3 in order to boost performances INTEGER :: npl = 0 ! number of \"Z\" planes for this processor = npp( mpime + 1 ) INTEGER :: nnp = 0 ! number of 0 and non 0 sticks in a plane ( ~nr1*nr2/nproc ) INTEGER :: nnr = 0 ! local number of FFT grid elements  ( ~nr1*nr2*nr3/proc ) ! size of the arrays allocated for the FFT, local to each processor: ! in parallel execution may differ from nr1x*nr2x*nr3x ! Not to be confused either with nr1*nr2*nr3 INTEGER , POINTER :: ngl (:) ! per proc. no. of non zero charge density/potential components INTEGER , POINTER :: nwl (:) ! per proc. no. of non zero wave function plane components INTEGER , POINTER :: npp (:) ! number of \"Z\" planes per processor INTEGER , POINTER :: ipp (:) ! offset of the first \"Z\" plane on each proc ( 0 on the first proc!!!) INTEGER , POINTER :: iss (:) ! index of the first stick on each proc INTEGER , POINTER :: isind (:) ! for each position in the plane indicate the stick index INTEGER , POINTER :: ismap (:) ! for each stick in the plane indicate the position INTEGER , POINTER :: iplp (:) ! indicate which \"Y\" plane should be FFTed ( potential ) INTEGER , POINTER :: iplw (:) ! indicate which \"Y\" plane should be FFTed ( wave func ) ! !  descriptor id and pointer, for future use ! INTEGER :: id INTEGER :: tptr ! !  Sub (box) grid descriptor ! INTEGER , POINTER :: irb (:,:) ! the offset of the box corner INTEGER , POINTER :: imin3 (:) ! the starting local plane INTEGER , POINTER :: imax3 (:) ! the last local plane INTEGER , POINTER :: np3 (:) ! number of local plane for the box fft ! !  fft parallelization ! INTEGER :: mype ! my processor id (starting from 0) in the fft group INTEGER :: comm ! communicator of the fft gruop INTEGER :: nproc ! number of processor in the fft group INTEGER :: root ! root processor ! !  task groups ! LOGICAL :: have_task_groups ! INTEGER :: me_pgrp ! task id for plane wave task group INTEGER :: nogrp ! number of proc. in an orbital \"task group\" INTEGER :: npgrp ! number of proc. in a plane-wave \"task group\" INTEGER :: ogrp_comm ! orbital group communicator INTEGER :: pgrp_comm ! plane-wave group communicator INTEGER , POINTER :: nolist (:) ! list of pes in orbital group INTEGER , POINTER :: nplist (:) ! list of pes in pw group ! INTEGER :: tg_nnr ! maximum among nnr INTEGER , POINTER :: tg_nsw (:) ! number of sticks per task group ( wave func ) INTEGER , POINTER :: tg_npp (:) ! number of \"Z\" planes per task group INTEGER , POINTER :: tg_snd (:) ! number of element to be sent in group redist INTEGER , POINTER :: tg_rcv (:) ! number of element to be received in group redist INTEGER , POINTER :: tg_psdsp (:) ! send displacement for all to all (pack) INTEGER , POINTER :: tg_usdsp (:) ! send displacement for all to all (unpack) INTEGER , POINTER :: tg_rdsp (:) ! receive displacement for all to all ! END TYPE INTEGER , PRIVATE :: icount = 0 CONTAINS SUBROUTINE fft_dlay_allocate ( desc , mype , root , nproc , comm , nogrp , nx , ny ) TYPE ( fft_dlay_descriptor ) :: desc INTEGER , INTENT ( in ) :: mype , root , nproc , comm , nx , ny ! mype starting from 0 INTEGER , INTENT ( in ) :: nogrp ! number of task groups ALLOCATE ( desc % nsp ( nproc ) ) ALLOCATE ( desc % nsw ( nproc ) ) ALLOCATE ( desc % ngl ( nproc ) ) ALLOCATE ( desc % nwl ( nproc ) ) ALLOCATE ( desc % npp ( nproc ) ) ALLOCATE ( desc % ipp ( nproc ) ) ALLOCATE ( desc % iss ( nproc ) ) ALLOCATE ( desc % isind ( nx * ny ) ) ALLOCATE ( desc % ismap ( nx * ny ) ) ALLOCATE ( desc % iplp ( nx ) ) ALLOCATE ( desc % iplw ( nx ) ) desc % nsp = 0 desc % nsw = 0 desc % ngl = 0 desc % nwl = 0 desc % npp = 0 desc % ipp = 0 desc % iss = 0 desc % isind = 0 desc % ismap = 0 desc % iplp = 0 desc % iplw = 0 desc % id = 0 desc % mype = mype desc % comm = comm desc % nproc = nproc desc % root = root desc % have_task_groups = . false . IF ( nogrp > 1 ) & desc % have_task_groups = . true . desc % me_pgrp = 0 ! IF ( MOD ( nproc , MAX ( 1 , nogrp ) ) /= 0 ) & CALL fftx_error__ ( \" fft_dlay_allocate \" , \"the number of task groups should be a divisor of the number of MPI task \" , 1 ) IF ( nogrp > nproc ) & CALL fftx_error__ ( \" fft_dlay_allocate \" , \"the number of task groups should be less than the number of MPI task \" , 1 ) desc % nogrp = MAX ( 1 , nogrp ) desc % npgrp = nproc / MAX ( 1 , nogrp ) desc % ogrp_comm = 0 desc % pgrp_comm = 0 ALLOCATE ( desc % nolist ( desc % nogrp ) ) ALLOCATE ( desc % nplist ( desc % npgrp ) ) desc % nolist = 0 desc % nplist = 0 NULLIFY ( desc % tg_nsw ) NULLIFY ( desc % tg_npp ) NULLIFY ( desc % tg_snd ) NULLIFY ( desc % tg_rcv ) NULLIFY ( desc % tg_psdsp ) NULLIFY ( desc % tg_usdsp ) NULLIFY ( desc % tg_rdsp ) END SUBROUTINE fft_dlay_allocate SUBROUTINE fft_dlay_deallocate ( desc ) TYPE ( fft_dlay_descriptor ) :: desc IF ( associated ( desc % nsp ) ) DEALLOCATE ( desc % nsp ) IF ( associated ( desc % nsw ) ) DEALLOCATE ( desc % nsw ) IF ( associated ( desc % ngl ) ) DEALLOCATE ( desc % ngl ) IF ( associated ( desc % nwl ) ) DEALLOCATE ( desc % nwl ) IF ( associated ( desc % npp ) ) DEALLOCATE ( desc % npp ) IF ( associated ( desc % ipp ) ) DEALLOCATE ( desc % ipp ) IF ( associated ( desc % iss ) ) DEALLOCATE ( desc % iss ) IF ( associated ( desc % isind ) ) DEALLOCATE ( desc % isind ) IF ( associated ( desc % ismap ) ) DEALLOCATE ( desc % ismap ) IF ( associated ( desc % iplp ) ) DEALLOCATE ( desc % iplp ) IF ( associated ( desc % iplw ) ) DEALLOCATE ( desc % iplw ) IF ( associated ( desc % nolist ) ) DEALLOCATE ( desc % nolist ) IF ( associated ( desc % nplist ) ) DEALLOCATE ( desc % nplist ) desc % id = 0 IF ( desc % have_task_groups ) THEN IF ( associated ( desc % tg_nsw ) ) DEALLOCATE ( desc % tg_nsw ) IF ( associated ( desc % tg_npp ) ) DEALLOCATE ( desc % tg_npp ) IF ( associated ( desc % tg_snd ) ) DEALLOCATE ( desc % tg_snd ) IF ( associated ( desc % tg_rcv ) ) DEALLOCATE ( desc % tg_rcv ) IF ( associated ( desc % tg_psdsp ) ) DEALLOCATE ( desc % tg_psdsp ) IF ( associated ( desc % tg_usdsp ) ) DEALLOCATE ( desc % tg_usdsp ) IF ( associated ( desc % tg_rdsp ) ) DEALLOCATE ( desc % tg_rdsp ) ENDIF desc % have_task_groups = . false . END SUBROUTINE fft_dlay_deallocate !=----------------------------------------------------------------------------=! SUBROUTINE fft_box_allocate ( desc , mype , root , nproc , comm , nat ) TYPE ( fft_dlay_descriptor ) :: desc INTEGER , INTENT ( in ) :: nat , nproc , mype , root , comm ! mype starting from 0 ALLOCATE ( desc % irb ( 3 , nat ) ) ALLOCATE ( desc % imin3 ( nat ) ) ALLOCATE ( desc % imax3 ( nat ) ) ALLOCATE ( desc % npp ( nproc ) ) ALLOCATE ( desc % ipp ( nproc ) ) ALLOCATE ( desc % np3 ( nat ) ) desc % irb = 0 desc % imin3 = 0 desc % imax3 = 0 desc % npp = 0 desc % ipp = 0 desc % np3 = 0 desc % mype = mype desc % nproc = nproc desc % comm = comm desc % root = root desc % have_task_groups = . false . END SUBROUTINE fft_box_allocate SUBROUTINE fft_box_deallocate ( desc ) TYPE ( fft_dlay_descriptor ) :: desc IF ( associated ( desc % irb ) ) DEALLOCATE ( desc % irb ) IF ( associated ( desc % imin3 ) ) DEALLOCATE ( desc % imin3 ) IF ( associated ( desc % imax3 ) ) DEALLOCATE ( desc % imax3 ) IF ( associated ( desc % npp ) ) DEALLOCATE ( desc % npp ) IF ( associated ( desc % ipp ) ) DEALLOCATE ( desc % ipp ) IF ( associated ( desc % np3 ) ) DEALLOCATE ( desc % np3 ) desc % have_task_groups = . false . END SUBROUTINE fft_box_deallocate !=----------------------------------------------------------------------------=! SUBROUTINE fft_dlay_set ( desc , tk , nst , nr1 , nr2 , nr3 , nr1x , nr2x , nr3x , & ub , lb , idx , in1 , in2 , ncp , ncpw , ngp , ngpw , st , stw ) TYPE ( fft_dlay_descriptor ) :: desc LOGICAL , INTENT ( in ) :: tk INTEGER , INTENT ( in ) :: nst INTEGER , INTENT ( in ) :: nr1 , nr2 , nr3 ! size of real space grid INTEGER , INTENT ( in ) :: nr1x , nr2x , nr3x ! padded size of real space grid INTEGER , INTENT ( in ) :: ub ( 3 ), lb ( 3 ) ! upper and lower bound of real space indices INTEGER , INTENT ( in ) :: idx (:) INTEGER , INTENT ( in ) :: in1 (:) INTEGER , INTENT ( in ) :: in2 (:) INTEGER , INTENT ( in ) :: ncp (:) INTEGER , INTENT ( in ) :: ncpw (:) INTEGER , INTENT ( in ) :: ngp (:) INTEGER , INTENT ( in ) :: ngpw (:) INTEGER , INTENT ( in ) :: st ( lb ( 1 ) : ub ( 1 ), lb ( 2 ) : ub ( 2 ) ) INTEGER , INTENT ( in ) :: stw ( lb ( 1 ) : ub ( 1 ), lb ( 2 ) : ub ( 2 ) ) INTEGER :: npp ( desc % nproc ), n3 ( desc % nproc ), nsp ( desc % nproc ) INTEGER :: np , nq , i , is , iss , i1 , i2 , m1 , m2 , n1 , n2 , ip INTEGER :: ncpx , nppx !  Task-grouping C. Bekas ! INTEGER :: sm IF ( ( size ( desc % ngl ) < desc % nproc ) . or . ( size ( desc % npp ) < desc % nproc ) . or . & ( size ( desc % ipp ) < desc % nproc ) . or . ( size ( desc % iss ) < desc % nproc ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong descriptor dimensions ' , 1 ) IF ( ( nr1 > nr1x ) . or . ( nr2 > nr2x ) . or . ( nr3 > nr3x ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong fft dimensions ' , 2 ) IF ( ( size ( idx ) < nst ) . or . ( size ( in1 ) < nst ) . or . ( size ( in2 ) < nst ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong number of stick dimensions ' , 3 ) IF ( ( size ( ncp ) < desc % nproc ) . or . ( size ( ngp ) < desc % nproc ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong stick dimensions ' , 4 ) !  Set the number of \"xy\" planes for each processor !  in other word do a slab partition along the z axis sm = 0 npp = 0 IF ( desc % nproc == 1 ) THEN npp ( 1 ) = nr3 ELSEIF ( desc % nproc <= nr3 ) THEN np = nr3 / desc % nproc nq = nr3 - np * desc % nproc DO i = 1 , desc % nproc npp ( i ) = np IF ( i <= nq ) npp ( i ) = np + 1 ENDDO ELSE DO ip = 1 , nr3 !  some compiler complains for empty DO loops DO i = 1 , desc % nproc , desc % nogrp npp ( i ) = npp ( i ) + 1 sm = sm + 1 IF ( sm == nr3 ) exit ENDDO IF ( sm == nr3 ) exit ENDDO ENDIF desc % npp ( 1 : desc % nproc ) = npp desc % npl = npp ( desc % mype + 1 ) !  Find out the index of the starting plane on each proc n3 = 0 DO i = 2 , desc % nproc n3 ( i ) = n3 ( i - 1 ) + npp ( i - 1 ) ENDDO desc % ipp ( 1 : desc % nproc ) = n3 !  Set the proper number of sticks IF ( . not . tk ) THEN desc % nst = 2 * nst - 1 ELSE desc % nst = nst ENDIF !  Set fft actual and leading dimensions desc % nr1 = nr1 desc % nr2 = nr2 desc % nr3 = nr3 desc % nr1x = nr1x desc % nr2x = nr2x desc % nr3x = nr3x desc % nnp = nr1x * nr2x ! see ncplane !  Set fft local workspace dimension nppx = 0 ncpx = 0 DO i = 1 , desc % nproc nppx = MAX ( nppx , npp ( i ) ) ncpx = MAX ( ncpx , ncp ( i ) ) END DO IF ( desc % nproc == 1 ) THEN desc % nnr = nr1x * nr2x * nr3x desc % tg_nnr = desc % nnr ELSE desc % nnr = max ( nr3x * ncpx , nr1x * nr2x * nppx ) desc % nnr = max ( desc % nnr , ncpx * nppx * desc % nproc ) ! this is required to use ALLTOALL instead of ALLTOALLV desc % nnr = max ( 1 , desc % nnr ) ! ensure that desc%nrr > 0 ( for extreme parallelism ) desc % tg_nnr = desc % nnr desc % tg_nnr = max ( desc % tg_nnr , nr3x * ncpx ) desc % tg_nnr = max ( desc % tg_nnr , nr1x * nr2x * nppx ) desc % tg_nnr = max ( 1 , desc % tg_nnr ) ! ensure that desc%nrr > 0 ( for extreme parallelism ) ENDIF desc % ngl ( 1 : desc % nproc ) = ngp ( 1 : desc % nproc ) desc % nwl ( 1 : desc % nproc ) = ngpw ( 1 : desc % nproc ) IF ( size ( desc % isind ) < ( nr1x * nr2x ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong descriptor dimensions, isind ' , 5 ) IF ( size ( desc % iplp ) < ( nr1x ) . or . size ( desc % iplw ) < ( nr1x ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong descriptor dimensions, ipl ' , 5 ) ! !  1. Temporarily store in the array \"desc%isind\" the index of the processor !     that own the corresponding stick (index of proc starting from 1) !  2. Set the array elements of  \"desc%iplw\" and \"desc%iplp\" to one !     for that index corresponding to YZ planes containing at least one stick !     this are used in the FFT transform along Y ! desc % isind = 0 desc % iplp = 0 desc % iplw = 0 DO iss = 1 , nst is = idx ( iss ) i1 = in1 ( is ) i2 = in2 ( is ) IF ( st ( i1 , i2 ) > 0 ) THEN m1 = i1 + 1 ; IF ( m1 < 1 ) m1 = m1 + nr1 m2 = i2 + 1 ; IF ( m2 < 1 ) m2 = m2 + nr2 IF ( stw ( i1 , i2 ) > 0 ) THEN desc % isind ( m1 + ( m2 - 1 ) * nr1x ) = st ( i1 , i2 ) desc % iplw ( m1 ) = 1 ELSE desc % isind ( m1 + ( m2 - 1 ) * nr1x ) = - st ( i1 , i2 ) ENDIF desc % iplp ( m1 ) = 1 IF ( . not . tk ) THEN n1 = - i1 + 1 ; IF ( n1 < 1 ) n1 = n1 + nr1 n2 = - i2 + 1 ; IF ( n2 < 1 ) n2 = n2 + nr2 IF ( stw ( - i1 , - i2 ) > 0 ) THEN desc % isind ( n1 + ( n2 - 1 ) * nr1x ) = st ( - i1 , - i2 ) desc % iplw ( n1 ) = 1 ELSE desc % isind ( n1 + ( n2 - 1 ) * nr1x ) = - st ( - i1 , - i2 ) ENDIF desc % iplp ( n1 ) = 1 ENDIF ENDIF ENDDO ! !  Compute for each proc the global index ( starting from 0 ) of the first !  local stick ( desc%iss ) ! DO i = 1 , desc % nproc IF ( i == 1 ) THEN desc % iss ( i ) = 0 ELSE desc % iss ( i ) = desc % iss ( i - 1 ) + ncp ( i - 1 ) ENDIF ENDDO IF ( size ( desc % ismap ) < ( nst ) ) & CALL fftx_error__ ( ' fft_dlay_set ' , ' wrong descriptor dimensions ' , 6 ) ! !  1. Set the array desc%ismap which maps stick indexes to !     position in the palne  ( iss ) !  2. Re-set the array \"desc%isind\",  that maps position !     in the plane with stick indexes (it is the inverse of desc%ismap ) ! !  wave function sticks first desc % ismap = 0 nsp = 0 DO iss = 1 , size ( desc % isind ) ip = desc % isind ( iss ) IF ( ip > 0 ) THEN nsp ( ip ) = nsp ( ip ) + 1 desc % ismap ( nsp ( ip ) + desc % iss ( ip ) ) = iss IF ( ip == ( desc % mype + 1 ) ) THEN desc % isind ( iss ) = nsp ( ip ) ELSE desc % isind ( iss ) = 0 ENDIF ENDIF ENDDO !  check number of stick against the input value IF ( any ( nsp ( 1 : desc % nproc ) /= ncpw ( 1 : desc % nproc ) ) ) THEN DO ip = 1 , desc % nproc WRITE ( stdout , * ) ' * ' , ip , ' * ' , nsp ( ip ), ' /= ' , ncpw ( ip ) ENDDO CALL fftx_error__ ( ' fft_dlay_set ' , ' inconsistent number of sticks ' , 7 ) ENDIF desc % nsw ( 1 : desc % nproc ) = nsp ( 1 : desc % nproc ) !  then add pseudopotential stick DO iss = 1 , size ( desc % isind ) ip = desc % isind ( iss ) IF ( ip < 0 ) THEN nsp ( - ip ) = nsp ( - ip ) + 1 desc % ismap ( nsp ( - ip ) + desc % iss ( - ip ) ) = iss IF ( - ip == ( desc % mype + 1 ) ) THEN desc % isind ( iss ) = nsp ( - ip ) ELSE desc % isind ( iss ) = 0 ENDIF ENDIF ENDDO !  check number of stick against the input value IF ( any ( nsp ( 1 : desc % nproc ) /= ncp ( 1 : desc % nproc ) ) ) THEN DO ip = 1 , desc % nproc WRITE ( stdout , * ) ' * ' , ip , ' * ' , nsp ( ip ), ' /= ' , ncp ( ip ) ENDDO CALL fftx_error__ ( ' fft_dlay_set ' , ' inconsistent number of sticks ' , 8 ) ENDIF desc % nsp ( 1 : desc % nproc ) = nsp ( 1 : desc % nproc ) icount = icount + 1 desc % id = icount !  Initialize the pointer to the fft tables desc % tptr = icount RETURN END SUBROUTINE fft_dlay_set !=----------------------------------------------------------------------------=! SUBROUTINE fft_box_set ( desc , nr1b , nr2b , nr3b , nr1bx , nr2bx , nr3bx , nat , & irb , npp , ipp ) IMPLICIT NONE TYPE ( fft_dlay_descriptor ) :: desc INTEGER , INTENT ( in ) :: nat INTEGER , INTENT ( in ) :: irb ( :, : ) INTEGER , INTENT ( in ) :: npp ( : ) INTEGER , INTENT ( in ) :: ipp ( : ) INTEGER , INTENT ( in ) :: nr1b , nr2b , nr3b , nr1bx , nr2bx , nr3bx INTEGER :: ir3 , ibig3 , irb3 , imin3 , imax3 , nr3 , isa IF ( nat > size ( desc % irb , 2 ) ) THEN WRITE ( stdout , fmt = \"( ///,'NAT, SIZE = ',2I10)\" ) nat , size ( desc % irb , 2 ) CALL fftx_error__ ( \" fft_box_set \" , \" inconsistent dimensions \" , 1 ) ENDIF IF ( desc % nproc > size ( desc % npp ) ) & CALL fftx_error__ ( \" fft_box_set \" , \" inconsistent dimensions \" , 2 ) desc % nr1 = nr1b desc % nr2 = nr2b desc % nr3 = nr3b desc % nr1x = nr1bx desc % nr2x = nr2bx desc % nr3x = nr3bx desc % irb ( 1 : 3 , 1 : nat ) = irb ( 1 : 3 , 1 : nat ) desc % npp ( 1 : desc % nproc ) = npp ( 1 : desc % nproc ) desc % ipp ( 1 : desc % nproc ) = ipp ( 1 : desc % nproc ) nr3 = sum ( npp ( 1 : desc % nproc ) ) DO isa = 1 , nat imin3 = nr3b imax3 = 1 irb3 = irb ( 3 , isa ) DO ir3 = 1 , nr3b ibig3 = 1 + mod ( irb3 + ir3 - 2 , nr3 ) IF ( ibig3 < 1 . or . ibig3 > nr3 ) & & CALL fftx_error__ ( ' fft_box_set ' , ' ibig3 wrong ' , ibig3 ) ibig3 = ibig3 - ipp ( desc % mype + 1 ) IF ( ibig3 > 0 . and . ibig3 <= npp ( desc % mype + 1 ) ) THEN imin3 = min ( imin3 , ir3 ) imax3 = max ( imax3 , ir3 ) ENDIF ENDDO desc % imin3 ( isa ) = imin3 desc % imax3 ( isa ) = imax3 desc % np3 ( isa ) = imax3 - imin3 + 1 ENDDO desc % have_task_groups = . false . END SUBROUTINE fft_box_set !=----------------------------------------------------------------------------=! SUBROUTINE fft_dlay_scalar ( desc , ub , lb , nr1 , nr2 , nr3 , nr1x , nr2x , nr3x , stw ) IMPLICIT NONE TYPE ( fft_dlay_descriptor ) :: desc INTEGER , INTENT ( in ) :: lb (:), ub (:) INTEGER , INTENT ( in ) :: stw ( lb ( 2 ) : ub ( 2 ), lb ( 3 ) : ub ( 3 ) ) INTEGER :: nr1 , nr2 , nr3 , nr1x , nr2x , nr3x INTEGER :: m1 , m2 , i2 , i3 IF ( size ( desc % iplw ) < nr3x . or . size ( desc % isind ) < nr2x * nr3x ) & CALL fftx_error__ ( ' fft_dlay_scalar ' , ' wrong dimensions ' , 1 ) desc % isind = 0 desc % iplw = 0 desc % iplp = 1 desc % nr1 = nr1 desc % nr2 = nr2 desc % nr3 = nr3 desc % nr1x = nr1x desc % nr2x = nr2x desc % nr3x = nr3x ! here we are setting parameter as if we were ! in a serial code, sticks are along X dimension ! and not along Z DO i2 = lb ( 2 ), ub ( 2 ) DO i3 = lb ( 3 ), ub ( 3 ) m1 = i2 + 1 ; IF ( m1 < 1 ) m1 = m1 + nr2 m2 = i3 + 1 ; IF ( m2 < 1 ) m2 = m2 + nr3 IF ( stw ( i2 , i3 ) > 0 ) THEN desc % isind ( m1 + ( m2 - 1 ) * nr2x ) = 1 ! st( i1, i2 ) desc % iplw ( m2 ) = 1 ENDIF ENDDO ENDDO desc % nnr = nr1x * nr2x * nr3x desc % npl = nr3 desc % nnp = nr1x * nr2x desc % npp = nr3 desc % ipp = 0 desc % tg_nnr = desc % nnr ! desc % have_task_groups = . false . RETURN END SUBROUTINE fft_dlay_scalar END MODULE fft_types","tags":"","loc":"sourcefile/fft_types.f90.html","title":"fft_types.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !---------------------------------------------------------------------- ! FFT base Module. ! Written by Carlo Cavazzoni, modified by Paolo Giannozzi !---------------------------------------------------------------------- ! !=----------------------------------------------------------------------=! MODULE scatter_mod !=----------------------------------------------------------------------=! USE fft_types , ONLY : fft_dlay_descriptor IMPLICIT NONE INTERFACE gather_grid MODULE PROCEDURE gather_real_grid , gather_complex_grid END INTERFACE INTERFACE scatter_grid MODULE PROCEDURE scatter_real_grid , scatter_complex_grid END INTERFACE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) SAVE PRIVATE PUBLIC :: fft_dlay_descriptor PUBLIC :: fft_scatter , gather_grid , scatter_grid PUBLIC :: cgather_sym , cgather_sym_many , cscatter_sym_many !=----------------------------------------------------------------------=! CONTAINS !=----------------------------------------------------------------------=! ! ! ! !   ALLTOALL based SCATTER, should be better on network !   with a defined topology, like on bluegene and cray machine ! !----------------------------------------------------------------------- SUBROUTINE fft_scatter ( dfft , f_in , nr3x , nxx_ , f_aux , ncp_ , npp_ , isgn , use_tg ) !----------------------------------------------------------------------- ! ! transpose the fft grid across nodes ! a) From columns to planes (isgn > 0) ! !    \"columns\" (or \"pencil\") representation: !    processor \"me\" has ncp_(me) contiguous columns along z !    Each column has nr3x elements for a fft of order nr3 !    nr3x can be =nr3+1 in order to reduce memory conflicts. ! !    The transpose take places in two steps: !    1) on each processor the columns are divided into slices along z !       that are stored contiguously. On processor \"me\", slices for !       processor \"proc\" are npp_(proc)*ncp_(me) big !    2) all processors communicate to exchange slices !       (all columns with z in the slice belonging to \"me\" !        must be received, all the others must be sent to \"proc\") !    Finally one gets the \"planes\" representation: !    processor \"me\" has npp_(me) complete xy planes !    f_in  contains input columns, is destroyed on output !    f_aux contains output planes ! !  b) From planes to columns (isgn < 0) ! !    Quite the same in the opposite direction !    f_aux contains input planes, is destroyed on output !    f_in  contains output columns ! ! !  If optional argument \"use_tg\" is true the subroutines performs !  the trasposition using the Task Groups distribution ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfft INTEGER , INTENT ( in ) :: nr3x , nxx_ , isgn , ncp_ (:), npp_ (:) COMPLEX ( DP ), INTENT ( inout ) :: f_in ( nxx_ ), f_aux ( nxx_ ) LOGICAL , OPTIONAL , INTENT ( in ) :: use_tg #if defined(__MPI) INTEGER :: dest , from , k , offset , proc , ierr , me , nprocp , gproc , gcomm , i , kdest , kfrom INTEGER :: me_p , nppx , mc , j , npp , nnp , ii , it , ip , ioff , sendsiz , ncpx , ipp , nblk , nsiz ! LOGICAL :: use_tg_ #if defined __HPM !       CALL f_hpmstart( 10, 'scatter' ) #endif ! !  Task Groups use_tg_ = . false . IF ( present ( use_tg ) ) use_tg_ = use_tg me = dfft % mype + 1 ! IF ( use_tg_ ) THEN !  This is the number of procs. in the plane-wave group nprocp = dfft % npgrp ELSE nprocp = dfft % nproc ENDIF ! CALL start_clock ( 'fft_scatter' ) ! ncpx = 0 nppx = 0 IF ( use_tg_ ) THEN DO proc = 1 , nprocp gproc = dfft % nplist ( proc ) + 1 ncpx = max ( ncpx , ncp_ ( gproc ) ) nppx = max ( nppx , npp_ ( gproc ) ) ENDDO ELSE DO proc = 1 , nprocp ncpx = max ( ncpx , ncp_ ( proc ) ) nppx = max ( nppx , npp_ ( proc ) ) ENDDO IF ( dfft % nproc == 1 ) THEN nppx = dfft % nr3x END IF ENDIF sendsiz = ncpx * nppx ! ierr = 0 IF ( isgn . gt . 0 ) THEN IF ( nprocp == 1 ) GO TO 10 ! ! \"forward\" scatter from columns to planes ! ! step one: store contiguously the slices ! offset = 1 DO proc = 1 , nprocp IF ( use_tg_ ) THEN gproc = dfft % nplist ( proc ) + 1 ELSE gproc = proc ENDIF ! from = offset dest = 1 + ( proc - 1 ) * sendsiz ! kdest = dest - 1 kfrom = from - 1 ! DO k = 1 , ncp_ ( me ) DO i = 1 , npp_ ( gproc ) f_aux ( kdest + i ) = f_in ( kfrom + i ) ENDDO kdest = kdest + nppx kfrom = kfrom + nr3x ENDDO offset = offset + npp_ ( gproc ) ENDDO ! ! maybe useless; ensures that no garbage is present in the output ! !! f_in = 0.0_DP ! ! step two: communication ! IF ( use_tg_ ) THEN gcomm = dfft % pgrp_comm ELSE gcomm = dfft % comm ENDIF CALL mpi_alltoall ( f_aux ( 1 ), sendsiz , MPI_DOUBLE_COMPLEX , f_in ( 1 ), sendsiz , MPI_DOUBLE_COMPLEX , gcomm , ierr ) IF ( abs ( ierr ) /= 0 ) CALL fftx_error__ ( 'fft_scatter' , 'info<>0' , abs ( ierr ) ) ! 10 CONTINUE ! f_aux = ( 0. d0 , 0. d0 ) ! IF ( isgn == 1 ) THEN DO ip = 1 , dfft % nproc ioff = dfft % iss ( ip ) it = ( ip - 1 ) * sendsiz DO i = 1 , dfft % nsp ( ip ) mc = dfft % ismap ( i + ioff ) DO j = 1 , dfft % npp ( me ) f_aux ( mc + ( j - 1 ) * dfft % nnp ) = f_in ( j + it ) ENDDO it = it + nppx ENDDO ENDDO ELSE IF ( use_tg_ ) THEN npp = dfft % tg_npp ( me ) nnp = dfft % nr1x * dfft % nr2x ELSE npp = dfft % npp ( me ) nnp = dfft % nnp ENDIF IF ( use_tg_ ) THEN nblk = dfft % nproc / dfft % nogrp nsiz = dfft % nogrp ELSE nblk = dfft % nproc nsiz = 1 END IF ! ip = 1 ! DO gproc = 1 , nblk ! ii = 0 ! DO ipp = 1 , nsiz ! ioff = dfft % iss ( ip ) ! DO i = 1 , dfft % nsw ( ip ) ! mc = dfft % ismap ( i + ioff ) ! it = ii * nppx + ( gproc - 1 ) * sendsiz ! DO j = 1 , npp f_aux ( mc + ( j - 1 ) * nnp ) = f_in ( j + it ) ENDDO ! ii = ii + 1 ! ENDDO ! ip = ip + 1 ! ENDDO ! ENDDO END IF ELSE ! !  \"backward\" scatter from planes to columns ! IF ( isgn == - 1 ) THEN DO ip = 1 , dfft % nproc ioff = dfft % iss ( ip ) it = ( ip - 1 ) * sendsiz DO i = 1 , dfft % nsp ( ip ) mc = dfft % ismap ( i + ioff ) DO j = 1 , dfft % npp ( me ) f_in ( j + it ) = f_aux ( mc + ( j - 1 ) * dfft % nnp ) ENDDO it = it + nppx ENDDO ENDDO ELSE IF ( use_tg_ ) THEN npp = dfft % tg_npp ( me ) nnp = dfft % nr1x * dfft % nr2x ELSE npp = dfft % npp ( me ) nnp = dfft % nnp ENDIF IF ( use_tg_ ) THEN nblk = dfft % nproc / dfft % nogrp nsiz = dfft % nogrp ELSE nblk = dfft % nproc nsiz = 1 END IF ! ip = 1 ! DO gproc = 1 , nblk ! ii = 0 ! DO ipp = 1 , nsiz ! ioff = dfft % iss ( ip ) ! DO i = 1 , dfft % nsw ( ip ) ! mc = dfft % ismap ( i + ioff ) ! it = ii * nppx + ( gproc - 1 ) * sendsiz ! DO j = 1 , npp f_in ( j + it ) = f_aux ( mc + ( j - 1 ) * nnp ) ENDDO ! ii = ii + 1 ! ENDDO ! ip = ip + 1 ! ENDDO ! ENDDO END IF IF ( nprocp == 1 ) GO TO 20 ! !  step two: communication ! IF ( use_tg_ ) THEN gcomm = dfft % pgrp_comm ELSE gcomm = dfft % comm ENDIF ! CALL mpi_barrier (gcomm, ierr)  ! why barrier? for buggy openmpi over ib CALL mpi_alltoall ( f_in ( 1 ), sendsiz , MPI_DOUBLE_COMPLEX , f_aux ( 1 ), sendsiz , MPI_DOUBLE_COMPLEX , gcomm , ierr ) IF ( abs ( ierr ) /= 0 ) CALL fftx_error__ ( 'fft_scatter' , 'info<>0' , abs ( ierr ) ) ! !  step one: store contiguously the columns ! !! f_in = 0.0_DP ! offset = 1 DO proc = 1 , nprocp from = offset IF ( use_tg_ ) THEN gproc = dfft % nplist ( proc ) + 1 ELSE gproc = proc ENDIF dest = 1 + ( proc - 1 ) * sendsiz ! kdest = dest - 1 kfrom = from - 1 ! DO k = 1 , ncp_ ( me ) DO i = 1 , npp_ ( gproc ) f_in ( kfrom + i ) = f_aux ( kdest + i ) ENDDO kdest = kdest + nppx kfrom = kfrom + nr3x ENDDO offset = offset + npp_ ( gproc ) ENDDO 20 CONTINUE ENDIF CALL stop_clock ( 'fft_scatter' ) #endif #if defined __HPM !       CALL f_hpmstop( 10 ) #endif RETURN END SUBROUTINE fft_scatter ! !---------------------------------------------------------------------------- SUBROUTINE gather_real_grid ( dfft , f_in , f_out ) !---------------------------------------------------------------------------- ! ! ... gathers a distributed real-space FFT grid to dfft%root, that is, ! ... the first processor of input descriptor dfft - version for real arrays ! ! ... REAL*8  f_in  = distributed variable (dfft%nnr) ! ... REAL*8  f_out = gathered variable (dfft%nr1x*dfft%nr2x*dfft%nr3x) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! REAL ( DP ), INTENT ( in ) :: f_in (:) REAL ( DP ), INTENT ( inout ) :: f_out (:) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft ! #if defined(__MPI) ! INTEGER :: proc , info ! ... the following are automatic arrays INTEGER :: displs ( 0 : dfft % nproc - 1 ), recvcount ( 0 : dfft % nproc - 1 ) ! IF ( size ( f_in ) < dfft % nnr ) & CALL fftx_error__ ( ' gather_grid ' , ' f_in too small ' , dfft % nnr - size ( f_in ) ) ! CALL start_clock ( 'gather_grid' ) ! DO proc = 0 , ( dfft % nproc - 1 ) ! recvcount ( proc ) = dfft % nnp * dfft % npp ( proc + 1 ) IF ( proc == 0 ) THEN displs ( proc ) = 0 ELSE displs ( proc ) = displs ( proc - 1 ) + recvcount ( proc - 1 ) ENDIF ! ENDDO ! ! ... the following check should be performed only on processor dfft%root ! ... otherwise f_out must be allocated on all processors even if not used ! info = size ( f_out ) - displs ( dfft % nproc - 1 ) - recvcount ( dfft % nproc - 1 ) IF ( info < 0 ) & CALL fftx_error__ ( ' gather_grid ' , ' f_out too small ' , - info ) ! info = 0 ! CALL MPI_GATHERV ( f_in , recvcount ( dfft % mype ), MPI_DOUBLE_PRECISION , f_out , & recvcount , displs , MPI_DOUBLE_PRECISION , dfft % root , & dfft % comm , info ) ! CALL fftx_error__ ( 'gather_grid' , 'info<>0' , info ) ! CALL stop_clock ( 'gather_grid' ) ! #else CALL fftx_error__ ( 'gather_grid' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE gather_real_grid !---------------------------------------------------------------------------- SUBROUTINE gather_complex_grid ( dfft , f_in , f_out ) !---------------------------------------------------------------------------- ! ! ... gathers a distributed real-space FFT grid to dfft%root, that is, ! ... the first processor of input descriptor dfft - complex arrays ! ! ... COMPLEX*16  f_in  = distributed variable (dfft%nnr) ! ... COMPLEX*16  f_out = gathered variable (dfft%nr1x*dfft%nr2x*dfft%nr3x) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! COMPLEX ( DP ), INTENT ( in ) :: f_in (:) COMPLEX ( DP ), INTENT ( inout ) :: f_out (:) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft ! #if defined(__MPI) ! INTEGER :: proc , info ! ... the following are automatic arrays INTEGER :: displs ( 0 : dfft % nproc - 1 ), recvcount ( 0 : dfft % nproc - 1 ) ! IF ( 2 * size ( f_in ) < dfft % nnr ) & CALL fftx_error__ ( ' gather_grid ' , ' f_in too small ' , dfft % nnr - size ( f_in ) ) ! CALL start_clock ( 'gather_grid' ) ! DO proc = 0 , ( dfft % nproc - 1 ) ! recvcount ( proc ) = 2 * dfft % nnp * dfft % npp ( proc + 1 ) IF ( proc == 0 ) THEN displs ( proc ) = 0 ELSE displs ( proc ) = displs ( proc - 1 ) + recvcount ( proc - 1 ) ENDIF ! ENDDO ! ! ... the following check should be performed only on processor dfft%root ! ... otherwise f_out must be allocated on all processors even if not used ! info = 2 * size ( f_out ) - displs ( dfft % nproc - 1 ) - recvcount ( dfft % nproc - 1 ) IF ( info < 0 ) & CALL fftx_error__ ( ' gather_grid ' , ' f_out too small ' , - info ) ! info = 0 ! CALL MPI_GATHERV ( f_in , recvcount ( dfft % mype ), MPI_DOUBLE_PRECISION , f_out , & recvcount , displs , MPI_DOUBLE_PRECISION , dfft % root , & dfft % comm , info ) ! CALL fftx_error__ ( 'gather_grid' , 'info<>0' , info ) ! CALL stop_clock ( 'gather_grid' ) ! #else CALL fftx_error__ ( 'gather_grid' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE gather_complex_grid !---------------------------------------------------------------------------- SUBROUTINE scatter_real_grid ( dfft , f_in , f_out ) !---------------------------------------------------------------------------- ! ! ... scatters a real-space FFT grid from dfft%root, first processor of ! ... input descriptor dfft, to all others - opposite of \"gather_grid\" ! ! ... REAL*8  f_in  = gathered variable (dfft%nr1x*dfft%nr2x*dfft%nr3x) ! ... REAL*8  f_out = distributed variable (dfft%nnr) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! REAL ( DP ), INTENT ( in ) :: f_in (:) REAL ( DP ), INTENT ( inout ) :: f_out (:) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft ! #if defined(__MPI) ! INTEGER :: proc , info ! ... the following are automatic arrays INTEGER :: displs ( 0 : dfft % nproc - 1 ), sendcount ( 0 : dfft % nproc - 1 ) ! IF ( size ( f_out ) < dfft % nnr ) & CALL fftx_error__ ( ' scatter_grid ' , ' f_out too small ' , dfft % nnr - size ( f_in ) ) ! CALL start_clock ( 'scatter_grid' ) ! DO proc = 0 , ( dfft % nproc - 1 ) ! sendcount ( proc ) = dfft % nnp * dfft % npp ( proc + 1 ) IF ( proc == 0 ) THEN displs ( proc ) = 0 ELSE displs ( proc ) = displs ( proc - 1 ) + sendcount ( proc - 1 ) ENDIF ! ENDDO ! ! ... the following check should be performed only on processor dfft%root ! ... otherwise f_in must be allocated on all processors even if not used ! info = size ( f_in ) - displs ( dfft % nproc - 1 ) - sendcount ( dfft % nproc - 1 ) IF ( info < 0 ) & CALL fftx_error__ ( ' scatter_grid ' , ' f_in too small ' , - info ) ! info = 0 ! CALL MPI_SCATTERV ( f_in , sendcount , displs , MPI_DOUBLE_PRECISION , & f_out , sendcount ( dfft % mype ), MPI_DOUBLE_PRECISION , & dfft % root , dfft % comm , info ) ! CALL fftx_error__ ( 'scatter_grid' , 'info<>0' , info ) ! IF ( sendcount ( dfft % mype ) /= dfft % nnr ) & f_out ( sendcount ( dfft % mype ) + 1 : dfft % nnr ) = 0. D0 ! CALL stop_clock ( 'scatter_grid' ) ! #else CALL fftx_error__ ( 'scatter_grid' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE scatter_real_grid !---------------------------------------------------------------------------- SUBROUTINE scatter_complex_grid ( dfft , f_in , f_out ) !---------------------------------------------------------------------------- ! ! ... scatters a real-space FFT grid from dfft%root, first processor of ! ... input descriptor dfft, to all others - opposite of \"gather_grid\" ! ! ... COMPLEX*16  f_in  = gathered variable (dfft%nr1x*dfft%nr2x*dfft%nr3x) ! ... COMPLEX*16  f_out = distributed variable (dfft%nnr) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! COMPLEX ( DP ), INTENT ( in ) :: f_in (:) COMPLEX ( DP ), INTENT ( inout ) :: f_out (:) TYPE ( fft_dlay_descriptor ), INTENT ( IN ) :: dfft ! #if defined(__MPI) ! INTEGER :: proc , info ! ... the following are automatic arrays INTEGER :: displs ( 0 : dfft % nproc - 1 ), sendcount ( 0 : dfft % nproc - 1 ) ! IF ( 2 * size ( f_out ) < dfft % nnr ) & CALL fftx_error__ ( ' scatter_grid ' , ' f_out too small ' , dfft % nnr - size ( f_in ) ) ! CALL start_clock ( 'scatter_grid' ) ! DO proc = 0 , ( dfft % nproc - 1 ) ! sendcount ( proc ) = 2 * dfft % nnp * dfft % npp ( proc + 1 ) IF ( proc == 0 ) THEN displs ( proc ) = 0 ELSE displs ( proc ) = displs ( proc - 1 ) + sendcount ( proc - 1 ) ENDIF ! ENDDO ! ! ... the following check should be performed only on processor dfft%root ! ... otherwise f_in must be allocated on all processors even if not used ! info = 2 * size ( f_in ) - displs ( dfft % nproc - 1 ) - sendcount ( dfft % nproc - 1 ) IF ( info < 0 ) & CALL fftx_error__ ( ' scatter_grid ' , ' f_in too small ' , - info ) ! info = 0 ! CALL MPI_SCATTERV ( f_in , sendcount , displs , MPI_DOUBLE_PRECISION , & f_out , sendcount ( dfft % mype ), MPI_DOUBLE_PRECISION , & dfft % root , dfft % comm , info ) ! CALL fftx_error__ ( 'scatter_grid' , 'info<>0' , info ) ! IF ( sendcount ( dfft % mype ) /= dfft % nnr ) & f_out ( sendcount ( dfft % mype ) + 1 : dfft % nnr ) = 0. D0 ! CALL stop_clock ( 'scatter_grid' ) ! #else CALL fftx_error__ ( 'scatter_grid' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE scatter_complex_grid ! ! ... \"gather\"-like subroutines ! !----------------------------------------------------------------------- SUBROUTINE cgather_sym ( dfftp , f_in , f_out ) !----------------------------------------------------------------------- ! ! ... gather complex data for symmetrization (used in phonon code) ! ... Differs from gather_grid because mpi_allgatherv is used instead ! ... of mpi_gatherv - all data is gathered on ALL processors ! ... COMPLEX*16  f_in  = distributed variable (nrxx) ! ... COMPLEX*16  f_out = gathered variable (nr1x*nr2x*nr3x) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfftp COMPLEX ( DP ) :: f_in ( : ), f_out (:) ! #if defined(__MPI) ! INTEGER :: proc , info INTEGER :: displs ( 0 : dfftp % nproc - 1 ), recvcount ( 0 : dfftp % nproc - 1 ) ! ! CALL start_clock ( 'cgather' ) ! DO proc = 0 , ( dfftp % nproc - 1 ) ! recvcount ( proc ) = 2 * dfftp % nnp * dfftp % npp ( proc + 1 ) IF ( proc == 0 ) THEN displs ( proc ) = 0 ELSE displs ( proc ) = displs ( proc - 1 ) + recvcount ( proc - 1 ) ENDIF ! ENDDO ! CALL MPI_BARRIER ( dfftp % comm , info ) ! CALL MPI_ALLGATHERV ( f_in , recvcount ( dfftp % mype ), MPI_DOUBLE_PRECISION , & f_out , recvcount , displs , MPI_DOUBLE_PRECISION , & dfftp % comm , info ) ! CALL fftx_error__ ( 'cgather_sym' , 'info<>0' , info ) ! CALL stop_clock ( 'cgather' ) ! #else CALL fftx_error__ ( 'cgather_sym' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE cgather_sym ! ! !----------------------------------------------------------------------- SUBROUTINE cgather_sym_many ( dfftp , f_in , f_out , nbnd , nbnd_proc , start_nbnd_proc ) !----------------------------------------------------------------------- ! ! ... Written by A. Dal Corso ! ! ... This routine generalizes cgather_sym, receiveng nbnd complex ! ... distributed functions and collecting nbnd_proc(dfftp%mype+1) ! ... functions in each processor. ! ... start_nbnd_proc(dfftp%mype+1), says where the data for each processor ! ... start in the distributed variable ! ... COMPLEX*16  f_in  = distributed variable (nrxx,nbnd) ! ... COMPLEX*16  f_out = gathered variable (nr1x*nr2x*nr3x, !                                             nbnd_proc(dfftp%mype+1)) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfftp INTEGER :: nbnd , nbnd_proc ( dfftp % nproc ), start_nbnd_proc ( dfftp % nproc ) COMPLEX ( DP ) :: f_in ( dfftp % nnr , nbnd ) COMPLEX ( DP ) :: f_out ( dfftp % nnp * dfftp % nr3x , nbnd_proc ( dfftp % mype + 1 )) ! #if defined(__MPI) ! INTEGER :: proc , info INTEGER :: ibnd , jbnd INTEGER :: displs ( 0 : dfftp % nproc - 1 ), recvcount ( 0 : dfftp % nproc - 1 ) ! ! CALL start_clock ( 'cgather' ) ! DO proc = 0 , ( dfftp % nproc - 1 ) ! recvcount ( proc ) = 2 * dfftp % nnp * dfftp % npp ( proc + 1 ) ! IF ( proc == 0 ) THEN ! displs ( proc ) = 0 ! ELSE ! displs ( proc ) = displs ( proc - 1 ) + recvcount ( proc - 1 ) ! ENDIF ! ENDDO ! CALL MPI_BARRIER ( dfftp % comm , info ) ! DO proc = 0 , dfftp % nproc - 1 DO ibnd = 1 , nbnd_proc ( proc + 1 ) jbnd = start_nbnd_proc ( proc + 1 ) + ibnd - 1 CALL MPI_GATHERV ( f_in ( 1 , jbnd ), recvcount ( dfftp % mype ), & MPI_DOUBLE_PRECISION , f_out ( 1 , ibnd ), recvcount , & displs , MPI_DOUBLE_PRECISION , proc , dfftp % comm , info ) END DO END DO ! CALL fftx_error__ ( 'cgather_sym_many' , 'info<>0' , info ) ! !  CALL mp_barrier( dfftp%comm ) ! CALL stop_clock ( 'cgather' ) ! #else CALL fftx_error__ ( 'cgather_sym_many' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE cgather_sym_many ! !---------------------------------------------------------------------------- SUBROUTINE cscatter_sym_many ( dfftp , f_in , f_out , target_ibnd , nbnd , nbnd_proc , & start_nbnd_proc ) !---------------------------------------------------------------------------- ! ! ... Written by A. Dal Corso ! ! ... generalizes cscatter_sym. It assumes that each processor has ! ... a certain number of bands (nbnd_proc(dfftp%mype+1)). The processor ! ... that has target_ibnd scatters it to all the other processors ! ... that receive a distributed part of the target function. ! ... start_nbnd_proc(dfftp%mype+1) is used to identify the processor ! ... that has the required band ! ! ... COMPLEX*16  f_in  = gathered variable (nr1x*nr2x*nr3x, !                                                nbnd_proc(dfftp%mype+1) ) ! ... COMPLEX*16  f_out = distributed variable (nrxx) ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! TYPE ( fft_dlay_descriptor ), INTENT ( in ) :: dfftp INTEGER :: nbnd , nbnd_proc ( dfftp % nproc ), start_nbnd_proc ( dfftp % nproc ) COMPLEX ( DP ) :: f_in ( dfftp % nnp * dfftp % nr3x , nbnd_proc ( dfftp % mype + 1 )) COMPLEX ( DP ) :: f_out ( dfftp % nnr ) INTEGER :: target_ibnd ! #if defined(__MPI) ! INTEGER :: proc , info INTEGER :: displs ( 0 : dfftp % nproc - 1 ), sendcount ( 0 : dfftp % nproc - 1 ) INTEGER :: ibnd , jbnd ! ! CALL start_clock ( 'cscatter_sym' ) ! DO proc = 0 , ( dfftp % nproc - 1 ) ! sendcount ( proc ) = 2 * dfftp % nnp * dfftp % npp ( proc + 1 ) ! IF ( proc == 0 ) THEN ! displs ( proc ) = 0 ! ELSE ! displs ( proc ) = displs ( proc - 1 ) + sendcount ( proc - 1 ) ! ENDIF ! ENDDO ! f_out = ( 0.0_DP , 0.0_DP ) ! CALL MPI_BARRIER ( dfftp % comm , info ) ! DO proc = 0 , dfftp % nproc - 1 DO ibnd = 1 , nbnd_proc ( proc + 1 ) jbnd = start_nbnd_proc ( proc + 1 ) + ibnd - 1 IF ( jbnd == target_ibnd ) & CALL MPI_SCATTERV ( f_in ( 1 , ibnd ), sendcount , displs , & MPI_DOUBLE_PRECISION , f_out , sendcount ( dfftp % mype ), & MPI_DOUBLE_PRECISION , proc , dfftp % comm , info ) ENDDO ENDDO ! CALL fftx_error__ ( 'cscatter_sym_many' , 'info<>0' , info ) ! CALL stop_clock ( 'cscatter_sym' ) ! #else CALL fftx_error__ ( 'cscatter_sym_many' , 'do not use in serial execution' , 1 ) #endif ! RETURN ! END SUBROUTINE cscatter_sym_many !=----------------------------------------------------------------------=! END MODULE scatter_mod !=----------------------------------------------------------------------=!","tags":"","loc":"sourcefile/scatter_mod.f90.html","title":"scatter_mod.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=----------------------------------------------------------------------= MODULE stick_base !=----------------------------------------------------------------------= IMPLICIT NONE PRIVATE SAVE PUBLIC :: sticks_maps , sticks_sort , sticks_countg , sticks_dist , sticks_pairup PUBLIC :: sticks_owner , sticks_deallocate , sticks_maps_scalar , sticks_ordered_dist ! ...   sticks_owner :   stick owner, sticks_owner( i, j ) is the index of the processor ! ...     (starting from 1) owning the stick whose x and y coordinate  are i and j. INTEGER , ALLOCATABLE , TARGET :: sticks_owner ( : , : ) INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) !=----------------------------------------------------------------------= CONTAINS !=----------------------------------------------------------------------= SUBROUTINE sticks_maps ( tk , ub , lb , b1 , b2 , b3 , gcut , gcutw , gcuts , st , stw , sts , me , nproc , comm ) #if defined(__MPI) INCLUDE 'mpif.h' #endif LOGICAL , INTENT ( in ) :: tk !  if true use the full space grid INTEGER , INTENT ( in ) :: ub (:) !  upper bounds for i-th grid dimension INTEGER , INTENT ( in ) :: lb (:) !  lower bounds for i-th grid dimension REAL ( DP ) , INTENT ( in ) :: b1 (:), b2 (:), b3 (:) ! reciprocal space base vectors REAL ( DP ) , INTENT ( in ) :: gcut ! cut-off for potentials REAL ( DP ) , INTENT ( in ) :: gcutw ! cut-off for plane waves REAL ( DP ) , INTENT ( in ) :: gcuts ! cut-off for smooth mesh INTEGER , INTENT ( out ) :: st ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for potential INTEGER , INTENT ( out ) :: stw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( out ) :: sts ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for smooth mesh INTEGER , INTENT ( in ) :: me ! my proc id (starting from 0) INTEGER , INTENT ( in ) :: nproc ! number of proc in the g-vec group INTEGER , INTENT ( in ) :: comm ! communicator of the g-vec group INTEGER :: i , j , k , kip , ierr REAL ( DP ) :: gsq stw = 0 st = 0 sts = 0 ! ...       Here find the basic maps of sticks st, stw and sts for the potential ! ...       cut-off gcut, wavefunction cut-off gcutw, and smooth mesh cut-off gcuts ! ...       st(i,j) will contain the number of G vectors of the stick whose ! ...       indices are (i,j). #if defined (__EKO) WRITE ( * , * ) ! Workaround for EKOPath compiler bug #endif IF ( . not . tk ) THEN kip = 0 + abs ( lb ( 3 )) + 1 IF ( mod ( kip , nproc ) == me ) THEN st ( 0 , 0 ) = st ( 0 , 0 ) + 1 stw ( 0 , 0 ) = stw ( 0 , 0 ) + 1 sts ( 0 , 0 ) = sts ( 0 , 0 ) + 1 ENDIF DO i = 0 , 0 DO j = 0 , 0 DO k = 1 , ub ( 3 ) kip = k + abs ( lb ( 3 )) + 1 IF ( mod ( kip , nproc ) == me ) THEN gsq = ( dble ( i ) * b1 ( 1 ) + dble ( j ) * b2 ( 1 ) + dble ( k ) * b3 ( 1 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 2 ) + dble ( j ) * b2 ( 2 ) + dble ( k ) * b3 ( 2 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 3 ) + dble ( j ) * b2 ( 3 ) + dble ( k ) * b3 ( 3 ) ) ** 2 IF ( gsq . le . gcut ) THEN st ( i , j ) = st ( i , j ) + 1 IF ( gsq . le . gcutw ) THEN stw ( i , j ) = stw ( i , j ) + 1 ENDIF IF ( gsq . le . gcuts ) THEN sts ( i , j ) = sts ( i , j ) + 1 ENDIF ENDIF ENDIF ENDDO ENDDO ENDDO DO i = 0 , 0 DO j = 1 , ub ( 2 ) DO k = lb ( 3 ), ub ( 3 ) kip = k + abs ( lb ( 3 )) + 1 IF ( mod ( kip , nproc ) == me ) THEN gsq = ( dble ( i ) * b1 ( 1 ) + dble ( j ) * b2 ( 1 ) + dble ( k ) * b3 ( 1 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 2 ) + dble ( j ) * b2 ( 2 ) + dble ( k ) * b3 ( 2 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 3 ) + dble ( j ) * b2 ( 3 ) + dble ( k ) * b3 ( 3 ) ) ** 2 IF ( gsq . le . gcut ) THEN st ( i , j ) = st ( i , j ) + 1 IF ( gsq . le . gcutw ) THEN stw ( i , j ) = stw ( i , j ) + 1 ENDIF IF ( gsq . le . gcuts ) THEN sts ( i , j ) = sts ( i , j ) + 1 ENDIF ENDIF ENDIF ENDDO ENDDO ENDDO DO i = 1 , ub ( 1 ) DO j = lb ( 2 ), ub ( 2 ) DO k = lb ( 3 ), ub ( 3 ) kip = k + abs ( lb ( 3 )) + 1 IF ( mod ( kip , nproc ) == me ) THEN gsq = ( dble ( i ) * b1 ( 1 ) + dble ( j ) * b2 ( 1 ) + dble ( k ) * b3 ( 1 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 2 ) + dble ( j ) * b2 ( 2 ) + dble ( k ) * b3 ( 2 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 3 ) + dble ( j ) * b2 ( 3 ) + dble ( k ) * b3 ( 3 ) ) ** 2 IF ( gsq . le . gcut ) THEN st ( i , j ) = st ( i , j ) + 1 IF ( gsq . le . gcutw ) THEN stw ( i , j ) = stw ( i , j ) + 1 ENDIF IF ( gsq . le . gcuts ) THEN sts ( i , j ) = sts ( i , j ) + 1 ENDIF ENDIF ENDIF ENDDO ENDDO ENDDO ELSE DO i = lb ( 1 ), ub ( 1 ) DO j = lb ( 2 ), ub ( 2 ) DO k = lb ( 3 ), ub ( 3 ) kip = k + abs ( lb ( 3 )) + 1 IF ( mod ( kip , nproc ) == me ) THEN gsq = ( dble ( i ) * b1 ( 1 ) + dble ( j ) * b2 ( 1 ) + dble ( k ) * b3 ( 1 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 2 ) + dble ( j ) * b2 ( 2 ) + dble ( k ) * b3 ( 2 ) ) ** 2 gsq = gsq + ( dble ( i ) * b1 ( 3 ) + dble ( j ) * b2 ( 3 ) + dble ( k ) * b3 ( 3 ) ) ** 2 IF ( gsq . le . gcut ) THEN st ( i , j ) = st ( i , j ) + 1 ENDIF IF ( gsq . le . gcutw ) THEN stw ( i , j ) = stw ( i , j ) + 1 ENDIF IF ( gsq . le . gcuts ) THEN sts ( i , j ) = sts ( i , j ) + 1 ENDIF ENDIF ENDDO ENDDO ENDDO ENDIF CALL MPI_ALLREDUCE ( MPI_IN_PLACE , st , SIZE ( st ), MPI_INTEGER , MPI_SUM , comm , ierr ) CALL MPI_ALLREDUCE ( MPI_IN_PLACE , stw , SIZE ( stw ), MPI_INTEGER , MPI_SUM , comm , ierr ) CALL MPI_ALLREDUCE ( MPI_IN_PLACE , sts , SIZE ( sts ), MPI_INTEGER , MPI_SUM , comm , ierr ) !CALL reduce_base_integer( SIZE(st), st, comm, -1 ) !CALL reduce_base_integer( SIZE(stw), stw, comm, -1 ) !CALL reduce_base_integer( SIZE(sts), sts, comm, -1 ) !!! TO REMOVE BEFORE COMMIT INTO SVN !!! #if defined(__STICKS_DEBUG) ! Test sticks WRITE ( 6 , * ) 'testtesttesttesttesttesttesttesttesttest' WRITE ( 6 , * ) 'lb = ' , lb ( 1 ), lb ( 2 ) WRITE ( 6 , * ) 'ub = ' , ub ( 1 ), ub ( 2 ) WRITE ( 6 , * ) 'counts    = ' , count ( st > 0 ), count ( stw > 0 ), count ( sts > 0 ) WRITE ( 6 , * ) 'cut-offs  = ' , gcut , gcutw , gcuts WRITE ( 6 , * ) 'b1  = ' , b1 ( 1 : 3 ) WRITE ( 6 , * ) 'b2  = ' , b2 ( 1 : 3 ) WRITE ( 6 , * ) 'b3  = ' , b3 ( 1 : 3 ) DO i = lb ( 1 ), ub ( 1 ) DO j = lb ( 2 ), ub ( 2 ) WRITE ( 6 , '(2I4,3I6)' ) i , j , st ( i , j ), stw ( i , j ), sts ( i , j ) ENDDO ENDDO WRITE ( 6 , * ) 'testtesttesttesttesttesttesttesttesttest' ! Test sticks #endif !!! TO REMOVE BEFORE COMMIT INTO SVN !!! RETURN END SUBROUTINE sticks_maps !=----------------------------------------------------------------------= SUBROUTINE sticks_maps_scalar ( lgamma , ub , lb , b1 , b2 , b3 , gcutm , gkcut , gcutms , stw , ngm , ngms ) LOGICAL , INTENT ( in ) :: lgamma !  if true use gamma point simmetry INTEGER , INTENT ( in ) :: ub (:) !  upper bounds for i-th grid dimension INTEGER , INTENT ( in ) :: lb (:) !  lower bounds for i-th grid dimension REAL ( DP ) , INTENT ( in ) :: b1 (:), b2 (:), b3 (:) ! reciprocal space base vectors REAL ( DP ) , INTENT ( in ) :: gcutm ! cut-off for potentials REAL ( DP ) , INTENT ( in ) :: gkcut ! cut-off for plane waves REAL ( DP ) , INTENT ( in ) :: gcutms ! cut-off for smooth mesh ! INTEGER , INTENT ( out ) :: ngm , ngms ! !     stick map for wave functions, note that map is taken in YZ plane ! INTEGER , INTENT ( out ) :: stw ( lb ( 2 ) : ub ( 2 ), lb ( 3 ) : ub ( 3 ) ) INTEGER :: i1 , i2 , i3 , n1 , n2 , n3 REAL ( DP ) :: amod ngm = 0 ngms = 0 stw = 0 n1 = max ( abs ( lb ( 1 ) ), abs ( ub ( 1 ) ) ) n2 = max ( abs ( lb ( 2 ) ), abs ( ub ( 2 ) ) ) n3 = max ( abs ( lb ( 3 ) ), abs ( ub ( 3 ) ) ) loop1 : DO i1 = - n1 , n1 ! ! Gamma-only: exclude space with x<0 ! IF ( lgamma . and . i1 < 0 ) CYCLE loop1 ! loop2 : DO i2 = - n2 , n2 ! ! Gamma-only: exclude plane with x=0, y<0 ! IF ( lgamma . and . i1 == 0. and . i2 < 0 ) CYCLE loop2 ! loop3 : DO i3 = - n3 , n3 ! ! Gamma-only: exclude line with x=0, y=0, z<0 ! IF ( lgamma . and . i1 == 0 . and . i2 == 0 . and . i3 < 0 ) CYCLE loop3 ! amod = ( i1 * b1 ( 1 ) + i2 * b2 ( 1 ) + i3 * b3 ( 1 ) ) ** 2 + & ( i1 * b1 ( 2 ) + i2 * b2 ( 2 ) + i3 * b3 ( 2 ) ) ** 2 + & ( i1 * b1 ( 3 ) + i2 * b2 ( 3 ) + i3 * b3 ( 3 ) ) ** 2 IF ( amod <= gcutm ) ngm = ngm + 1 IF ( amod <= gcutms ) ngms = ngms + 1 IF ( amod <= gkcut ) THEN stw ( i2 , i3 ) = 1 IF ( lgamma ) stw ( - i2 , - i3 ) = 1 ENDIF ENDDO loop3 ENDDO loop2 ENDDO loop1 RETURN END SUBROUTINE sticks_maps_scalar !=----------------------------------------------------------------------= SUBROUTINE sticks_sort ( ngc , ngcw , ngcs , nct , idx , nproc ) ! ...     This subroutine sorts the sticks indexes, according to ! ...     the length and type of the sticks, wave functions sticks ! ...     first, then smooth mesh sticks, and finally potential ! ...     sticks ! lengths of sticks, ngc for potential mesh, ngcw for wave functions mesh ! and ngcs for smooth mesh INTEGER , INTENT ( in ) :: ngc (:), ngcw (:), ngcs (:) INTEGER , INTENT ( in ) :: nproc ! number of proc in the g-vec group ! nct, total number of sticks INTEGER , INTENT ( in ) :: nct ! index, on output, new sticks indexes INTEGER , INTENT ( out ) :: idx (:) INTEGER :: mc , nr3x , ic REAL ( DP ) :: dn3 REAL ( DP ), ALLOCATABLE :: aux (:) nr3x = maxval ( ngc ( 1 : nct ) ) + 1 dn3 = REAL ( nr3x ) IF ( nproc > 1 ) THEN ALLOCATE ( aux ( nct ) ) DO mc = 1 , nct aux ( mc ) = ngcw ( mc ) aux ( mc ) = dn3 * aux ( mc ) + ngcs ( mc ) aux ( mc ) = dn3 * aux ( mc ) + ngc ( mc ) aux ( mc ) = - aux ( mc ) idx ( mc ) = 0 ENDDO CALL hpsort ( nct , aux ( 1 ), idx ( 1 )) DEALLOCATE ( aux ) ELSE ic = 0 DO mc = 1 , nct IF ( ngcw ( mc ) > 0 ) THEN ic = ic + 1 idx ( ic ) = mc ENDIF ENDDO DO mc = 1 , nct IF ( ngcs ( mc ) > 0 . and . ngcw ( mc ) == 0 ) THEN ic = ic + 1 idx ( ic ) = mc ENDIF ENDDO DO mc = 1 , nct IF ( ngc ( mc ) > 0 . and . ngcs ( mc ) == 0 . and . ngcw ( mc ) == 0 ) THEN ic = ic + 1 idx ( ic ) = mc ENDIF ENDDO ENDIF !!! TO REMOVE BEFORE COMMIT INTO SVN !!! #if defined(__STICKS_DEBUG) WRITE ( 6 , * ) '-----------------' WRITE ( 6 , * ) 'STICKS_SORT DEBUG' DO mc = 1 , nct WRITE ( 6 , fmt = \"(4I10)\" ) idx ( mc ), ngcw ( idx ( mc ) ), ngcs ( idx ( mc ) ), ngc ( idx ( mc ) ) ENDDO WRITE ( 6 , * ) '-----------------' #endif !!! TO REMOVE BEFORE COMMIT INTO SVN !!! RETURN END SUBROUTINE sticks_sort !=----------------------------------------------------------------------= SUBROUTINE sticks_countg ( tk , ub , lb , st , stw , sts , in1 , in2 , ngc , ngcw , ngcs ) INTEGER , INTENT ( in ) :: ub (:), lb (:) INTEGER , INTENT ( in ) :: st ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for potential INTEGER , INTENT ( in ) :: stw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( in ) :: sts ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for smooth mesh LOGICAL , INTENT ( in ) :: tk INTEGER , INTENT ( out ) :: in1 (:), in2 (:) INTEGER , INTENT ( out ) :: ngc (:), ngcw (:), ngcs (:) INTEGER :: j1 , j2 , i1 , i2 , nct , min_size ! ! ...     initialize the sticks indexes array ist ! ...     nct counts columns containing G-vectors for the dense grid ! ...     ncts counts columns contaning G-vectors for the smooth grid ! nct = 0 ngc = 0 ngcs = 0 ngcw = 0 min_size = min ( size ( in1 ), size ( in2 ), size ( ngc ), size ( ngcw ), size ( ngcs ) ) DO j2 = 0 , ( ub ( 2 ) - lb ( 2 ) ) DO j1 = 0 , ( ub ( 1 ) - lb ( 1 ) ) i1 = j1 IF ( i1 > ub ( 1 ) ) i1 = lb ( 1 ) + ( i1 - ub ( 1 ) ) - 1 i2 = j2 IF ( i2 > ub ( 2 ) ) i2 = lb ( 2 ) + ( i2 - ub ( 2 ) ) - 1 IF ( st ( i1 , i2 ) > 0 ) THEN ! this sticks contains G-vectors nct = nct + 1 IF ( nct > min_size ) & CALL fftx_error__ ( ' sticks_countg ' , ' too many sticks ' , nct ) in1 ( nct ) = i1 in2 ( nct ) = i2 ngc ( nct ) = st ( i1 , i2 ) IF ( stw ( i1 , i2 ) . gt . 0 ) ngcw ( nct ) = stw ( i1 , i2 ) IF ( sts ( i1 , i2 ) . gt . 0 ) ngcs ( nct ) = sts ( i1 , i2 ) ENDIF ! WRITE(7,fmt=\"(5I5)\") i1, i2, nct, ngc(nct), ngcw( nct ) ENDDO ENDDO RETURN END SUBROUTINE sticks_countg !=----------------------------------------------------------------------= SUBROUTINE sticks_dist ( tk , ub , lb , idx , in1 , in2 , ngc , ngcw , ngcs , nct , & ncp , ncpw , ncps , ngp , ngpw , ngps , stown , stownw , stowns , nproc ) LOGICAL , INTENT ( in ) :: tk INTEGER , INTENT ( in ) :: ub (:), lb (:), idx (:) INTEGER , INTENT ( out ) :: stown ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for potential INTEGER , INTENT ( out ) :: stownw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( out ) :: stowns ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for smooth mesh INTEGER , INTENT ( in ) :: in1 (:), in2 (:) INTEGER , INTENT ( in ) :: ngc (:), ngcw (:), ngcs (:) INTEGER , INTENT ( in ) :: nct INTEGER , INTENT ( out ) :: ncp (:), ncpw (:), ncps (:) INTEGER , INTENT ( out ) :: ngp (:), ngpw (:), ngps (:) INTEGER , INTENT ( in ) :: nproc ! number of proc in the g-vec group INTEGER :: mc , i1 , i2 , i , j , jj , icnt ncp = 0 ncps = 0 ncpw = 0 ngp = 0 ngps = 0 ngpw = 0 stown = 0 stownw = 0 stowns = 0 icnt = 0 DO mc = 1 , nct i = idx ( mc ) i = idx ( mc ) ! ! index contains the desired ordering of sticks (see above) ! i1 = in1 ( i ) i2 = in2 ( i ) ! IF ( ( . not . tk ) . and . ( ( i1 < 0 ) . or . ( ( i1 == 0 ) . and . ( i2 < 0 ) ) ) ) GOTO 30 ! jj = 1 IF ( ngcw ( i ) > 0 ) THEN ! ! this is an active sticks: find which processor has currently ! the smallest number of plane waves ! !jj = MOD( icnt, nproc ) + 1 !icnt = icnt + 1 DO j = 1 , nproc IF ( ngpw ( j ) < ngpw ( jj ) ) THEN jj = j ELSEIF ( ( ngpw ( j ) == ngpw ( jj ) ) . and . ( ncpw ( j ) < ncpw ( jj ) ) ) THEN jj = j ENDIF ENDDO ELSE ! ! this is an inactive sticks: find which processor has currently ! the smallest number of G-vectors ! DO j = 1 , nproc IF ( ngp ( j ) < ngp ( jj ) ) jj = j ENDDO ENDIF ! ! potential mesh ncp ( jj ) = ncp ( jj ) + 1 ngp ( jj ) = ngp ( jj ) + ngc ( i ) stown ( i1 , i2 ) = jj ! smooth mesh IF ( ngcs ( i ) > 0 ) THEN ncps ( jj ) = ncps ( jj ) + 1 ngps ( jj ) = ngps ( jj ) + ngcs ( i ) stowns ( i1 , i2 ) = jj ENDIF ! wave functions mesh IF ( ngcw ( i ) > 0 ) THEN ncpw ( jj ) = ncpw ( jj ) + 1 ngpw ( jj ) = ngpw ( jj ) + ngcw ( i ) stownw ( i1 , i2 ) = jj ENDIF 30 CONTINUE ENDDO RETURN END SUBROUTINE sticks_dist !=----------------------------------------------------------------------= SUBROUTINE sticks_pairup ( tk , ub , lb , idx , in1 , in2 , ngc , ngcw , ngcs , nct , & ncp , ncpw , ncps , ngp , ngpw , ngps , stown , stownw , stowns , nproc ) LOGICAL , INTENT ( in ) :: tk INTEGER , INTENT ( in ) :: ub (:), lb (:), idx (:) INTEGER , INTENT ( inout ) :: stown ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for potential INTEGER , INTENT ( inout ) :: stownw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( inout ) :: stowns ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( in ) :: in1 (:), in2 (:) INTEGER , INTENT ( in ) :: ngc (:), ngcw (:), ngcs (:) INTEGER , INTENT ( in ) :: nct INTEGER , INTENT ( out ) :: ncp (:), ncpw (:), ncps (:) INTEGER , INTENT ( out ) :: ngp (:), ngpw (:), ngps (:) INTEGER , INTENT ( in ) :: nproc ! number of proc in the g-vec group INTEGER :: mc , i1 , i2 , i , jj IF ( . not . tk ) THEN !  when gamma symmetry is used only the sticks of half reciprocal space !  are generated, then here we pair-up the sticks with those of the other !  half of the space, using the gamma symmetry relation !  Note that the total numero of stick \"nct\" is not modified DO mc = 1 , nct i = idx ( mc ) i1 = in1 ( i ) i2 = in2 ( i ) IF ( i1 == 0 . and . i2 == 0 ) THEN jj = stown ( i1 , i2 ) IF ( jj > 0 ) ngp ( jj ) = ngp ( jj ) + ngc ( i ) - 1 jj = stowns ( i1 , i2 ) IF ( jj > 0 ) ngps ( jj ) = ngps ( jj ) + ngcs ( i ) - 1 jj = stownw ( i1 , i2 ) IF ( jj > 0 ) ngpw ( jj ) = ngpw ( jj ) + ngcw ( i ) - 1 ELSE jj = stown ( i1 , i2 ) IF ( jj > 0 ) THEN stown ( - i1 , - i2 ) = jj ncp ( jj ) = ncp ( jj ) + 1 ngp ( jj ) = ngp ( jj ) + ngc ( i ) ENDIF jj = stowns ( i1 , i2 ) IF ( jj > 0 ) THEN stowns ( - i1 , - i2 ) = jj ncps ( jj ) = ncps ( jj ) + 1 ngps ( jj ) = ngps ( jj ) + ngcs ( i ) ENDIF jj = stownw ( i1 , i2 ) IF ( jj > 0 ) THEN stownw ( - i1 , - i2 ) = jj ncpw ( jj ) = ncpw ( jj ) + 1 ngpw ( jj ) = ngpw ( jj ) + ngcw ( i ) ENDIF ENDIF ENDDO ENDIF IF ( allocated ( sticks_owner ) ) DEALLOCATE ( sticks_owner ) ALLOCATE ( sticks_owner ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) sticks_owner ( :, : ) = abs ( stown ( :, :) ) RETURN END SUBROUTINE sticks_pairup !=----------------------------------------------------------------------= SUBROUTINE sticks_ordered_dist ( tk , ub , lb , idx , in1 , in2 , ngc , ngcw , ngcs , nct , & ncp , ncpw , ncps , ngp , ngpw , ngps , stown , stownw , stowns , nproc ) ! ! This routine works as sticks_dist only it distributes the sticks according to sticks_owner. ! This ensures that the gvectors for any 'smooth like grid' remain on the same proc as the ! original grid. ! LOGICAL , INTENT ( in ) :: tk INTEGER , INTENT ( in ) :: ub (:), lb (:), idx (:) INTEGER , INTENT ( out ) :: stown ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for potential INTEGER , INTENT ( out ) :: stownw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for wave functions INTEGER , INTENT ( out ) :: stowns ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ! stick map for smooth mesh INTEGER , INTENT ( in ) :: in1 (:), in2 (:) INTEGER , INTENT ( in ) :: ngc (:), ngcw (:), ngcs (:) INTEGER , INTENT ( in ) :: nct INTEGER , INTENT ( out ) :: ncp (:), ncpw (:), ncps (:) INTEGER , INTENT ( out ) :: ngp (:), ngpw (:), ngps (:) INTEGER , INTENT ( in ) :: nproc ! number of proc in the g-vec group INTEGER :: mc , i1 , i2 , i , j , jj ncp = 0 ncps = 0 ncpw = 0 ngp = 0 ngps = 0 ngpw = 0 stown = sticks_owner stownw = 0 stowns = 0 DO mc = 1 , nct i = idx ( mc ) ! ! index has no effect in this case ! i1 = in1 ( i ) i2 = in2 ( i ) ! IF ( ( . not . tk ) . and . ( ( i1 < 0 ) . or . ( ( i1 == 0 ) . and . ( i2 < 0 ) ) ) ) GOTO 30 ! ! potential mesh set according to sticks_owner jj = stown ( i1 , i2 ) ncp ( jj ) = ncp ( jj ) + 1 ngp ( jj ) = ngp ( jj ) + ngc ( i ) ! smooth mesh IF ( ngcs ( i ) > 0 ) THEN ncps ( jj ) = ncps ( jj ) + 1 ngps ( jj ) = ngps ( jj ) + ngcs ( i ) stowns ( i1 , i2 ) = jj ENDIF ! wave functions mesh IF ( ngcw ( i ) > 0 ) THEN ncpw ( jj ) = ncpw ( jj ) + 1 ngpw ( jj ) = ngpw ( jj ) + ngcw ( i ) stownw ( i1 , i2 ) = jj ENDIF 30 CONTINUE ENDDO RETURN END SUBROUTINE sticks_ordered_dist !=----------------------------------------------------------------------= SUBROUTINE sticks_deallocate IF ( allocated ( sticks_owner ) ) DEALLOCATE ( sticks_owner ) RETURN END SUBROUTINE sticks_deallocate !=----------------------------------------------------------------------= END MODULE stick_base !=----------------------------------------------------------------------=","tags":"","loc":"sourcefile/stick_base.f90.html","title":"stick_base.f90 â€“ FFTXlib"},{"text":"Source Code ! ! Copyright (C) Quantum ESPRESSO group ! ! This file is distributed under the terms of the ! GNU General Public License. See the file `License' ! in the root directory of the present distribution, ! or http://www.gnu.org/copyleft/gpl.txt . ! !=----------------------------------------------------------------------= MODULE stick_set !=----------------------------------------------------------------------= !  ... Distribute G-vectors across processors as sticks and planes, !  ... initialize FFT descriptors for both dense and smooth grids USE stick_base USE fft_types , ONLY : fft_dlay_descriptor , fft_dlay_allocate , & fft_dlay_set , fft_dlay_scalar IMPLICIT NONE INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) PRIVATE SAVE PUBLIC :: pstickset , pstickset_custom !=----------------------------------------------------------------------= CONTAINS !=----------------------------------------------------------------------= SUBROUTINE pstickset ( gamma_only , bg , gcut , gkcut , gcuts , & dfftp , dffts , ngw , ngm , ngs , mype , root , nproc , comm , nogrp_ , & ionode , stdout , dfft3d ) LOGICAL , INTENT ( in ) :: gamma_only ! ...     bg(:,1), bg(:,2), bg(:,3) reciprocal space base vectors. REAL ( DP ), INTENT ( in ) :: bg ( 3 , 3 ) REAL ( DP ), INTENT ( in ) :: gcut , gkcut , gcuts TYPE ( fft_dlay_descriptor ), INTENT ( inout ) :: dfftp , dffts INTEGER , INTENT ( out ) :: ngw , ngm , ngs INTEGER , INTENT ( IN ) :: mype , root , nproc , comm INTEGER , INTENT ( IN ) :: nogrp_ LOGICAL , INTENT ( IN ) :: ionode INTEGER , INTENT ( IN ) :: stdout TYPE ( fft_dlay_descriptor ), OPTIONAL , INTENT ( inout ) :: dfft3d LOGICAL :: tk INTEGER :: ub ( 3 ), lb ( 3 ) ! ...     ub(i), lb(i) upper and lower miller indexes ! ! ...     Plane Waves ! INTEGER , ALLOCATABLE :: stw (:,:) ! ...   stick map (wave functions), stw(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstpw (:) ! ...   number of sticks (wave functions), nstpw(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstpw (:) ! ...   number of G-vectors (wave functions), sstpw(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nstw , nstpwx ! ...   nstw     local number of sticks (wave functions) ! ...   nstpwx   maximum among all processors of nstw ! ! ...     Potentials ! INTEGER , ALLOCATABLE :: st (:,:) ! ...   stick map (potentials), st(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstp (:) ! ...   number of sticks (potentials), nstp(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstp (:) ! ...   number of G-vectors (potentials), sstp(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nst , nstpx ! ...   nst      local number of sticks (potentials) ! ...   nstpx    maximum among all processors of nst ! ! ...     Smooth Mesh ! INTEGER , ALLOCATABLE :: sts (:,:) ! ...   stick map (smooth mesh), sts(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstps (:) ! ...   number of sticks (smooth mesh), nstp(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstps (:) ! ...   number of G-vectors (smooth mesh), sstps(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nsts ! ...   nsts      local number of sticks (smooth mesh) INTEGER , ALLOCATABLE :: ist (:,:) ! sticks indices ordered INTEGER :: ip , ngm_ , ngs_ INTEGER , ALLOCATABLE :: idx (:) tk = . not . gamma_only ub ( 1 ) = ( dfftp % nr1 - 1 ) / 2 ub ( 2 ) = ( dfftp % nr2 - 1 ) / 2 ub ( 3 ) = ( dfftp % nr3 - 1 ) / 2 lb = - ub ! ...       Allocate maps ALLOCATE ( stw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) ALLOCATE ( st ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) ALLOCATE ( sts ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) st = 0 stw = 0 sts = 0 ! ...       Fill in the stick maps, for given g-space base and cut-off CALL sticks_maps ( tk , ub , lb , bg (:, 1 ), bg (:, 2 ), bg (:, 3 ), & gcut , gkcut , gcuts , st , stw , sts , mype , & nproc , comm ) ! ...       Now count the number of stick nst and nstw nst = count ( st > 0 ) nstw = count ( stw > 0 ) nsts = count ( sts > 0 ) ALLOCATE ( ist ( nst , 5 )) ALLOCATE ( nstp ( nproc )) ALLOCATE ( sstp ( nproc )) ALLOCATE ( nstpw ( nproc )) ALLOCATE ( sstpw ( nproc )) ALLOCATE ( nstps ( nproc )) ALLOCATE ( sstps ( nproc )) ! ...       initialize the sticks indexes array ist CALL sticks_countg ( tk , ub , lb , st , stw , sts , & ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ) ) ! ...       Sorts the sticks according to their length ALLOCATE ( idx ( nst ) ) CALL sticks_sort ( ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), nst , idx , nproc ) ! ... Set as first stick the stick containing the G=0 ! !  DO iss = 1, nst !    IF( ist( idx( iss ), 1 ) == 0 .AND. ist( idx( iss ), 2 ) == 0 )  EXIT !  END DO !  itmp         = idx( 1 ) !  idx( 1 )   = idx( iss ) !  idx( iss ) = itmp CALL sticks_dist ( tk , ub , lb , idx , ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), & nst , nstp , nstpw , nstps , sstp , sstpw , sstps , st , stw , sts , nproc ) ngw = sstpw ( mype + 1 ) ngm = sstp ( mype + 1 ) ngs = sstps ( mype + 1 ) CALL sticks_pairup ( tk , ub , lb , idx , ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), & nst , nstp , nstpw , nstps , sstp , sstpw , sstps , st , stw , sts , nproc ) ! ...   Allocate and Set fft data layout descriptors #if defined(__MPI) CALL fft_dlay_allocate ( dfftp , mype , root , nproc , comm , nogrp_ , dfftp % nr1x , dfftp % nr2x ) CALL fft_dlay_allocate ( dffts , mype , root , nproc , comm , nogrp_ , dffts % nr1x , dffts % nr2x ) CALL fft_dlay_set ( dfftp , tk , nst , dfftp % nr1 , dfftp % nr2 , dfftp % nr3 , dfftp % nr1x , dfftp % nr2x , dfftp % nr3x , & ub , lb , idx , ist (:, 1 ), ist (:, 2 ), nstp , nstpw , sstp , sstpw , st , stw ) CALL fft_dlay_set ( dffts , tk , nsts , dffts % nr1 , dffts % nr2 , dffts % nr3 , dffts % nr1x , dffts % nr2x , dffts % nr3x , & ub , lb , idx , ist (:, 1 ), ist (:, 2 ), nstps , nstpw , sstps , sstpw , sts , stw ) IF ( PRESENT ( dfft3d ) ) THEN DEALLOCATE ( stw ) ALLOCATE ( stw ( lb ( 2 ) : ub ( 2 ), lb ( 3 ) : ub ( 3 ) ) ) CALL sticks_maps_scalar ( (. not . tk ), ub , lb , bg (:, 1 ), bg (:, 2 ), bg (:, 3 ), gcut , gkcut , gcuts , stw , ngm_ , ngs_ ) CALL fft_dlay_allocate ( dfft3d , mype , root , nproc , comm , 1 , max ( dffts % nr1x , dffts % nr3x ), dffts % nr2x ) CALL fft_dlay_scalar ( dfft3d , ub , lb , dffts % nr1 , dffts % nr2 , dffts % nr3 , dffts % nr1x , dffts % nr2x , dffts % nr3x , stw ) END IF #else DEALLOCATE ( stw ) ALLOCATE ( stw ( lb ( 2 ) : ub ( 2 ), lb ( 3 ) : ub ( 3 ) ) ) CALL sticks_maps_scalar ( (. not . tk ), ub , lb , bg (:, 1 ), bg (:, 2 ), bg (:, 3 ),& gcut , gkcut , gcuts , stw , ngm_ , ngs_ ) IF ( ngm_ /= ngm ) CALL fftx_error__ ( ' pstickset ' , ' inconsistent ngm ' , abs ( ngm - ngm_ ) ) IF ( ngs_ /= ngs ) CALL fftx_error__ ( ' pstickset ' , ' inconsistent ngs ' , abs ( ngs - ngs_ ) ) CALL fft_dlay_allocate ( dfftp , mype , root , nproc , comm , 1 , max ( dfftp % nr1x , dfftp % nr3x ), dfftp % nr2x ) CALL fft_dlay_allocate ( dffts , mype , root , nproc , comm , 1 , max ( dffts % nr1x , dffts % nr3x ), dffts % nr2x ) CALL fft_dlay_scalar ( dfftp , ub , lb , dfftp % nr1 , dfftp % nr2 , dfftp % nr3 , dfftp % nr1x , dfftp % nr2x , dfftp % nr3x , stw ) CALL fft_dlay_scalar ( dffts , ub , lb , dffts % nr1 , dffts % nr2 , dffts % nr3 , dffts % nr1x , dffts % nr2x , dffts % nr3x , stw ) #endif ! ...     Maximum number of sticks (potentials) nstpx = maxval ( nstp ) ! ...     Maximum number of sticks (wave func.) nstpwx = maxval ( nstpw ) ! !  Initialize task groups. !  Note that this call modify dffts adding task group data. ! CALL task_groups_init ( dffts ) ! IF ( ionode ) THEN WRITE ( stdout , * ) IF ( nproc > 1 ) THEN WRITE ( stdout , '(5X,\"Parallelization info\")' ) ELSE WRITE ( stdout , '(5X,\"G-vector sticks info\")' ) ENDIF WRITE ( stdout , '(5X,\"--------------------\")' ) WRITE ( stdout , '(5X,\"sticks:   dense  smooth     PW\", & & 5X,\"G-vecs:    dense   smooth      PW\")' ) IF ( nproc > 1 ) THEN WRITE ( stdout , '(5X,\"Min\",4X,2I8,I7,12X,2I9,I8)' ) & minval ( nstp ), minval ( nstps ), minval ( nstpw ), & minval ( sstp ), minval ( sstps ), minval ( sstpw ) WRITE ( stdout , '(5X,\"Max\",4X,2I8,I7,12X,2I9,I8)' ) & maxval ( nstp ), maxval ( nstps ), maxval ( nstpw ), & maxval ( sstp ), maxval ( sstps ), maxval ( sstpw ) END IF WRITE ( stdout , '(5X,\"Sum\",4X,2I8,I7,12X,2I9,I8)' ) & sum ( nstp ), sum ( nstps ), sum ( nstpw ), & sum ( sstp ), sum ( sstps ), sum ( sstpw ) ! in the case k=0, the lines above and below differ: ! above all sticks, below only those in the half sphere IF ( . NOT . tk ) & WRITE ( stdout , '(5X,\"Tot\",4X,2I8,I7)' ) nst , nsts , nstw ENDIF DEALLOCATE ( ist ) DEALLOCATE ( idx ) DEALLOCATE ( st , stw , sts ) DEALLOCATE ( sstp ) DEALLOCATE ( nstp ) DEALLOCATE ( sstpw ) DEALLOCATE ( nstpw ) DEALLOCATE ( sstps ) DEALLOCATE ( nstps ) IF ( ionode ) WRITE ( stdout , * ) RETURN END SUBROUTINE pstickset !---------------------------------------------------------------------- SUBROUTINE pstickset_custom ( gamma_only , bg , gcut , gkcut , gcuts , & dfftp , dffts , ngw , ngm , ngs , mype , root , nproc , comm , nogrp_ ) LOGICAL , INTENT ( in ) :: gamma_only ! ...     bg(:,1), bg(:,2), bg(:,3) reciprocal space base vectors. REAL ( DP ), INTENT ( in ) :: bg ( 3 , 3 ) REAL ( DP ), INTENT ( in ) :: gcut , gkcut , gcuts TYPE ( fft_dlay_descriptor ), INTENT ( inout ) :: dfftp , dffts INTEGER , INTENT ( inout ) :: ngw , ngm , ngs INTEGER , INTENT ( IN ) :: mype , root , nproc , comm INTEGER , INTENT ( IN ) :: nogrp_ LOGICAL :: tk INTEGER :: ub ( 3 ), lb ( 3 ) ! ...     ub(i), lb(i) upper and lower miller indexes ! ! ...     Plane Waves ! INTEGER , ALLOCATABLE :: stw (:,:) ! ...   stick map (wave functions), stw(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstpw (:) ! ...   number of sticks (wave functions), nstpw(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstpw (:) ! ...   number of G-vectors (wave functions), sstpw(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nstw , nstpwx ! ...   nstw     local number of sticks (wave functions) ! ...   nstpwx   maximum among all processors of nstw ! ! ...     Potentials ! INTEGER , ALLOCATABLE :: st (:,:) ! ...   stick map (potentials), st(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstp (:) ! ...   number of sticks (potentials), nstp(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstp (:) ! ...   number of G-vectors (potentials), sstp(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nst , nstpx ! ...   nst      local number of sticks (potentials) ! ...   nstpx    maximum among all processors of nst ! ! ...     Smooth Mesh ! INTEGER , ALLOCATABLE :: sts (:,:) ! ...   stick map (smooth mesh), sts(i,j) = number of G-vector in the ! ...     stick whose x and y miller index are i and j INTEGER , ALLOCATABLE :: nstps (:) ! ...   number of sticks (smooth mesh), nstp(ip) = number of stick ! ...     for processor ip INTEGER , ALLOCATABLE :: sstps (:) ! ...   number of G-vectors (smooth mesh), sstps(ip) = sum of the ! ...     sticks length for processor ip = number of G-vectors ! ...     owned by the processor ip INTEGER :: nsts ! ...   nsts      local number of sticks (smooth mesh) INTEGER , ALLOCATABLE :: ist (:,:) ! sticks indices ordered INTEGER :: ip , ngm_ , ngs_ INTEGER , ALLOCATABLE :: idx (:) tk = . not . gamma_only ub ( 1 ) = ( dfftp % nr1 - 1 ) / 2 ub ( 2 ) = ( dfftp % nr2 - 1 ) / 2 ub ( 3 ) = ( dfftp % nr3 - 1 ) / 2 lb = - ub ! ...       Allocate maps ALLOCATE ( stw ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) ALLOCATE ( st ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) ALLOCATE ( sts ( lb ( 1 ): ub ( 1 ), lb ( 2 ): ub ( 2 ) ) ) st = 0 stw = 0 sts = 0 ! ...       Fill in the stick maps, for given g-space base and cut-off CALL sticks_maps ( tk , ub , lb , bg (:, 1 ), bg (:, 2 ), bg (:, 3 ), & gcut , gkcut , gcuts , st , stw , sts , mype , & nproc , comm ) ! ...       Now count the number of stick nst and nstw nst = count ( st > 0 ) nstw = count ( stw > 0 ) nsts = count ( sts > 0 ) ALLOCATE ( ist ( nst , 5 )) ALLOCATE ( nstp ( nproc )) ALLOCATE ( sstp ( nproc )) ALLOCATE ( nstpw ( nproc )) ALLOCATE ( sstpw ( nproc )) ALLOCATE ( nstps ( nproc )) ALLOCATE ( sstps ( nproc )) ! ...       initialize the sticks indexes array ist CALL sticks_countg ( tk , ub , lb , st , stw , sts , & ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ) ) ! ...       Sorts the sticks according to their length ALLOCATE ( idx ( nst ) ) CALL sticks_sort ( ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), nst , idx , nproc ) ! ...       Distribute the sticks as in dfftp CALL sticks_ordered_dist ( tk , ub , lb , idx , ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), & nst , nstp , nstpw , nstps , sstp , sstpw , sstps , st , stw , sts , nproc ) ngw = sstpw ( mype + 1 ) ngm = sstp ( mype + 1 ) ngs = sstps ( mype + 1 ) CALL sticks_pairup ( tk , ub , lb , idx , ist (:, 1 ), ist (:, 2 ), ist (:, 4 ), ist (:, 3 ), ist (:, 5 ), & nst , nstp , nstpw , nstps , sstp , sstpw , sstps , st , stw , sts , nproc ) ! ...   Allocate and Set fft data layout descriptors #if defined(__MPI) CALL fft_dlay_allocate ( dffts , mype , root , nproc , comm , nogrp_ , dffts % nr1x , dffts % nr2x ) CALL fft_dlay_set ( dffts , tk , nsts , dffts % nr1 , dffts % nr2 , dffts % nr3 , dffts % nr1x , dffts % nr2x , dffts % nr3x , & ub , lb , idx , ist (:, 1 ), ist (:, 2 ), nstps , nstpw , sstps , sstpw , sts , stw ) #else DEALLOCATE ( stw ) ALLOCATE ( stw ( lb ( 2 ) : ub ( 2 ), lb ( 3 ) : ub ( 3 ) ) ) CALL sticks_maps_scalar ( (. not . tk ), ub , lb , bg (:, 1 ), bg (:, 2 ), bg (:, 3 ),& gcut , gkcut , gcuts , stw , ngm_ , ngs_ ) IF ( ngs_ /= ngs ) CALL fftx_error__ ( ' pstickset_custom ' , ' inconsistent ngs ' , abs ( ngs - ngs_ ) ) CALL fft_dlay_allocate ( dffts , mype , root , nproc , comm , 1 , max ( dffts % nr1x , dffts % nr3x ), dffts % nr2x ) CALL fft_dlay_scalar ( dffts , ub , lb , dffts % nr1 , dffts % nr2 , dffts % nr3 , dffts % nr1x , dffts % nr2x , dffts % nr3x , stw ) #endif ! ...     Maximum number of sticks (potentials) nstpx = maxval ( nstp ) ! ...     Maximum number of sticks (wave func.) nstpwx = maxval ( nstpw ) DEALLOCATE ( ist ) DEALLOCATE ( idx ) DEALLOCATE ( st , stw , sts ) DEALLOCATE ( sstp ) DEALLOCATE ( nstp ) DEALLOCATE ( sstpw ) DEALLOCATE ( nstpw ) DEALLOCATE ( sstps ) DEALLOCATE ( nstps ) RETURN END SUBROUTINE pstickset_custom !----------------------------------------- ! Task groups Contributed by C. Bekas, October 2005 ! Revised by C. Cavazzoni !-------------------------------------------- SUBROUTINE task_groups_init ( dffts ) ! USE fft_types , ONLY : fft_dlay_descriptor ! T.G. ! NPGRP:      Number of processors per group ! NOGRP:      Number of processors per orbital task group IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif TYPE ( fft_dlay_descriptor ), INTENT ( inout ) :: dffts INTEGER :: stdout = 6 !---------------------------------- !Local Variables declaration !---------------------------------- INTEGER :: I INTEGER :: IERR INTEGER :: num_planes , num_sticks INTEGER :: nnrsx_vec ( dffts % nproc ) INTEGER :: pgroup ( dffts % nproc ) INTEGER :: strd CALL task_groups_init_first ( dffts ) ! #if defined(DEBUG) IF ( dffts % nogrp > 1 ) WRITE ( stdout , 100 ) dffts % nogrp , dffts % npgrp 100 FORMAT ( / , 3 X , 'Task Groups are in USE' , / , 3 X , 'groups and procs/group : ' , I5 , I5 ) #endif !Find maximum chunk of local data concerning coefficients of eigenfunctions in g-space #if defined(__MPI) CALL MPI_Allgather ( dffts % nnr , 1 , MPI_INTEGER , nnrsx_vec , 1 , MPI_INTEGER , dffts % comm , IERR ) strd = maxval ( nnrsx_vec ( 1 : dffts % nproc ) ) #else strd = dffts % nnr #endif IF ( strd /= dffts % tg_nnr ) CALL fftx_error__ ( ' task_groups_init ' , ' inconsistent nnr ' , 1 ) !------------------------------------------------------------------------------------- !C. Bekas...TASK GROUP RELATED. FFT DATA STRUCTURES ARE ALREADY DEFINED ABOVE !------------------------------------------------------------------------------------- !dfft%nsw(me) holds the number of z-sticks for the current processor per wave-function !We can either send these in the group with an mpi_allgather...or put them !in the PSIS vector (in special positions) and send them with them. !Otherwise we can do this once at the beginning, before the loop. !we choose to do the latter one. !------------------------------------------------------------------------------------- ! ! ALLOCATE ( dffts % tg_nsw ( dffts % nproc )) ALLOCATE ( dffts % tg_npp ( dffts % nproc )) num_sticks = 0 num_planes = 0 DO i = 1 , dffts % nogrp num_sticks = num_sticks + dffts % nsw ( dffts % nolist ( i ) + 1 ) num_planes = num_planes + dffts % npp ( dffts % nolist ( i ) + 1 ) ENDDO #if defined(__MPI) CALL MPI_ALLGATHER ( num_sticks , 1 , MPI_INTEGER , dffts % tg_nsw ( 1 ), 1 , MPI_INTEGER , dffts % comm , IERR ) CALL MPI_ALLGATHER ( num_planes , 1 , MPI_INTEGER , dffts % tg_npp ( 1 ), 1 , MPI_INTEGER , dffts % comm , IERR ) #else dffts % tg_nsw ( 1 ) = num_sticks dffts % tg_npp ( 1 ) = num_planes #endif ALLOCATE ( dffts % tg_snd ( dffts % nogrp ) ) ALLOCATE ( dffts % tg_rcv ( dffts % nogrp ) ) ALLOCATE ( dffts % tg_psdsp ( dffts % nogrp ) ) ALLOCATE ( dffts % tg_usdsp ( dffts % nogrp ) ) ALLOCATE ( dffts % tg_rdsp ( dffts % nogrp ) ) dffts % tg_snd ( 1 ) = dffts % nr3x * dffts % nsw ( dffts % mype + 1 ) IF ( dffts % nr3x * dffts % nsw ( dffts % mype + 1 ) > dffts % tg_nnr ) THEN CALL fftx_error__ ( ' task_groups_init ' , ' inconsistent dffts%tg_nnr ' , 1 ) ENDIF dffts % tg_psdsp ( 1 ) = 0 dffts % tg_usdsp ( 1 ) = 0 dffts % tg_rcv ( 1 ) = dffts % nr3x * dffts % nsw ( dffts % nolist ( 1 ) + 1 ) dffts % tg_rdsp ( 1 ) = 0 DO i = 2 , dffts % nogrp dffts % tg_snd ( i ) = dffts % nr3x * dffts % nsw ( dffts % mype + 1 ) dffts % tg_psdsp ( i ) = dffts % tg_psdsp ( i - 1 ) + dffts % tg_nnr dffts % tg_usdsp ( i ) = dffts % tg_usdsp ( i - 1 ) + dffts % tg_snd ( i - 1 ) dffts % tg_rcv ( i ) = dffts % nr3x * dffts % nsw ( dffts % nolist ( i ) + 1 ) dffts % tg_rdsp ( i ) = dffts % tg_rdsp ( i - 1 ) + dffts % tg_rcv ( i - 1 ) ENDDO RETURN END SUBROUTINE task_groups_init ! SUBROUTINE task_groups_init_first ( dffts ) ! USE fft_types , ONLY : fft_dlay_descriptor ! IMPLICIT NONE #if defined(__MPI) INCLUDE 'mpif.h' #endif ! TYPE ( fft_dlay_descriptor ), INTENT ( inout ) :: dffts ! INTEGER :: i , n1 , ipos , color , key , ierr , itsk , ntsk INTEGER :: pgroup ( dffts % nproc ) ! !SUBDIVIDE THE PROCESSORS IN GROUPS ! DO i = 1 , dffts % nproc pgroup ( i ) = i - 1 ENDDO ! #if defined(__TASK_GROUP_WAVE_ORDER) n1 = ( dffts % mype / dffts % npgrp ) * dffts % npgrp ipos = dffts % mype - n1 #else n1 = ( dffts % mype / dffts % nogrp ) * dffts % nogrp ipos = dffts % mype - n1 #endif ! !LIST OF PROCESSORS IN MY ORBITAL GROUP !     (processors dealing with my same pw's of different orbitals) ! !  processors in these group have contiguous indexes ! DO i = 1 , dffts % nogrp #if defined(__TASK_GROUP_WAVE_ORDER) dffts % nolist ( i ) = pgroup ( ipos + ( i - 1 ) * dffts % npgrp + 1 ) #else dffts % nolist ( i ) = pgroup ( n1 + i ) #endif ENDDO ! !LIST OF PROCESSORS IN MY PLANE WAVE GROUP !     (processors dealing with different pw's of my same orbital) ! DO i = 1 , dffts % npgrp #if defined(__TASK_GROUP_WAVE_ORDER) dffts % nplist ( i ) = pgroup ( n1 + i ) #else dffts % nplist ( i ) = pgroup ( ipos + ( i - 1 ) * dffts % nogrp + 1 ) #endif ENDDO ! !SET UP THE GROUPS ! !CREATE ORBITAL GROUPS ! #if defined(__MPI) ! processes with the same color are in the same new communicator #if defined(__TASK_GROUP_WAVE_ORDER) color = MOD ( dffts % mype , dffts % npgrp ) key = dffts % mype / dffts % npgrp #else color = dffts % mype / dffts % nogrp key = MOD ( dffts % mype , dffts % nogrp ) #endif CALL MPI_COMM_SPLIT ( dffts % comm , color , key , dffts % ogrp_comm , ierr ) if ( ierr /= 0 ) & CALL fftx_error__ ( ' task_groups_init_first ' , ' creating ogrp_comm ' , ABS ( ierr ) ) CALL MPI_COMM_RANK ( dffts % ogrp_comm , itsk , IERR ) CALL MPI_COMM_SIZE ( dffts % ogrp_comm , ntsk , IERR ) IF ( dffts % nogrp /= ntsk ) CALL fftx_error__ ( ' task_groups_init_first ' , ' ogrp_comm size ' , ntsk ) DO i = 1 , dffts % nogrp IF ( dffts % mype == dffts % nolist ( i ) ) THEN IF ( ( i - 1 ) /= itsk ) CALL fftx_error__ ( ' task_groups_init_first ' , ' ogrp_comm rank ' , itsk ) END IF END DO #endif ! !CREATE PLANEWAVE GROUPS ! #if defined(__MPI) ! processes with the same color are in the same new communicator #if defined(__TASK_GROUP_WAVE_ORDER) color = dffts % mype / dffts % npgrp key = MOD ( dffts % mype , dffts % npgrp ) #else color = MOD ( dffts % mype , dffts % nogrp ) key = dffts % mype / dffts % nogrp #endif CALL MPI_COMM_SPLIT ( dffts % comm , color , key , dffts % pgrp_comm , ierr ) if ( ierr /= 0 ) & CALL fftx_error__ ( ' task_groups_init_first ' , ' creating pgrp_comm ' , ABS ( ierr ) ) CALL MPI_COMM_RANK ( dffts % pgrp_comm , itsk , IERR ) CALL MPI_COMM_SIZE ( dffts % pgrp_comm , ntsk , IERR ) IF ( dffts % npgrp /= ntsk ) CALL fftx_error__ ( ' task_groups_init_first ' , ' pgrp_comm size ' , ntsk ) DO i = 1 , dffts % npgrp IF ( dffts % mype == dffts % nplist ( i ) ) THEN IF ( ( i - 1 ) /= itsk ) CALL fftx_error__ ( ' task_groups_init_first ' , ' pgrp_comm rank ' , itsk ) END IF END DO dffts % me_pgrp = itsk #endif RETURN END SUBROUTINE task_groups_init_first ! !=----------------------------------------------------------------------= END MODULE stick_set !=----------------------------------------------------------------------=","tags":"","loc":"sourcefile/stick_set.f90.html","title":"stick_set.f90 â€“ FFTXlib"},{"text":"type, private :: dfti_descriptor_array type~~dfti_descriptor_array~~InheritsGraph type~dfti_descriptor_array dfti_descriptor_array DFTI_DESCRIPTOR DFTI_DESCRIPTOR DFTI_DESCRIPTOR->type~dfti_descriptor_array desc Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type(DFTI_DESCRIPTOR), public, POINTER :: desc","tags":"","loc":"type/dfti_descriptor_array.html","title":"dfti_descriptor_array â€“ FFTXlib "},{"text":"type, public :: fft_dlay_descriptor Components Type Visibility Attributes Name Initial integer, public :: nst integer, public, POINTER :: nsp (:) integer, public, POINTER :: nsw (:) integer, public :: nr1 = 0 integer, public :: nr2 = 0 integer, public :: nr3 = 0 integer, public :: nr1x = 0 integer, public :: nr2x = 0 integer, public :: nr3x = 0 integer, public :: npl = 0 integer, public :: nnp = 0 integer, public :: nnr = 0 integer, public, POINTER :: ngl (:) integer, public, POINTER :: nwl (:) integer, public, POINTER :: npp (:) integer, public, POINTER :: ipp (:) integer, public, POINTER :: iss (:) integer, public, POINTER :: isind (:) integer, public, POINTER :: ismap (:) integer, public, POINTER :: iplp (:) integer, public, POINTER :: iplw (:) integer, public :: id integer, public :: tptr integer, public, POINTER :: irb (:,:) integer, public, POINTER :: imin3 (:) integer, public, POINTER :: imax3 (:) integer, public, POINTER :: np3 (:) integer, public :: mype integer, public :: comm integer, public :: nproc integer, public :: root logical, public :: have_task_groups integer, public :: me_pgrp integer, public :: nogrp integer, public :: npgrp integer, public :: ogrp_comm integer, public :: pgrp_comm integer, public, POINTER :: nolist (:) integer, public, POINTER :: nplist (:) integer, public :: tg_nnr integer, public, POINTER :: tg_nsw (:) integer, public, POINTER :: tg_npp (:) integer, public, POINTER :: tg_snd (:) integer, public, POINTER :: tg_rcv (:) integer, public, POINTER :: tg_psdsp (:) integer, public, POINTER :: tg_usdsp (:) integer, public, POINTER :: tg_rdsp (:)","tags":"","loc":"type/fft_dlay_descriptor.html","title":"fft_dlay_descriptor â€“ FFTXlib "},{"text":"subroutine fftx_error__(calling_routine, message, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calling_routine character(len=*), intent(in) :: message integer, intent(in) :: ierr Calls proc~~fftx_error__~~CallsGraph proc~fftx_error__ fftx_error__ mpi_abort mpi_abort proc~fftx_error__->mpi_abort Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=6), public :: cerr integer, public :: info","tags":"","loc":"proc/fftx_error__.html","title":"fftx_error__ â€“ FFTXlib"},{"text":"subroutine invfft_x(grid_type, f, dfft) Uses: fft_scalar fft_smallbox fft_parallel fft_types Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~invfft_x~~CallsGraph proc~invfft_x invfft_x proc~cfft3d cfft3d proc~invfft_x->proc~cfft3d proc~tg_cft3s tg_cft3s proc~invfft_x->proc~tg_cft3s proc~cfft3ds cfft3ds proc~invfft_x->proc~cfft3ds stop_clock stop_clock proc~invfft_x->stop_clock fftx_error__ fftx_error__ proc~invfft_x->fftx_error__ start_clock start_clock proc~invfft_x->start_clock dfticomputeforward dfticomputeforward proc~cfft3d->dfticomputeforward none~lookup~3 lookup proc~cfft3d->none~lookup~3 dfticomputebackward dfticomputebackward proc~cfft3d->dfticomputebackward none~check_dims~2 check_dims proc~cfft3d->none~check_dims~2 none~init_dfti~3 init_dfti proc~cfft3d->none~init_dfti~3 proc~tg_cft3s->fftx_error__ proc~cft_2xy cft_2xy proc~tg_cft3s->proc~cft_2xy proc~unpack_group_sticks unpack_group_sticks proc~tg_cft3s->proc~unpack_group_sticks proc~cft_1z cft_1z proc~tg_cft3s->proc~cft_1z none~bw_scatter bw_scatter proc~tg_cft3s->none~bw_scatter none~fw_scatter fw_scatter proc~tg_cft3s->none~fw_scatter proc~pack_group_sticks pack_group_sticks proc~tg_cft3s->proc~pack_group_sticks proc~cfft3ds->proc~cfft3d none~check_dims~2->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti~3->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~3->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~3->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~3->dfticreatedescriptor proc~cft_2xy->stop_clock proc~cft_2xy->fftx_error__ proc~cft_2xy->start_clock proc~cft_2xy->dfticomputeforward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 none~lookup~2 lookup proc~cft_2xy->none~lookup~2 proc~unpack_group_sticks->stop_clock proc~unpack_group_sticks->fftx_error__ proc~unpack_group_sticks->start_clock mpi_alltoallv mpi_alltoallv proc~unpack_group_sticks->mpi_alltoallv proc~cft_1z->stop_clock proc~cft_1z->fftx_error__ proc~cft_1z->start_clock proc~cft_1z->dfticomputeforward proc~cft_1z->dfticomputebackward none~check_dims check_dims proc~cft_1z->none~check_dims none~lookup lookup proc~cft_1z->none~lookup none~init_dfti init_dfti proc~cft_1z->none~init_dfti proc~fft_scatter fft_scatter none~bw_scatter->proc~fft_scatter none~fw_scatter->proc~fft_scatter proc~pack_group_sticks->stop_clock proc~pack_group_sticks->fftx_error__ proc~pack_group_sticks->start_clock proc~pack_group_sticks->mpi_alltoallv none~init_dfti~2->dfticommitdescriptor none~init_dfti~2->dftisetvalue none~init_dfti~2->dftifreedescriptor none~init_dfti~2->dfticreatedescriptor none~check_dims->fftx_error__ none~init_dfti->fftx_error__ none~init_dfti->dfticommitdescriptor none~init_dfti->dftisetvalue none~init_dfti->dftifreedescriptor none~init_dfti->dfticreatedescriptor proc~fft_scatter->stop_clock proc~fft_scatter->fftx_error__ proc~fft_scatter->start_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200)","tags":"","loc":"proc/invfft_x.html","title":"invfft_x â€“ FFTXlib"},{"text":"subroutine fwfft_x(grid_type, f, dfft) Uses: fft_scalar fft_parallel fft_types Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~fwfft_x~~CallsGraph proc~fwfft_x fwfft_x proc~cfft3d cfft3d proc~fwfft_x->proc~cfft3d proc~tg_cft3s tg_cft3s proc~fwfft_x->proc~tg_cft3s proc~cfft3ds cfft3ds proc~fwfft_x->proc~cfft3ds stop_clock stop_clock proc~fwfft_x->stop_clock fftx_error__ fftx_error__ proc~fwfft_x->fftx_error__ start_clock start_clock proc~fwfft_x->start_clock dfticomputeforward dfticomputeforward proc~cfft3d->dfticomputeforward none~lookup~3 lookup proc~cfft3d->none~lookup~3 dfticomputebackward dfticomputebackward proc~cfft3d->dfticomputebackward none~check_dims~2 check_dims proc~cfft3d->none~check_dims~2 none~init_dfti~3 init_dfti proc~cfft3d->none~init_dfti~3 proc~tg_cft3s->fftx_error__ proc~cft_2xy cft_2xy proc~tg_cft3s->proc~cft_2xy proc~unpack_group_sticks unpack_group_sticks proc~tg_cft3s->proc~unpack_group_sticks proc~cft_1z cft_1z proc~tg_cft3s->proc~cft_1z none~bw_scatter bw_scatter proc~tg_cft3s->none~bw_scatter none~fw_scatter fw_scatter proc~tg_cft3s->none~fw_scatter proc~pack_group_sticks pack_group_sticks proc~tg_cft3s->proc~pack_group_sticks proc~cfft3ds->proc~cfft3d none~check_dims~2->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti~3->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~3->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~3->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~3->dfticreatedescriptor proc~cft_2xy->stop_clock proc~cft_2xy->fftx_error__ proc~cft_2xy->start_clock proc~cft_2xy->dfticomputeforward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 none~lookup~2 lookup proc~cft_2xy->none~lookup~2 proc~unpack_group_sticks->stop_clock proc~unpack_group_sticks->fftx_error__ proc~unpack_group_sticks->start_clock mpi_alltoallv mpi_alltoallv proc~unpack_group_sticks->mpi_alltoallv proc~cft_1z->stop_clock proc~cft_1z->fftx_error__ proc~cft_1z->start_clock proc~cft_1z->dfticomputeforward proc~cft_1z->dfticomputebackward none~check_dims check_dims proc~cft_1z->none~check_dims none~lookup lookup proc~cft_1z->none~lookup none~init_dfti init_dfti proc~cft_1z->none~init_dfti proc~fft_scatter fft_scatter none~bw_scatter->proc~fft_scatter none~fw_scatter->proc~fft_scatter proc~pack_group_sticks->stop_clock proc~pack_group_sticks->fftx_error__ proc~pack_group_sticks->start_clock proc~pack_group_sticks->mpi_alltoallv none~init_dfti~2->dfticommitdescriptor none~init_dfti~2->dftisetvalue none~init_dfti~2->dftifreedescriptor none~init_dfti~2->dfticreatedescriptor none~check_dims->fftx_error__ none~init_dfti->fftx_error__ none~init_dfti->dfticommitdescriptor none~init_dfti->dftisetvalue none~init_dfti->dftifreedescriptor none~init_dfti->dfticreatedescriptor proc~fft_scatter->stop_clock proc~fft_scatter->fftx_error__ proc~fft_scatter->start_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200)","tags":"","loc":"proc/fwfft_x.html","title":"fwfft_x â€“ FFTXlib"},{"text":"subroutine invfft_b(grid_type, f, dfft, ia) Uses: fft_scalar fft_smallbox fft_parallel fft_types Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft integer, intent(in) :: ia Calls proc~~invfft_b~~CallsGraph proc~invfft_b invfft_b proc~cfft3d cfft3d proc~invfft_b->proc~cfft3d fftx_error__ fftx_error__ proc~invfft_b->fftx_error__ proc~cft_b_omp cft_b_omp proc~invfft_b->proc~cft_b_omp stop_clock stop_clock proc~invfft_b->stop_clock proc~cft_b cft_b proc~invfft_b->proc~cft_b start_clock start_clock proc~invfft_b->start_clock dfticomputeforward dfticomputeforward proc~cfft3d->dfticomputeforward none~lookup~3 lookup proc~cfft3d->none~lookup~3 dfticomputebackward dfticomputebackward proc~cfft3d->dfticomputebackward none~check_dims~2 check_dims proc~cfft3d->none~check_dims~2 none~init_dfti~3 init_dfti proc~cfft3d->none~init_dfti~3 proc~cft_b_omp->fftx_error__ fftw_inplace_drv_1d fftw_inplace_drv_1d proc~cft_b_omp->fftw_inplace_drv_1d proc~cft_b->fftx_error__ proc~cft_b->fftw_inplace_drv_1d bw_planz bw_planz proc~cft_b->bw_planz bw_planx bw_planx proc~cft_b->bw_planx bw_planxy bw_planxy proc~cft_b->bw_planxy destroy_plan_1d destroy_plan_1d proc~cft_b->destroy_plan_1d create_plan_1d create_plan_1d proc~cft_b->create_plan_1d bw_plany bw_plany proc~cft_b->bw_plany destroy_plan_2d destroy_plan_2d proc~cft_b->destroy_plan_2d create_plan_2d create_plan_2d proc~cft_b->create_plan_2d none~check_dims~2->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti~3->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~3->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~3->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~3->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200) integer, public :: imin3 integer, public :: imax3 integer, public :: np3","tags":"","loc":"proc/invfft_b.html","title":"invfft_b â€“ FFTXlib"},{"text":"public interface invfft Subroutines public subroutine invfft_x(grid_type, f, dfft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft public subroutine invfft_b(grid_type, f, dfft, ia) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft integer, intent(in) :: ia","tags":"","loc":"interface/invfft.html","title":"invfft â€“ FFTXlib"},{"text":"public interface fwfft Subroutines public subroutine fwfft_x(grid_type, f, dfft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft","tags":"","loc":"interface/fwfft.html","title":"fwfft â€“ FFTXlib"},{"text":"public subroutine tg_cft3s(f, dfft, isgn, use_task_groups) Uses: fft_scalar scatter_mod fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft integer, intent(in) :: isgn logical, intent(in), optional :: use_task_groups Calls proc~~tg_cft3s~~CallsGraph proc~tg_cft3s tg_cft3s proc~cft_2xy cft_2xy proc~tg_cft3s->proc~cft_2xy proc~unpack_group_sticks unpack_group_sticks proc~tg_cft3s->proc~unpack_group_sticks fftx_error__ fftx_error__ proc~tg_cft3s->fftx_error__ proc~cft_1z cft_1z proc~tg_cft3s->proc~cft_1z none~bw_scatter bw_scatter proc~tg_cft3s->none~bw_scatter none~fw_scatter fw_scatter proc~tg_cft3s->none~fw_scatter proc~pack_group_sticks pack_group_sticks proc~tg_cft3s->proc~pack_group_sticks proc~cft_2xy->fftx_error__ dfticomputebackward dfticomputebackward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 stop_clock stop_clock proc~cft_2xy->stop_clock none~lookup~2 lookup proc~cft_2xy->none~lookup~2 start_clock start_clock proc~cft_2xy->start_clock dfticomputeforward dfticomputeforward proc~cft_2xy->dfticomputeforward proc~unpack_group_sticks->fftx_error__ proc~unpack_group_sticks->stop_clock proc~unpack_group_sticks->start_clock mpi_alltoallv mpi_alltoallv proc~unpack_group_sticks->mpi_alltoallv proc~cft_1z->fftx_error__ proc~cft_1z->dfticomputebackward proc~cft_1z->stop_clock proc~cft_1z->start_clock proc~cft_1z->dfticomputeforward none~check_dims check_dims proc~cft_1z->none~check_dims none~lookup lookup proc~cft_1z->none~lookup none~init_dfti init_dfti proc~cft_1z->none~init_dfti proc~fft_scatter fft_scatter none~bw_scatter->proc~fft_scatter none~fw_scatter->proc~fft_scatter proc~pack_group_sticks->fftx_error__ proc~pack_group_sticks->stop_clock proc~pack_group_sticks->start_clock proc~pack_group_sticks->mpi_alltoallv dfticommitdescriptor dfticommitdescriptor none~init_dfti~2->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~2->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~2->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~2->dfticreatedescriptor none~check_dims->fftx_error__ none~init_dfti->fftx_error__ none~init_dfti->dfticommitdescriptor none~init_dfti->dftisetvalue none~init_dfti->dftifreedescriptor none~init_dfti->dfticreatedescriptor proc~fft_scatter->fftx_error__ proc~fft_scatter->stop_clock proc~fft_scatter->start_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~tg_cft3s~~CalledByGraph proc~tg_cft3s tg_cft3s proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: me_p integer, public :: n1 integer, public :: n2 integer, public :: n3 integer, public :: nx1 integer, public :: nx2 integer, public :: nx3 complex(kind=DP), public, ALLOCATABLE :: yf (:) complex(kind=DP), public, ALLOCATABLE :: aux (:) integer, public :: planes (dfft%nr1x) logical, public :: use_tg Subroutines subroutine fw_scatter(iopt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iopt subroutine bw_scatter(iopt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iopt","tags":"","loc":"proc/tg_cft3s.html","title":"tg_cft3s â€“ FFTXlib"},{"text":"public subroutine fw_tg_cft3_z(f_in, dfft, f_out) Uses: fft_scalar fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f_in (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_out (:) Calls proc~~fw_tg_cft3_z~~CallsGraph proc~fw_tg_cft3_z fw_tg_cft3_z proc~cft_1z cft_1z proc~fw_tg_cft3_z->proc~cft_1z none~check_dims check_dims proc~cft_1z->none~check_dims fftx_error__ fftx_error__ proc~cft_1z->fftx_error__ none~lookup lookup proc~cft_1z->none~lookup dfticomputebackward dfticomputebackward proc~cft_1z->dfticomputebackward stop_clock stop_clock proc~cft_1z->stop_clock none~init_dfti init_dfti proc~cft_1z->none~init_dfti start_clock start_clock proc~cft_1z->start_clock dfticomputeforward dfticomputeforward proc~cft_1z->dfticomputeforward none~check_dims->fftx_error__ none~init_dfti->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fw_tg_cft3_z.html","title":"fw_tg_cft3_z â€“ FFTXlib"},{"text":"public subroutine bw_tg_cft3_z(f_out, dfft, f_in) Uses: fft_scalar fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f_out (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_in (:) Calls proc~~bw_tg_cft3_z~~CallsGraph proc~bw_tg_cft3_z bw_tg_cft3_z proc~cft_1z cft_1z proc~bw_tg_cft3_z->proc~cft_1z none~check_dims check_dims proc~cft_1z->none~check_dims fftx_error__ fftx_error__ proc~cft_1z->fftx_error__ none~lookup lookup proc~cft_1z->none~lookup dfticomputebackward dfticomputebackward proc~cft_1z->dfticomputebackward stop_clock stop_clock proc~cft_1z->stop_clock none~init_dfti init_dfti proc~cft_1z->none~init_dfti start_clock start_clock proc~cft_1z->start_clock dfticomputeforward dfticomputeforward proc~cft_1z->dfticomputeforward none~check_dims->fftx_error__ none~init_dfti->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/bw_tg_cft3_z.html","title":"bw_tg_cft3_z â€“ FFTXlib"},{"text":"public subroutine fw_tg_cft3_scatter(f, dfft, aux) Uses: scatter_mod fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: aux (:) Calls proc~~fw_tg_cft3_scatter~~CallsGraph proc~fw_tg_cft3_scatter fw_tg_cft3_scatter proc~fft_scatter fft_scatter proc~fw_tg_cft3_scatter->proc~fft_scatter fftx_error__ fftx_error__ proc~fft_scatter->fftx_error__ start_clock start_clock proc~fft_scatter->start_clock stop_clock stop_clock proc~fft_scatter->stop_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fw_tg_cft3_scatter.html","title":"fw_tg_cft3_scatter â€“ FFTXlib"},{"text":"public subroutine bw_tg_cft3_scatter(f, dfft, aux) Uses: scatter_mod fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: aux (:) Calls proc~~bw_tg_cft3_scatter~~CallsGraph proc~bw_tg_cft3_scatter bw_tg_cft3_scatter proc~fft_scatter fft_scatter proc~bw_tg_cft3_scatter->proc~fft_scatter fftx_error__ fftx_error__ proc~fft_scatter->fftx_error__ start_clock start_clock proc~fft_scatter->start_clock stop_clock stop_clock proc~fft_scatter->stop_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/bw_tg_cft3_scatter.html","title":"bw_tg_cft3_scatter â€“ FFTXlib"},{"text":"public subroutine fw_tg_cft3_xy(f, dfft) Uses: fft_scalar fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~fw_tg_cft3_xy~~CallsGraph proc~fw_tg_cft3_xy fw_tg_cft3_xy proc~cft_2xy cft_2xy proc~fw_tg_cft3_xy->proc~cft_2xy fftx_error__ fftx_error__ proc~cft_2xy->fftx_error__ dfticomputebackward dfticomputebackward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 stop_clock stop_clock proc~cft_2xy->stop_clock none~lookup~2 lookup proc~cft_2xy->none~lookup~2 start_clock start_clock proc~cft_2xy->start_clock dfticomputeforward dfticomputeforward proc~cft_2xy->dfticomputeforward dfticommitdescriptor dfticommitdescriptor none~init_dfti~2->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~2->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~2->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~2->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: planes (dfft%nr1x)","tags":"","loc":"proc/fw_tg_cft3_xy.html","title":"fw_tg_cft3_xy â€“ FFTXlib"},{"text":"public subroutine bw_tg_cft3_xy(f, dfft) Uses: fft_scalar fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~bw_tg_cft3_xy~~CallsGraph proc~bw_tg_cft3_xy bw_tg_cft3_xy proc~cft_2xy cft_2xy proc~bw_tg_cft3_xy->proc~cft_2xy fftx_error__ fftx_error__ proc~cft_2xy->fftx_error__ dfticomputebackward dfticomputebackward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 stop_clock stop_clock proc~cft_2xy->stop_clock none~lookup~2 lookup proc~cft_2xy->none~lookup~2 start_clock start_clock proc~cft_2xy->start_clock dfticomputeforward dfticomputeforward proc~cft_2xy->dfticomputeforward dfticommitdescriptor dfticommitdescriptor none~init_dfti~2->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~2->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~2->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~2->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: planes (dfft%nr1x)","tags":"","loc":"proc/bw_tg_cft3_xy.html","title":"bw_tg_cft3_xy â€“ FFTXlib"},{"text":"public subroutine pack_group_sticks(f, yf, dfft) Uses: fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(in) :: f (:) complex(kind=DP), intent(out) :: yf (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~pack_group_sticks~~CallsGraph proc~pack_group_sticks pack_group_sticks fftx_error__ fftx_error__ proc~pack_group_sticks->fftx_error__ stop_clock stop_clock proc~pack_group_sticks->stop_clock mpi_alltoallv mpi_alltoallv proc~pack_group_sticks->mpi_alltoallv start_clock start_clock proc~pack_group_sticks->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~pack_group_sticks~~CalledByGraph proc~pack_group_sticks pack_group_sticks proc~tg_cft3s tg_cft3s proc~tg_cft3s->proc~pack_group_sticks proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ierr","tags":"","loc":"proc/pack_group_sticks.html","title":"pack_group_sticks â€“ FFTXlib"},{"text":"public subroutine unpack_group_sticks(yf, f, dfft) Uses: fft_types Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(in) :: yf (:) complex(kind=DP), intent(out) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft Calls proc~~unpack_group_sticks~~CallsGraph proc~unpack_group_sticks unpack_group_sticks fftx_error__ fftx_error__ proc~unpack_group_sticks->fftx_error__ stop_clock stop_clock proc~unpack_group_sticks->stop_clock mpi_alltoallv mpi_alltoallv proc~unpack_group_sticks->mpi_alltoallv start_clock start_clock proc~unpack_group_sticks->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~unpack_group_sticks~~CalledByGraph proc~unpack_group_sticks unpack_group_sticks proc~tg_cft3s tg_cft3s proc~tg_cft3s->proc~unpack_group_sticks proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ierr","tags":"","loc":"proc/unpack_group_sticks.html","title":"unpack_group_sticks â€“ FFTXlib"},{"text":"public subroutine tg_gather(dffts, v, tg_v) Uses: fft_types Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dffts real(kind=DP) :: v (:) real(kind=DP) :: tg_v (:) Calls proc~~tg_gather~~CallsGraph proc~tg_gather tg_gather fftx_error__ fftx_error__ proc~tg_gather->fftx_error__ mpi_allgatherv mpi_allgatherv proc~tg_gather->mpi_allgatherv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: nsiz integer, public :: i integer, public :: ierr integer, public :: nsiz_tg integer, public :: recv_cnt (dffts%nogrp) integer, public :: recv_displ (dffts%nogrp)","tags":"","loc":"proc/tg_gather.html","title":"tg_gather â€“ FFTXlib"},{"text":"public subroutine tg_cgather(dffts, v, tg_v) Uses: fft_types Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dffts complex(kind=DP) :: v (:) complex(kind=DP) :: tg_v (:) Calls proc~~tg_cgather~~CallsGraph proc~tg_cgather tg_cgather fftx_error__ fftx_error__ proc~tg_cgather->fftx_error__ mpi_allgatherv mpi_allgatherv proc~tg_cgather->mpi_allgatherv Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: nsiz integer, public :: i integer, public :: ierr integer, public :: nsiz_tg integer, public :: recv_cnt (dffts%nogrp) integer, public :: recv_displ (dffts%nogrp)","tags":"","loc":"proc/tg_cgather.html","title":"tg_cgather â€“ FFTXlib"},{"text":"public subroutine cft_1z(c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) Calls proc~~cft_1z~~CallsGraph proc~cft_1z cft_1z none~check_dims check_dims proc~cft_1z->none~check_dims fftx_error__ fftx_error__ proc~cft_1z->fftx_error__ none~lookup lookup proc~cft_1z->none~lookup dfticomputebackward dfticomputebackward proc~cft_1z->dfticomputebackward stop_clock stop_clock proc~cft_1z->stop_clock none~init_dfti init_dfti proc~cft_1z->none~init_dfti start_clock start_clock proc~cft_1z->start_clock dfticomputeforward dfticomputeforward proc~cft_1z->dfticomputeforward none~check_dims->fftx_error__ none~init_dfti->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cft_1z~~CalledByGraph proc~cft_1z cft_1z proc~fw_tg_cft3_z fw_tg_cft3_z proc~fw_tg_cft3_z->proc~cft_1z proc~tg_cft3s tg_cft3s proc~tg_cft3s->proc~cft_1z proc~bw_tg_cft3_z bw_tg_cft3_z proc~bw_tg_cft3_z->proc~cft_1z proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=DP), public :: tscale integer, public :: i integer, public :: err integer, public :: idir integer, public :: ip integer, public :: void integer, public, SAVE :: zdims (3,ndims) = -1 integer, public, SAVE :: icurrent = 1 logical, public :: found integer, public :: tid integer, public :: offset integer, public :: ldz_t type( dfti_descriptor_array ), public, SAVE :: hand (ndims) logical, public, SAVE :: dfti_first = .TRUE. integer, public :: dfti_status = 0 Subroutines subroutine check_dims() Arguments None subroutine lookup() Arguments None subroutine init_dfti() Arguments None","tags":"","loc":"proc/cft_1z.html","title":"cft_1z â€“ FFTXlib"},{"text":"public subroutine cft_2xy(r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) Calls proc~~cft_2xy~~CallsGraph proc~cft_2xy cft_2xy fftx_error__ fftx_error__ proc~cft_2xy->fftx_error__ dfticomputebackward dfticomputebackward proc~cft_2xy->dfticomputebackward none~init_dfti~2 init_dfti proc~cft_2xy->none~init_dfti~2 stop_clock stop_clock proc~cft_2xy->stop_clock none~lookup~2 lookup proc~cft_2xy->none~lookup~2 start_clock start_clock proc~cft_2xy->start_clock dfticomputeforward dfticomputeforward proc~cft_2xy->dfticomputeforward dfticommitdescriptor dfticommitdescriptor none~init_dfti~2->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~2->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~2->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~2->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cft_2xy~~CalledByGraph proc~cft_2xy cft_2xy proc~fw_tg_cft3_xy fw_tg_cft3_xy proc~fw_tg_cft3_xy->proc~cft_2xy proc~tg_cft3s tg_cft3s proc~tg_cft3s->proc~cft_2xy proc~bw_tg_cft3_xy bw_tg_cft3_xy proc~bw_tg_cft3_xy->proc~cft_2xy proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: kk integer, public :: void real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (4,ndims) = -1 logical, public :: dofft (nfftx) logical, public :: found integer, public, parameter :: stdout = 6 integer, public :: offset integer, public :: nx_t integer, public :: ny_t integer, public :: nzl_t integer, public :: ldx_t integer, public :: ldy_t integer, public :: itid integer, public :: mytid integer, public :: ntids type( dfti_descriptor_array ), public, SAVE :: hand (ndims) logical, public, SAVE :: dfti_first = .TRUE. integer, public :: dfti_status = 0 Subroutines subroutine check_dims() Arguments None subroutine lookup() Arguments None subroutine init_dfti() Arguments None","tags":"","loc":"proc/cft_2xy.html","title":"cft_2xy â€“ FFTXlib"},{"text":"public subroutine cfft3d(f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign Calls proc~~cfft3d~~CallsGraph proc~cfft3d cfft3d dfticomputeforward dfticomputeforward proc~cfft3d->dfticomputeforward none~lookup~3 lookup proc~cfft3d->none~lookup~3 dfticomputebackward dfticomputebackward proc~cfft3d->dfticomputebackward none~check_dims~2 check_dims proc~cfft3d->none~check_dims~2 none~init_dfti~3 init_dfti proc~cfft3d->none~init_dfti~3 fftx_error__ fftx_error__ none~check_dims~2->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti~3->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~3->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~3->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~3->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cfft3d~~CalledByGraph proc~cfft3d cfft3d proc~cfft3ds cfft3ds proc~cfft3ds->proc~cfft3d proc~invfft_b invfft_b proc~invfft_b->proc~cfft3d proc~invfft_x invfft_x proc~invfft_x->proc~cfft3d proc~invfft_x->proc~cfft3ds proc~fwfft_x fwfft_x proc~fwfft_x->proc~cfft3d proc~fwfft_x->proc~cfft3ds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 type( dfti_descriptor_array ), public, SAVE :: hand (ndims) logical, public, SAVE :: dfti_first = .TRUE. integer, public :: dfti_status = 0 Subroutines subroutine check_dims() Arguments None subroutine lookup() Arguments None subroutine init_dfti() Arguments None","tags":"","loc":"proc/cfft3d.html","title":"cfft3d â€“ FFTXlib"},{"text":"public subroutine cfft3ds(f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:) Calls proc~~cfft3ds~~CallsGraph proc~cfft3ds cfft3ds proc~cfft3d cfft3d proc~cfft3ds->proc~cfft3d dfticomputeforward dfticomputeforward proc~cfft3d->dfticomputeforward none~lookup~3 lookup proc~cfft3d->none~lookup~3 dfticomputebackward dfticomputebackward proc~cfft3d->dfticomputebackward none~check_dims~2 check_dims proc~cfft3d->none~check_dims~2 none~init_dfti~3 init_dfti proc~cfft3d->none~init_dfti~3 fftx_error__ fftx_error__ none~check_dims~2->fftx_error__ dfticommitdescriptor dfticommitdescriptor none~init_dfti~3->dfticommitdescriptor dftisetvalue dftisetvalue none~init_dfti~3->dftisetvalue dftifreedescriptor dftifreedescriptor none~init_dfti~3->dftifreedescriptor dfticreatedescriptor dfticreatedescriptor none~init_dfti~3->dfticreatedescriptor Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cfft3ds~~CalledByGraph proc~cfft3ds cfft3ds proc~invfft_x invfft_x proc~invfft_x->proc~cfft3ds proc~fwfft_x fwfft_x proc~fwfft_x->proc~cfft3ds Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cfft3ds.html","title":"cfft3ds â€“ FFTXlib"},{"text":"public subroutine cft_1z(c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) Calls proc~~cft_1z~2~~CallsGraph proc~cft_1z~2 cft_1z fftx_error__ fftx_error__ proc~cft_1z~2->fftx_error__ stop_clock stop_clock proc~cft_1z~2->stop_clock start_clock start_clock proc~cft_1z~2->start_clock dcft dcft proc~cft_1z~2->dcft Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=DP), public :: tscale integer, public :: i integer, public :: err integer, public :: idir integer, public :: ip integer, public :: void integer, public, SAVE :: zdims (3,ndims) = -1 integer, public, SAVE :: icurrent = 1 logical, public :: done integer, public :: OMP_GET_THREAD_NUM integer, public :: tid integer, public :: offset integer, public :: ldz_t integer, public, parameter :: ltabl = 20000+3*nfftx real(kind=DP), public, SAVE :: fw_tablez (ltabl,ndims) real(kind=DP), public, SAVE :: bw_tablez (ltabl,ndims)","tags":"","loc":"proc/cft_1z~2.html","title":"cft_1z â€“ FFTXlib"},{"text":"public subroutine cft_2xy(r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) Calls proc~~cft_2xy~2~~CallsGraph proc~cft_2xy~2 cft_2xy fftx_error__ fftx_error__ proc~cft_2xy~2->fftx_error__ stop_clock stop_clock proc~cft_2xy~2->stop_clock start_clock start_clock proc~cft_2xy~2->start_clock dcft dcft proc~cft_2xy~2->dcft Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: kk integer, public :: void real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (4,ndims) = -1 logical, public :: dofft (nfftx) logical, public :: done integer, public, parameter :: stdout = 6 integer, public :: offset integer, public :: nx_t integer, public :: ny_t integer, public :: nzl_t integer, public :: ldx_t integer, public :: ldy_t integer, public :: itid integer, public :: mytid integer, public :: ntids integer, public, parameter :: ltabl = 20000+3*nfftx real(kind=DP), public, SAVE :: fw_tablex (ltabl,ndims) real(kind=DP), public, SAVE :: fw_tabley (ltabl,ndims) real(kind=DP), public, SAVE :: bw_tablex (ltabl,ndims) real(kind=DP), public, SAVE :: bw_tabley (ltabl,ndims)","tags":"","loc":"proc/cft_2xy~2.html","title":"cft_2xy â€“ FFTXlib"},{"text":"public subroutine cfft3d(f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign Calls proc~~cfft3d~2~~CallsGraph proc~cfft3d~2 cfft3d fftx_error__ fftx_error__ proc~cfft3d~2->fftx_error__ dcft3 dcft3 proc~cfft3d~2->dcft3 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1","tags":"","loc":"proc/cfft3d~2.html","title":"cfft3d â€“ FFTXlib"},{"text":"public subroutine cfft3ds(f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:) Calls proc~~cfft3ds~2~~CallsGraph proc~cfft3ds~2 cfft3ds fftx_error__ fftx_error__ proc~cfft3ds~2->fftx_error__ dscal dscal proc~cfft3ds~2->dscal dcft dcft proc~cfft3ds~2->dcft Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: incx1 integer, public :: incx2 integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: ii integer, public :: jj real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 integer, public, parameter :: ltabl = 20000+3*nfftx real(kind=DP), public, SAVE :: fw_table (ltabl,3,ndims) real(kind=DP), public, SAVE :: bw_table (ltabl,3,ndims)","tags":"","loc":"proc/cfft3ds~2.html","title":"cfft3ds â€“ FFTXlib"},{"text":"public subroutine cft_1z(c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) Calls proc~~cft_1z~3~~CallsGraph proc~cft_1z~3 cft_1z bw_planz bw_planz proc~cft_1z~3->bw_planz stop_clock stop_clock proc~cft_1z~3->stop_clock fftx_error__ fftx_error__ proc~cft_1z~3->fftx_error__ none~lookup~4 lookup proc~cft_1z~3->none~lookup~4 none~init_plan init_plan proc~cft_1z~3->none~init_plan fft_z_stick_single fft_z_stick_single proc~cft_1z~3->fft_z_stick_single fw_planz fw_planz proc~cft_1z~3->fw_planz start_clock start_clock proc~cft_1z~3->start_clock fft_z_stick fft_z_stick proc~cft_1z~3->fft_z_stick none~init_plan->bw_planz none~init_plan->fw_planz create_plan_1d create_plan_1d none~init_plan->create_plan_1d destroy_plan_1d destroy_plan_1d none~init_plan->destroy_plan_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=DP), public :: tscale integer, public :: i integer, public :: err integer, public :: idir integer, public :: ip integer, public :: void integer, public, SAVE :: zdims (3,ndims) = -1 integer, public, SAVE :: icurrent = 1 logical, public :: found integer, public :: OMP_GET_THREAD_NUM integer, public :: tid integer, public :: offset integer, public :: ldz_t Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cft_1z~3.html","title":"cft_1z â€“ FFTXlib"},{"text":"public subroutine cft_2xy(r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) Calls proc~~cft_2xy~3~~CallsGraph proc~cft_2xy~3 cft_2xy zdscal zdscal proc~cft_2xy~3->zdscal fw_plan_2d fw_plan_2d proc~cft_2xy~3->fw_plan_2d omp_get_num_threads omp_get_num_threads proc~cft_2xy~3->omp_get_num_threads fft_x_stick fft_x_stick proc~cft_2xy~3->fft_x_stick fftx_error__ fftx_error__ proc~cft_2xy~3->fftx_error__ fw_plan fw_plan proc~cft_2xy~3->fw_plan start_clock start_clock proc~cft_2xy~3->start_clock bw_plan bw_plan proc~cft_2xy~3->bw_plan none~lookup~5 lookup proc~cft_2xy~3->none~lookup~5 bw_plan_2d bw_plan_2d proc~cft_2xy~3->bw_plan_2d none~init_plan~2 init_plan proc~cft_2xy~3->none~init_plan~2 stop_clock stop_clock proc~cft_2xy~3->stop_clock fftw_inplace_drv_2d fftw_inplace_drv_2d proc~cft_2xy~3->fftw_inplace_drv_2d fft_y_stick fft_y_stick proc~cft_2xy~3->fft_y_stick fft_x_stick_single fft_x_stick_single proc~cft_2xy~3->fft_x_stick_single none~init_plan~2->fw_plan_2d none~init_plan~2->fw_plan none~init_plan~2->bw_plan none~init_plan~2->bw_plan_2d destroy_plan_1d destroy_plan_1d none~init_plan~2->destroy_plan_1d create_plan_1d create_plan_1d none~init_plan~2->create_plan_1d destroy_plan_2d destroy_plan_2d none~init_plan~2->destroy_plan_2d create_plan_2d create_plan_2d none~init_plan~2->create_plan_2d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: kk integer, public :: void real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (4,ndims) = -1 logical, public :: dofft (nfftx) logical, public :: found integer, public, parameter :: stdout = 6 integer, public :: offset integer, public :: nx_t integer, public :: ny_t integer, public :: nzl_t integer, public :: ldx_t integer, public :: ldy_t integer, public :: itid integer, public :: mytid integer, public :: ntids Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cft_2xy~3.html","title":"cft_2xy â€“ FFTXlib"},{"text":"public subroutine cfft3d(f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign Calls proc~~cfft3d~3~~CallsGraph proc~cfft3d~3 cfft3d none~init_plan~3 init_plan proc~cfft3d~3->none~init_plan~3 fftw_inplace_drv_3d fftw_inplace_drv_3d proc~cfft3d~3->fftw_inplace_drv_3d zdscal zdscal proc~cfft3d~3->zdscal fftx_error__ fftx_error__ proc~cfft3d~3->fftx_error__ fw_plan fw_plan proc~cfft3d~3->fw_plan bw_plan bw_plan proc~cfft3d~3->bw_plan none~lookup~6 lookup proc~cfft3d~3->none~lookup~6 none~init_plan~3->fftx_error__ none~init_plan~3->fw_plan none~init_plan~3->bw_plan create_plan_3d create_plan_3d none~init_plan~3->create_plan_3d destroy_plan_3d destroy_plan_3d none~init_plan~3->destroy_plan_3d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cfft3d~3.html","title":"cfft3d â€“ FFTXlib"},{"text":"public subroutine cfft3ds(f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:) Calls proc~~cfft3ds~3~~CallsGraph proc~cfft3ds~3 cfft3ds fftx_error__ fftx_error__ proc~cfft3ds~3->fftx_error__ fw_plan fw_plan proc~cfft3ds~3->fw_plan dscal dscal proc~cfft3ds~3->dscal bw_plan bw_plan proc~cfft3ds~3->bw_plan fftw_inplace_drv_1d fftw_inplace_drv_1d proc~cfft3ds~3->fftw_inplace_drv_1d none~lookup~7 lookup proc~cfft3ds~3->none~lookup~7 none~init_plan~4 init_plan proc~cfft3ds~3->none~init_plan~4 none~init_plan~4->fw_plan none~init_plan~4->bw_plan create_plan_1d create_plan_1d none~init_plan~4->create_plan_1d destroy_plan_1d destroy_plan_1d none~init_plan~4->destroy_plan_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: incx1 integer, public :: incx2 integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: ii integer, public :: jj real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cfft3ds~3.html","title":"cfft3ds â€“ FFTXlib"},{"text":"public subroutine cft_1z(c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) Calls proc~~cft_1z~4~~CallsGraph proc~cft_1z~4 cft_1z none~lookup~8 lookup proc~cft_1z~4->none~lookup~8 bw_planz bw_planz proc~cft_1z~4->bw_planz fftx_error__ fftx_error__ proc~cft_1z~4->fftx_error__ none~init_plan~5 init_plan proc~cft_1z~4->none~init_plan~5 dfftw_execute_dft dfftw_execute_dft proc~cft_1z~4->dfftw_execute_dft fw_planz fw_planz proc~cft_1z~4->fw_planz start_clock start_clock proc~cft_1z~4->start_clock stop_clock stop_clock proc~cft_1z~4->stop_clock none~init_plan~5->bw_planz none~init_plan~5->fw_planz omp_get_max_threads omp_get_max_threads none~init_plan~5->omp_get_max_threads dfftw_destroy_plan dfftw_destroy_plan none~init_plan~5->dfftw_destroy_plan dfftw_cleanup_threads dfftw_cleanup_threads none~init_plan~5->dfftw_cleanup_threads dfftw_plan_many_dft dfftw_plan_many_dft none~init_plan~5->dfftw_plan_many_dft fftw_init_threads fftw_init_threads none~init_plan~5->fftw_init_threads dfftw_plan_with_nthreads dfftw_plan_with_nthreads none~init_plan~5->dfftw_plan_with_nthreads Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=DP), public :: tscale integer, public :: i integer, public :: err integer, public :: idir integer, public :: ip integer, public :: void integer, public, SAVE :: zdims (3,ndims) = -1 integer, public, SAVE :: icurrent = 1 logical, public :: done integer, public :: tid integer, public :: offset integer, public :: ldz_t Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cft_1z~4.html","title":"cft_1z â€“ FFTXlib"},{"text":"public subroutine cft_2xy(r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) Calls proc~~cft_2xy~4~~CallsGraph proc~cft_2xy~4 cft_2xy zdscal zdscal proc~cft_2xy~4->zdscal dfftw_execute_dft dfftw_execute_dft proc~cft_2xy~4->dfftw_execute_dft fftx_error__ fftx_error__ proc~cft_2xy~4->fftx_error__ fw_plan fw_plan proc~cft_2xy~4->fw_plan bw_plan bw_plan proc~cft_2xy~4->bw_plan none~lookup~9 lookup proc~cft_2xy~4->none~lookup~9 start_clock start_clock proc~cft_2xy~4->start_clock none~init_plan~6 init_plan proc~cft_2xy~4->none~init_plan~6 stop_clock stop_clock proc~cft_2xy~4->stop_clock none~init_plan~6->fw_plan none~init_plan~6->bw_plan omp_get_max_threads omp_get_max_threads none~init_plan~6->omp_get_max_threads dfftw_destroy_plan dfftw_destroy_plan none~init_plan~6->dfftw_destroy_plan r r none~init_plan~6->r dfftw_plan_many_dft dfftw_plan_many_dft none~init_plan~6->dfftw_plan_many_dft dfftw_cleanup_threads dfftw_cleanup_threads none~init_plan~6->dfftw_cleanup_threads fftw_init_threads fftw_init_threads none~init_plan~6->fftw_init_threads dfftw_plan_with_nthreads dfftw_plan_with_nthreads none~init_plan~6->dfftw_plan_with_nthreads Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: kk integer, public :: void real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (4,ndims) = -1 logical, public :: dofft (nfftx) logical, public :: done integer, public, parameter :: stdout = 6 integer, public :: offset integer, public :: nx_t integer, public :: ny_t integer, public :: nzl_t integer, public :: ldx_t integer, public :: ldy_t integer, public :: itid integer, public :: mytid integer, public :: ntids Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cft_2xy~4.html","title":"cft_2xy â€“ FFTXlib"},{"text":"public subroutine cfft3d(f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign Calls proc~~cfft3d~4~~CallsGraph proc~cfft3d~4 cfft3d zdscal zdscal proc~cfft3d~4->zdscal bw_plan bw_plan proc~cfft3d~4->bw_plan none~lookup~10 lookup proc~cfft3d~4->none~lookup~10 none~init_plan~7 init_plan proc~cfft3d~4->none~init_plan~7 fw_plan fw_plan proc~cfft3d~4->fw_plan dfftw_execute_dft dfftw_execute_dft proc~cfft3d~4->dfftw_execute_dft fftx_error__ fftx_error__ proc~cfft3d~4->fftx_error__ none~init_plan~7->bw_plan none~init_plan~7->fw_plan none~init_plan~7->fftx_error__ dfftw_destroy_plan dfftw_destroy_plan none~init_plan~7->dfftw_destroy_plan dfftw_plan_dft_3d dfftw_plan_dft_3d none~init_plan~7->dfftw_plan_dft_3d f f none~init_plan~7->f Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cfft3d~4.html","title":"cfft3d â€“ FFTXlib"},{"text":"public subroutine cfft3ds(f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:) Calls proc~~cfft3ds~4~~CallsGraph proc~cfft3ds~4 cfft3ds none~lookup~11 lookup proc~cfft3ds~4->none~lookup~11 dfftw_execute_dft dfftw_execute_dft proc~cfft3ds~4->dfftw_execute_dft none~init_plan~8 init_plan proc~cfft3ds~4->none~init_plan~8 fw_plan fw_plan proc~cfft3ds~4->fw_plan bw_plan bw_plan proc~cfft3ds~4->bw_plan fftx_error__ fftx_error__ proc~cfft3ds~4->fftx_error__ dscal dscal proc~cfft3ds~4->dscal none~init_plan~8->fw_plan none~init_plan~8->bw_plan dfftw_plan_many_dft dfftw_plan_many_dft none~init_plan~8->dfftw_plan_many_dft f f none~init_plan~8->f dfftw_destroy_plan dfftw_destroy_plan none~init_plan~8->dfftw_destroy_plan Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: incx1 integer, public :: incx2 integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: ii integer, public :: jj real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 Subroutines subroutine lookup() Arguments None subroutine init_plan() Arguments None","tags":"","loc":"proc/cfft3ds~4.html","title":"cfft3ds â€“ FFTXlib"},{"text":"public subroutine cft_1z(c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) Calls proc~~cft_1z~5~~CallsGraph proc~cft_1z~5 cft_1z fftx_error__ fftx_error__ proc~cft_1z~5->fftx_error__ stop_clock stop_clock proc~cft_1z~5->stop_clock zzfftm zzfftm proc~cft_1z~5->zzfftm start_clock start_clock proc~cft_1z~5->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=DP), public :: tscale integer, public :: i integer, public :: err integer, public :: idir integer, public :: ip integer, public :: void integer, public, SAVE :: zdims (3,ndims) = -1 integer, public, SAVE :: icurrent = 1 logical, public :: done integer, public :: tid integer, public :: offset integer, public :: ldz_t integer, public, parameter :: ltabl = 2*nfftx+64 real(kind=DP), public, SAVE :: tablez (ltabl,ndims) real(kind=DP), public :: work (4*nz*nsl) complex(kind=DP), public :: DUMMY integer, public, SAVE :: isys = 1","tags":"","loc":"proc/cft_1z~5.html","title":"cft_1z â€“ FFTXlib"},{"text":"public subroutine cft_2xy(r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) Calls proc~~cft_2xy~5~~CallsGraph proc~cft_2xy~5 cft_2xy fftx_error__ fftx_error__ proc~cft_2xy~5->fftx_error__ stop_clock stop_clock proc~cft_2xy~5->stop_clock zzfftm zzfftm proc~cft_2xy~5->zzfftm start_clock start_clock proc~cft_2xy~5->start_clock zzfft zzfft proc~cft_2xy~5->zzfft Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: kk integer, public :: void real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (4,ndims) = -1 logical, public :: dofft (nfftx) logical, public :: done integer, public, parameter :: stdout = 6 integer, public :: offset integer, public :: nx_t integer, public :: ny_t integer, public :: nzl_t integer, public :: ldx_t integer, public :: ldy_t integer, public :: itid integer, public :: mytid integer, public :: ntids integer, public, parameter :: ltabl = 2*nfftx+64 real(kind=DP), public, SAVE :: tablex (ltabl,ndims) real(kind=DP), public, SAVE :: tabley (ltabl,ndims) real(kind=DP), public :: work (4*nx*ny) complex(kind=DP), public :: XY (ldx*ny) complex(kind=DP), public :: DUMMY integer, public, SAVE :: isys = 1","tags":"","loc":"proc/cft_2xy~5.html","title":"cft_2xy â€“ FFTXlib"},{"text":"public subroutine cfft3d(f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign Calls proc~~cfft3d~5~~CallsGraph proc~cfft3d~5 cfft3d zfc3bf zfc3bf proc~cfft3d~5->zfc3bf zdscal zdscal proc~cfft3d~5->zdscal fftx_error__ fftx_error__ proc~cfft3d~5->fftx_error__ zfc3cl zfc3cl proc~cfft3d~5->zfc3cl hfc3fb hfc3fb proc~cfft3d~5->hfc3fb zfc3fb zfc3fb proc~cfft3d~5->zfc3fb zzfft3d zzfft3d proc~cfft3d~5->zzfft3d hfc3bf hfc3bf proc~cfft3d~5->hfc3bf Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cfft3d~5~~CalledByGraph proc~cfft3d~5 cfft3d proc~cfft3ds~5 cfft3ds proc~cfft3ds~5->proc~cfft3d~5 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1 integer, public, parameter :: ltabl = 60 integer, public, parameter :: lwork = 195+6*nfftx integer, public, SAVE :: iw0 (ltabl,ndims) integer, public :: k_off integer, public :: kj_offset real(kind=DP), public, SAVE :: auxp (lwork,ndims) complex(kind=DP), public, DIMENSION(:), ALLOCATABLE :: cw2 complex(kind=DP), public :: f_out (size(f)) integer, public :: nbtasks","tags":"","loc":"proc/cfft3d~5.html","title":"cfft3d â€“ FFTXlib"},{"text":"public subroutine cfft3ds(f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:) Calls proc~~cfft3ds~5~~CallsGraph proc~cfft3ds~5 cfft3ds proc~cfft3d~5 cfft3d proc~cfft3ds~5->proc~cfft3d~5 zfc3bf zfc3bf proc~cfft3d~5->zfc3bf zdscal zdscal proc~cfft3d~5->zdscal fftx_error__ fftx_error__ proc~cfft3d~5->fftx_error__ zfc3cl zfc3cl proc~cfft3d~5->zfc3cl hfc3fb hfc3fb proc~cfft3d~5->hfc3fb zfc3fb zfc3fb proc~cfft3d~5->zfc3fb zzfft3d zzfft3d proc~cfft3d~5->zzfft3d hfc3bf hfc3bf proc~cfft3d~5->hfc3bf Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m integer, public :: incx1 integer, public :: incx2 integer, public :: i integer, public :: k integer, public :: j integer, public :: err integer, public :: idir integer, public :: ip integer, public :: ii integer, public :: jj real(kind=DP), public :: tscale integer, public, SAVE :: icurrent = 1 integer, public, SAVE :: dims (3,ndims) = -1","tags":"","loc":"proc/cfft3ds~5.html","title":"cfft3ds â€“ FFTXlib"},{"text":"public subroutine cft_b(f, nx, ny, nz, ldx, ldy, ldz, imin3, imax3, sgn) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: f (:) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: imin3 integer :: imax3 integer :: sgn Calls proc~~cft_b~~CallsGraph proc~cft_b cft_b bw_planz bw_planz proc~cft_b->bw_planz bw_planx bw_planx proc~cft_b->bw_planx fftx_error__ fftx_error__ proc~cft_b->fftx_error__ bw_planxy bw_planxy proc~cft_b->bw_planxy fftw_inplace_drv_1d fftw_inplace_drv_1d proc~cft_b->fftw_inplace_drv_1d destroy_plan_1d destroy_plan_1d proc~cft_b->destroy_plan_1d create_plan_1d create_plan_1d proc~cft_b->create_plan_1d bw_plany bw_plany proc~cft_b->bw_plany destroy_plan_2d destroy_plan_2d proc~cft_b->destroy_plan_2d create_plan_2d create_plan_2d proc~cft_b->create_plan_2d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cft_b~~CalledByGraph proc~cft_b cft_b proc~invfft_b invfft_b proc~invfft_b->proc~cft_b Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: isign integer, public :: naux integer, public :: ibid integer, public :: nplanes integer, public :: nstart integer, public :: k real(kind=DP), public :: tscale integer, public :: ip integer, public :: i integer, public, save :: icurrent = 1 integer, public, save :: dims (4,ndims) = -1","tags":"","loc":"proc/cft_b.html","title":"cft_b â€“ FFTXlib"},{"text":"public subroutine cft_b_omp_init(nx, ny, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz Calls proc~~cft_b_omp_init~~CallsGraph proc~cft_b_omp_init cft_b_omp_init create_plan_1d create_plan_1d proc~cft_b_omp_init->create_plan_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/cft_b_omp_init.html","title":"cft_b_omp_init â€“ FFTXlib"},{"text":"public subroutine cft_b_omp(f, nx, ny, nz, ldx, ldy, ldz, imin3, imax3, sgn) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: imin3 integer, intent(in) :: imax3 integer, intent(in) :: sgn Calls proc~~cft_b_omp~~CallsGraph proc~cft_b_omp cft_b_omp fftx_error__ fftx_error__ proc~cft_b_omp->fftx_error__ fftw_inplace_drv_1d fftw_inplace_drv_1d proc~cft_b_omp->fftw_inplace_drv_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~cft_b_omp~~CalledByGraph proc~cft_b_omp cft_b_omp proc~invfft_b invfft_b proc~invfft_b->proc~cft_b_omp Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, SAVE :: k","tags":"","loc":"proc/cft_b_omp.html","title":"cft_b_omp â€“ FFTXlib"},{"text":"public function good_fft_dimension(n) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: nx real(kind=DP), public :: log2n","tags":"","loc":"proc/good_fft_dimension.html","title":"good_fft_dimension â€“ FFTXlib"},{"text":"public function allowed(nr) Arguments Type Intent Optional Attributes Name integer :: nr Return Value logical Calls proc~~allowed~~CallsGraph proc~allowed allowed fftx_error__ fftx_error__ proc~allowed->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~allowed~~CalledByGraph proc~allowed allowed proc~good_fft_order good_fft_order proc~good_fft_order->proc~allowed Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: pwr (5) integer, public :: mr integer, public :: i integer, public :: fac integer, public :: p integer, public :: maxpwr integer, public :: factors (5) = (/2,3,5,7,11/)","tags":"","loc":"proc/allowed.html","title":"allowed â€“ FFTXlib"},{"text":"public function good_fft_order(nr, np) Uses: fft_param Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in), optional :: np Return Value integer Calls proc~~good_fft_order~~CallsGraph proc~good_fft_order good_fft_order proc~allowed allowed proc~good_fft_order->proc~allowed fftx_error__ fftx_error__ proc~good_fft_order->fftx_error__ proc~allowed->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: new","tags":"","loc":"proc/good_fft_order.html","title":"good_fft_order â€“ FFTXlib"},{"text":"public subroutine fft_dlay_allocate(desc, mype, root, nproc, comm, nogrp, nx, ny) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp integer, intent(in) :: nx integer, intent(in) :: ny Calls proc~~fft_dlay_allocate~~CallsGraph proc~fft_dlay_allocate fft_dlay_allocate fftx_error__ fftx_error__ proc~fft_dlay_allocate->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fft_dlay_allocate~~CalledByGraph proc~fft_dlay_allocate fft_dlay_allocate proc~pstickset pstickset proc~pstickset->proc~fft_dlay_allocate proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~fft_dlay_allocate Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fft_dlay_allocate.html","title":"fft_dlay_allocate â€“ FFTXlib"},{"text":"public subroutine fft_dlay_deallocate(desc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc","tags":"","loc":"proc/fft_dlay_deallocate.html","title":"fft_dlay_deallocate â€“ FFTXlib"},{"text":"public subroutine fft_box_allocate(desc, mype, root, nproc, comm, nat) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nat","tags":"","loc":"proc/fft_box_allocate.html","title":"fft_box_allocate â€“ FFTXlib"},{"text":"public subroutine fft_box_deallocate(desc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc","tags":"","loc":"proc/fft_box_deallocate.html","title":"fft_box_deallocate â€“ FFTXlib"},{"text":"public subroutine fft_dlay_set(desc, tk, nst, nr1, nr2, nr3, nr1x, nr2x, nr3x, ub, lb, idx, in1, in2, ncp, ncpw, ngp, ngpw, st, stw) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc logical, intent(in) :: tk integer, intent(in) :: nst integer, intent(in) :: nr1 integer, intent(in) :: nr2 integer, intent(in) :: nr3 integer, intent(in) :: nr1x integer, intent(in) :: nr2x integer, intent(in) :: nr3x integer, intent(in) :: ub (3) integer, intent(in) :: lb (3) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ncp (:) integer, intent(in) :: ncpw (:) integer, intent(in) :: ngp (:) integer, intent(in) :: ngpw (:) integer, intent(in) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: stw (lb(1):ub(1),lb(2):ub(2)) Calls proc~~fft_dlay_set~~CallsGraph proc~fft_dlay_set fft_dlay_set fftx_error__ fftx_error__ proc~fft_dlay_set->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fft_dlay_set~~CalledByGraph proc~fft_dlay_set fft_dlay_set proc~pstickset pstickset proc~pstickset->proc~fft_dlay_set proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~fft_dlay_set Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: npp (desc%nproc) integer, public :: n3 (desc%nproc) integer, public :: nsp (desc%nproc) integer, public :: np integer, public :: nq integer, public :: i integer, public :: is integer, public :: iss integer, public :: i1 integer, public :: i2 integer, public :: m1 integer, public :: m2 integer, public :: n1 integer, public :: n2 integer, public :: ip integer, public :: ncpx integer, public :: nppx integer, public :: sm","tags":"","loc":"proc/fft_dlay_set.html","title":"fft_dlay_set â€“ FFTXlib"},{"text":"public subroutine fft_box_set(desc, nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, nat, irb, npp, ipp) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: nr1b integer, intent(in) :: nr2b integer, intent(in) :: nr3b integer, intent(in) :: nr1bx integer, intent(in) :: nr2bx integer, intent(in) :: nr3bx integer, intent(in) :: nat integer, intent(in) :: irb (:,:) integer, intent(in) :: npp (:) integer, intent(in) :: ipp (:) Calls proc~~fft_box_set~~CallsGraph proc~fft_box_set fft_box_set fftx_error__ fftx_error__ proc~fft_box_set->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: ir3 integer, public :: ibig3 integer, public :: irb3 integer, public :: imin3 integer, public :: imax3 integer, public :: nr3 integer, public :: isa","tags":"","loc":"proc/fft_box_set.html","title":"fft_box_set â€“ FFTXlib"},{"text":"public subroutine fft_dlay_scalar(desc, ub, lb, nr1, nr2, nr3, nr1x, nr2x, nr3x, stw) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer :: nr1 integer :: nr2 integer :: nr3 integer :: nr1x integer :: nr2x integer :: nr3x integer, intent(in) :: stw (lb(2):ub(2),lb(3):ub(3)) Calls proc~~fft_dlay_scalar~~CallsGraph proc~fft_dlay_scalar fft_dlay_scalar fftx_error__ fftx_error__ proc~fft_dlay_scalar->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fft_dlay_scalar~~CalledByGraph proc~fft_dlay_scalar fft_dlay_scalar proc~pstickset pstickset proc~pstickset->proc~fft_dlay_scalar proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~fft_dlay_scalar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: m1 integer, public :: m2 integer, public :: i2 integer, public :: i3","tags":"","loc":"proc/fft_dlay_scalar.html","title":"fft_dlay_scalar â€“ FFTXlib"},{"text":"public subroutine fft_scatter(dfft, f_in, nr3x, nxx_, f_aux, ncp_, npp_, isgn, use_tg) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_in (nxx_) integer, intent(in) :: nr3x integer, intent(in) :: nxx_ complex(kind=DP), intent(inout) :: f_aux (nxx_) integer, intent(in) :: ncp_ (:) integer, intent(in) :: npp_ (:) integer, intent(in) :: isgn logical, intent(in), optional :: use_tg Description f_in = 0.0_DP f_in = 0.0_DP Calls proc~~fft_scatter~~CallsGraph proc~fft_scatter fft_scatter fftx_error__ fftx_error__ proc~fft_scatter->fftx_error__ start_clock start_clock proc~fft_scatter->start_clock stop_clock stop_clock proc~fft_scatter->stop_clock mpi_alltoall mpi_alltoall proc~fft_scatter->mpi_alltoall Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fft_scatter~~CalledByGraph proc~fft_scatter fft_scatter none~fw_scatter fw_scatter none~fw_scatter->proc~fft_scatter proc~bw_tg_cft3_scatter bw_tg_cft3_scatter proc~bw_tg_cft3_scatter->proc~fft_scatter none~bw_scatter bw_scatter none~bw_scatter->proc~fft_scatter proc~fw_tg_cft3_scatter fw_tg_cft3_scatter proc~fw_tg_cft3_scatter->proc~fft_scatter proc~tg_cft3s tg_cft3s proc~tg_cft3s->none~fw_scatter proc~tg_cft3s->none~bw_scatter proc~invfft_x invfft_x proc~invfft_x->proc~tg_cft3s proc~fwfft_x fwfft_x proc~fwfft_x->proc~tg_cft3s Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dest integer, public :: from integer, public :: k integer, public :: offset integer, public :: proc integer, public :: ierr integer, public :: me integer, public :: nprocp integer, public :: gproc integer, public :: gcomm integer, public :: i integer, public :: kdest integer, public :: kfrom integer, public :: me_p integer, public :: nppx integer, public :: mc integer, public :: j integer, public :: npp integer, public :: nnp integer, public :: ii integer, public :: it integer, public :: ip integer, public :: ioff integer, public :: sendsiz integer, public :: ncpx integer, public :: ipp integer, public :: nblk integer, public :: nsiz logical, public :: use_tg_","tags":"","loc":"proc/fft_scatter.html","title":"fft_scatter â€“ FFTXlib"},{"text":"private subroutine gather_real_grid(dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) Calls proc~~gather_real_grid~~CallsGraph proc~gather_real_grid gather_real_grid fftx_error__ fftx_error__ proc~gather_real_grid->fftx_error__ stop_clock stop_clock proc~gather_real_grid->stop_clock mpi_gatherv mpi_gatherv proc~gather_real_grid->mpi_gatherv start_clock start_clock proc~gather_real_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gather_real_grid~~CalledByGraph proc~gather_real_grid gather_real_grid interface~gather_grid gather_grid interface~gather_grid->proc~gather_real_grid Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfft%nproc-1) integer, public :: recvcount (0:dfft%nproc-1)","tags":"","loc":"proc/gather_real_grid.html","title":"gather_real_grid â€“ FFTXlib"},{"text":"private subroutine gather_complex_grid(dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) Calls proc~~gather_complex_grid~~CallsGraph proc~gather_complex_grid gather_complex_grid fftx_error__ fftx_error__ proc~gather_complex_grid->fftx_error__ stop_clock stop_clock proc~gather_complex_grid->stop_clock mpi_gatherv mpi_gatherv proc~gather_complex_grid->mpi_gatherv start_clock start_clock proc~gather_complex_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gather_complex_grid~~CalledByGraph proc~gather_complex_grid gather_complex_grid interface~gather_grid gather_grid interface~gather_grid->proc~gather_complex_grid Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfft%nproc-1) integer, public :: recvcount (0:dfft%nproc-1)","tags":"","loc":"proc/gather_complex_grid.html","title":"gather_complex_grid â€“ FFTXlib"},{"text":"private subroutine scatter_real_grid(dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) Calls proc~~scatter_real_grid~~CallsGraph proc~scatter_real_grid scatter_real_grid fftx_error__ fftx_error__ proc~scatter_real_grid->fftx_error__ mpi_scatterv mpi_scatterv proc~scatter_real_grid->mpi_scatterv stop_clock stop_clock proc~scatter_real_grid->stop_clock start_clock start_clock proc~scatter_real_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~scatter_real_grid~~CalledByGraph proc~scatter_real_grid scatter_real_grid interface~scatter_grid scatter_grid interface~scatter_grid->proc~scatter_real_grid Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfft%nproc-1) integer, public :: sendcount (0:dfft%nproc-1)","tags":"","loc":"proc/scatter_real_grid.html","title":"scatter_real_grid â€“ FFTXlib"},{"text":"private subroutine scatter_complex_grid(dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) Calls proc~~scatter_complex_grid~~CallsGraph proc~scatter_complex_grid scatter_complex_grid fftx_error__ fftx_error__ proc~scatter_complex_grid->fftx_error__ mpi_scatterv mpi_scatterv proc~scatter_complex_grid->mpi_scatterv stop_clock stop_clock proc~scatter_complex_grid->stop_clock start_clock start_clock proc~scatter_complex_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~scatter_complex_grid~~CalledByGraph proc~scatter_complex_grid scatter_complex_grid interface~scatter_grid scatter_grid interface~scatter_grid->proc~scatter_complex_grid Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfft%nproc-1) integer, public :: sendcount (0:dfft%nproc-1)","tags":"","loc":"proc/scatter_complex_grid.html","title":"scatter_complex_grid â€“ FFTXlib"},{"text":"public subroutine cgather_sym(dfftp, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (:) complex(kind=DP) :: f_out (:) Calls proc~~cgather_sym~~CallsGraph proc~cgather_sym cgather_sym fftx_error__ fftx_error__ proc~cgather_sym->fftx_error__ start_clock start_clock proc~cgather_sym->start_clock stop_clock stop_clock proc~cgather_sym->stop_clock mpi_allgatherv mpi_allgatherv proc~cgather_sym->mpi_allgatherv mpi_barrier mpi_barrier proc~cgather_sym->mpi_barrier Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfftp%nproc-1) integer, public :: recvcount (0:dfftp%nproc-1)","tags":"","loc":"proc/cgather_sym.html","title":"cgather_sym â€“ FFTXlib"},{"text":"public subroutine cgather_sym_many(dfftp, f_in, f_out, nbnd, nbnd_proc, start_nbnd_proc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (dfftp%nnr,nbnd) complex(kind=DP) :: f_out (dfftp%nnp*dfftp%nr3x,nbnd_proc(dfftp%mype+1)) integer :: nbnd integer :: nbnd_proc (dfftp%nproc) integer :: start_nbnd_proc (dfftp%nproc) Calls proc~~cgather_sym_many~~CallsGraph proc~cgather_sym_many cgather_sym_many fftx_error__ fftx_error__ proc~cgather_sym_many->fftx_error__ start_clock start_clock proc~cgather_sym_many->start_clock stop_clock stop_clock proc~cgather_sym_many->stop_clock mpi_gatherv mpi_gatherv proc~cgather_sym_many->mpi_gatherv mpi_barrier mpi_barrier proc~cgather_sym_many->mpi_barrier Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: ibnd integer, public :: jbnd integer, public :: displs (0:dfftp%nproc-1) integer, public :: recvcount (0:dfftp%nproc-1)","tags":"","loc":"proc/cgather_sym_many.html","title":"cgather_sym_many â€“ FFTXlib"},{"text":"public subroutine cscatter_sym_many(dfftp, f_in, f_out, target_ibnd, nbnd, nbnd_proc, start_nbnd_proc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (dfftp%nnp*dfftp%nr3x,nbnd_proc(dfftp%mype+1)) complex(kind=DP) :: f_out (dfftp%nnr) integer :: target_ibnd integer :: nbnd integer :: nbnd_proc (dfftp%nproc) integer :: start_nbnd_proc (dfftp%nproc) Calls proc~~cscatter_sym_many~~CallsGraph proc~cscatter_sym_many cscatter_sym_many fftx_error__ fftx_error__ proc~cscatter_sym_many->fftx_error__ start_clock start_clock proc~cscatter_sym_many->start_clock mpi_scatterv mpi_scatterv proc~cscatter_sym_many->mpi_scatterv stop_clock stop_clock proc~cscatter_sym_many->stop_clock mpi_barrier mpi_barrier proc~cscatter_sym_many->mpi_barrier Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: proc integer, public :: info integer, public :: displs (0:dfftp%nproc-1) integer, public :: sendcount (0:dfftp%nproc-1) integer, public :: ibnd integer, public :: jbnd","tags":"","loc":"proc/cscatter_sym_many.html","title":"cscatter_sym_many â€“ FFTXlib"},{"text":"public interface gather_grid Calls interface~~gather_grid~~CallsGraph interface~gather_grid gather_grid proc~gather_real_grid gather_real_grid interface~gather_grid->proc~gather_real_grid proc~gather_complex_grid gather_complex_grid interface~gather_grid->proc~gather_complex_grid fftx_error__ fftx_error__ proc~gather_real_grid->fftx_error__ stop_clock stop_clock proc~gather_real_grid->stop_clock mpi_gatherv mpi_gatherv proc~gather_real_grid->mpi_gatherv start_clock start_clock proc~gather_real_grid->start_clock proc~gather_complex_grid->fftx_error__ proc~gather_complex_grid->stop_clock proc~gather_complex_grid->mpi_gatherv proc~gather_complex_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine gather_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine gather_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:)","tags":"","loc":"interface/gather_grid.html","title":"gather_grid â€“ FFTXlib"},{"text":"public interface scatter_grid Calls interface~~scatter_grid~~CallsGraph interface~scatter_grid scatter_grid proc~scatter_real_grid scatter_real_grid interface~scatter_grid->proc~scatter_real_grid proc~scatter_complex_grid scatter_complex_grid interface~scatter_grid->proc~scatter_complex_grid fftx_error__ fftx_error__ proc~scatter_real_grid->fftx_error__ mpi_scatterv mpi_scatterv proc~scatter_real_grid->mpi_scatterv stop_clock stop_clock proc~scatter_real_grid->stop_clock start_clock start_clock proc~scatter_real_grid->start_clock proc~scatter_complex_grid->fftx_error__ proc~scatter_complex_grid->mpi_scatterv proc~scatter_complex_grid->stop_clock proc~scatter_complex_grid->start_clock Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine scatter_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine scatter_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:)","tags":"","loc":"interface/scatter_grid.html","title":"scatter_grid â€“ FFTXlib"},{"text":"public subroutine sticks_maps(tk, ub, lb, b1, b2, b3, gcut, gcutw, gcuts, st, stw, sts, me, nproc, comm) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) real(kind=DP), intent(in) :: b1 (:) real(kind=DP), intent(in) :: b2 (:) real(kind=DP), intent(in) :: b3 (:) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gcutw real(kind=DP), intent(in) :: gcuts integer, intent(out) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: sts (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: me integer, intent(in) :: nproc integer, intent(in) :: comm Description ! TO REMOVE BEFORE COMMIT INTO SVN !!! ! TO REMOVE BEFORE COMMIT INTO SVN !!! Calls proc~~sticks_maps~~CallsGraph proc~sticks_maps sticks_maps mpi_allreduce mpi_allreduce proc~sticks_maps->mpi_allreduce Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~sticks_maps~~CalledByGraph proc~sticks_maps sticks_maps proc~pstickset pstickset proc~pstickset->proc~sticks_maps proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_maps Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: kip integer, public :: ierr real(kind=DP), public :: gsq","tags":"","loc":"proc/sticks_maps.html","title":"sticks_maps â€“ FFTXlib"},{"text":"public subroutine sticks_maps_scalar(lgamma, ub, lb, b1, b2, b3, gcutm, gkcut, gcutms, stw, ngm, ngms) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lgamma integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) real(kind=DP), intent(in) :: b1 (:) real(kind=DP), intent(in) :: b2 (:) real(kind=DP), intent(in) :: b3 (:) real(kind=DP), intent(in) :: gcutm real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcutms integer, intent(out) :: stw (lb(2):ub(2),lb(3):ub(3)) integer, intent(out) :: ngm integer, intent(out) :: ngms Called By proc~~sticks_maps_scalar~~CalledByGraph proc~sticks_maps_scalar sticks_maps_scalar proc~pstickset pstickset proc~pstickset->proc~sticks_maps_scalar proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_maps_scalar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i1 integer, public :: i2 integer, public :: i3 integer, public :: n1 integer, public :: n2 integer, public :: n3 real(kind=DP), public :: amod","tags":"","loc":"proc/sticks_maps_scalar.html","title":"sticks_maps_scalar â€“ FFTXlib"},{"text":"public subroutine sticks_sort(ngc, ngcw, ngcs, nct, idx, nproc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: idx (:) integer, intent(in) :: nproc Description ! TO REMOVE BEFORE COMMIT INTO SVN !!!\n! TO REMOVE BEFORE COMMIT INTO SVN !!! Calls proc~~sticks_sort~~CallsGraph proc~sticks_sort sticks_sort hpsort hpsort proc~sticks_sort->hpsort Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~sticks_sort~~CalledByGraph proc~sticks_sort sticks_sort proc~pstickset pstickset proc~pstickset->proc~sticks_sort proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_sort Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: mc integer, public :: nr3x integer, public :: ic real(kind=DP), public :: dn3 real(kind=DP), public, ALLOCATABLE :: aux (:)","tags":"","loc":"proc/sticks_sort.html","title":"sticks_sort â€“ FFTXlib"},{"text":"public subroutine sticks_countg(tk, ub, lb, st, stw, sts, in1, in2, ngc, ngcw, ngcs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: stw (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: sts (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: in1 (:) integer, intent(out) :: in2 (:) integer, intent(out) :: ngc (:) integer, intent(out) :: ngcw (:) integer, intent(out) :: ngcs (:) Calls proc~~sticks_countg~~CallsGraph proc~sticks_countg sticks_countg fftx_error__ fftx_error__ proc~sticks_countg->fftx_error__ Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~sticks_countg~~CalledByGraph proc~sticks_countg sticks_countg proc~pstickset pstickset proc~pstickset->proc~sticks_countg proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_countg Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: j1 integer, public :: j2 integer, public :: i1 integer, public :: i2 integer, public :: nct integer, public :: min_size","tags":"","loc":"proc/sticks_countg.html","title":"sticks_countg â€“ FFTXlib"},{"text":"public subroutine sticks_dist(tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(out) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc Called By proc~~sticks_dist~~CalledByGraph proc~sticks_dist sticks_dist proc~pstickset pstickset proc~pstickset->proc~sticks_dist Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: mc integer, public :: i1 integer, public :: i2 integer, public :: i integer, public :: j integer, public :: jj integer, public :: icnt","tags":"","loc":"proc/sticks_dist.html","title":"sticks_dist â€“ FFTXlib"},{"text":"public subroutine sticks_pairup(tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(inout) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(inout) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(inout) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc Called By proc~~sticks_pairup~~CalledByGraph proc~sticks_pairup sticks_pairup proc~pstickset pstickset proc~pstickset->proc~sticks_pairup proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_pairup Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: mc integer, public :: i1 integer, public :: i2 integer, public :: i integer, public :: jj","tags":"","loc":"proc/sticks_pairup.html","title":"sticks_pairup â€“ FFTXlib"},{"text":"public subroutine sticks_ordered_dist(tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(out) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc Called By proc~~sticks_ordered_dist~~CalledByGraph proc~sticks_ordered_dist sticks_ordered_dist proc~pstickset_custom pstickset_custom proc~pstickset_custom->proc~sticks_ordered_dist Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: mc integer, public :: i1 integer, public :: i2 integer, public :: i integer, public :: j integer, public :: jj","tags":"","loc":"proc/sticks_ordered_dist.html","title":"sticks_ordered_dist â€“ FFTXlib"},{"text":"public subroutine sticks_deallocate() Arguments None","tags":"","loc":"proc/sticks_deallocate.html","title":"sticks_deallocate â€“ FFTXlib"},{"text":"public subroutine pstickset(gamma_only, bg, gcut, gkcut, gcuts, dfftp, dffts, ngw, ngm, ngs, mype, root, nproc, comm, nogrp_, ionode, stdout, dfft3d) Arguments Type Intent Optional Attributes Name logical, intent(in) :: gamma_only real(kind=DP), intent(in) :: bg (3,3) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcuts type( fft_dlay_descriptor ), intent(inout) :: dfftp type( fft_dlay_descriptor ), intent(inout) :: dffts integer, intent(out) :: ngw integer, intent(out) :: ngm integer, intent(out) :: ngs integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp_ logical, intent(in) :: ionode integer, intent(in) :: stdout type( fft_dlay_descriptor ), intent(inout), optional :: dfft3d Calls proc~~pstickset~~CallsGraph proc~pstickset pstickset proc~fft_dlay_set fft_dlay_set proc~pstickset->proc~fft_dlay_set proc~fft_dlay_scalar fft_dlay_scalar proc~pstickset->proc~fft_dlay_scalar proc~sticks_dist sticks_dist proc~pstickset->proc~sticks_dist proc~task_groups_init task_groups_init proc~pstickset->proc~task_groups_init proc~fft_dlay_allocate fft_dlay_allocate proc~pstickset->proc~fft_dlay_allocate proc~sticks_pairup sticks_pairup proc~pstickset->proc~sticks_pairup fftx_error__ fftx_error__ proc~pstickset->fftx_error__ proc~sticks_sort sticks_sort proc~pstickset->proc~sticks_sort proc~sticks_countg sticks_countg proc~pstickset->proc~sticks_countg proc~sticks_maps sticks_maps proc~pstickset->proc~sticks_maps proc~sticks_maps_scalar sticks_maps_scalar proc~pstickset->proc~sticks_maps_scalar proc~fft_dlay_set->fftx_error__ proc~fft_dlay_scalar->fftx_error__ proc~task_groups_init->fftx_error__ proc~task_groups_init_first task_groups_init_first proc~task_groups_init->proc~task_groups_init_first mpi_allgather mpi_allgather proc~task_groups_init->mpi_allgather proc~fft_dlay_allocate->fftx_error__ hpsort hpsort proc~sticks_sort->hpsort proc~sticks_countg->fftx_error__ mpi_allreduce mpi_allreduce proc~sticks_maps->mpi_allreduce proc~task_groups_init_first->fftx_error__ mpi_comm_size mpi_comm_size proc~task_groups_init_first->mpi_comm_size mpi_comm_split mpi_comm_split proc~task_groups_init_first->mpi_comm_split mpi_comm_rank mpi_comm_rank proc~task_groups_init_first->mpi_comm_rank Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: tk integer, public :: ub (3) integer, public :: lb (3) integer, public, ALLOCATABLE :: stw (:,:) integer, public, ALLOCATABLE :: nstpw (:) integer, public, ALLOCATABLE :: sstpw (:) integer, public :: nstw integer, public :: nstpwx integer, public, ALLOCATABLE :: st (:,:) integer, public, ALLOCATABLE :: nstp (:) integer, public, ALLOCATABLE :: sstp (:) integer, public :: nst integer, public :: nstpx integer, public, ALLOCATABLE :: sts (:,:) integer, public, ALLOCATABLE :: nstps (:) integer, public, ALLOCATABLE :: sstps (:) integer, public :: nsts integer, public, ALLOCATABLE :: ist (:,:) integer, public :: ip integer, public :: ngm_ integer, public :: ngs_ integer, public, ALLOCATABLE :: idx (:)","tags":"","loc":"proc/pstickset.html","title":"pstickset â€“ FFTXlib"},{"text":"public subroutine pstickset_custom(gamma_only, bg, gcut, gkcut, gcuts, dfftp, dffts, ngw, ngm, ngs, mype, root, nproc, comm, nogrp_) Arguments Type Intent Optional Attributes Name logical, intent(in) :: gamma_only real(kind=DP), intent(in) :: bg (3,3) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcuts type( fft_dlay_descriptor ), intent(inout) :: dfftp type( fft_dlay_descriptor ), intent(inout) :: dffts integer, intent(inout) :: ngw integer, intent(inout) :: ngm integer, intent(inout) :: ngs integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp_ Calls proc~~pstickset_custom~~CallsGraph proc~pstickset_custom pstickset_custom proc~fft_dlay_set fft_dlay_set proc~pstickset_custom->proc~fft_dlay_set proc~fft_dlay_scalar fft_dlay_scalar proc~pstickset_custom->proc~fft_dlay_scalar proc~sticks_maps_scalar sticks_maps_scalar proc~pstickset_custom->proc~sticks_maps_scalar proc~fft_dlay_allocate fft_dlay_allocate proc~pstickset_custom->proc~fft_dlay_allocate proc~sticks_pairup sticks_pairup proc~pstickset_custom->proc~sticks_pairup fftx_error__ fftx_error__ proc~pstickset_custom->fftx_error__ proc~sticks_sort sticks_sort proc~pstickset_custom->proc~sticks_sort proc~sticks_ordered_dist sticks_ordered_dist proc~pstickset_custom->proc~sticks_ordered_dist proc~sticks_countg sticks_countg proc~pstickset_custom->proc~sticks_countg proc~sticks_maps sticks_maps proc~pstickset_custom->proc~sticks_maps proc~fft_dlay_set->fftx_error__ proc~fft_dlay_scalar->fftx_error__ proc~fft_dlay_allocate->fftx_error__ hpsort hpsort proc~sticks_sort->hpsort proc~sticks_countg->fftx_error__ mpi_allreduce mpi_allreduce proc~sticks_maps->mpi_allreduce Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: tk integer, public :: ub (3) integer, public :: lb (3) integer, public, ALLOCATABLE :: stw (:,:) integer, public, ALLOCATABLE :: nstpw (:) integer, public, ALLOCATABLE :: sstpw (:) integer, public :: nstw integer, public :: nstpwx integer, public, ALLOCATABLE :: st (:,:) integer, public, ALLOCATABLE :: nstp (:) integer, public, ALLOCATABLE :: sstp (:) integer, public :: nst integer, public :: nstpx integer, public, ALLOCATABLE :: sts (:,:) integer, public, ALLOCATABLE :: nstps (:) integer, public, ALLOCATABLE :: sstps (:) integer, public :: nsts integer, public, ALLOCATABLE :: ist (:,:) integer, public :: ip integer, public :: ngm_ integer, public :: ngs_ integer, public, ALLOCATABLE :: idx (:)","tags":"","loc":"proc/pstickset_custom.html","title":"pstickset_custom â€“ FFTXlib"},{"text":"private subroutine task_groups_init(dffts) Uses: fft_types Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(inout) :: dffts Calls proc~~task_groups_init~~CallsGraph proc~task_groups_init task_groups_init fftx_error__ fftx_error__ proc~task_groups_init->fftx_error__ proc~task_groups_init_first task_groups_init_first proc~task_groups_init->proc~task_groups_init_first mpi_allgather mpi_allgather proc~task_groups_init->mpi_allgather proc~task_groups_init_first->fftx_error__ mpi_comm_size mpi_comm_size proc~task_groups_init_first->mpi_comm_size mpi_comm_split mpi_comm_split proc~task_groups_init_first->mpi_comm_split mpi_comm_rank mpi_comm_rank proc~task_groups_init_first->mpi_comm_rank Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~task_groups_init~~CalledByGraph proc~task_groups_init task_groups_init proc~pstickset pstickset proc~pstickset->proc~task_groups_init Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: stdout = 6 integer, public :: I integer, public :: IERR integer, public :: num_planes integer, public :: num_sticks integer, public :: nnrsx_vec (dffts%nproc) integer, public :: pgroup (dffts%nproc) integer, public :: strd","tags":"","loc":"proc/task_groups_init.html","title":"task_groups_init â€“ FFTXlib"},{"text":"private subroutine task_groups_init_first(dffts) Uses: fft_types Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(inout) :: dffts Calls proc~~task_groups_init_first~~CallsGraph proc~task_groups_init_first task_groups_init_first fftx_error__ fftx_error__ proc~task_groups_init_first->fftx_error__ mpi_comm_size mpi_comm_size proc~task_groups_init_first->mpi_comm_size mpi_comm_split mpi_comm_split proc~task_groups_init_first->mpi_comm_split mpi_comm_rank mpi_comm_rank proc~task_groups_init_first->mpi_comm_rank Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~task_groups_init_first~~CalledByGraph proc~task_groups_init_first task_groups_init_first proc~task_groups_init task_groups_init proc~task_groups_init->proc~task_groups_init_first proc~pstickset pstickset proc~pstickset->proc~task_groups_init Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n1 integer, public :: ipos integer, public :: color integer, public :: key integer, public :: ierr integer, public :: itsk integer, public :: ntsk integer, public :: pgroup (dffts%nproc)","tags":"","loc":"proc/task_groups_init_first.html","title":"task_groups_init_first â€“ FFTXlib"},{"text":"Interfaces public interface invfft public subroutine invfft_x(grid_type, f, dfft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft public subroutine invfft_b(grid_type, f, dfft, ia) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft integer, intent(in) :: ia public interface fwfft public subroutine fwfft_x(grid_type, f, dfft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: grid_type complex(kind=DP) :: f (:) type(fft_dlay_descriptor), intent(in) :: dfft","tags":"","loc":"module/fft_interfaces.html","title":"fft_interfaces â€“ FFTXlib"},{"text":"Used By module~~fft_parallel~~UsedByGraph module~fft_parallel fft_parallel proc~invfft_b invfft_b module~fft_parallel->proc~invfft_b proc~invfft_x invfft_x module~fft_parallel->proc~invfft_x proc~fwfft_x fwfft_x module~fft_parallel->proc~fwfft_x Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) Subroutines public subroutine tg_cft3s (f, dfft, isgn, use_task_groups) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft integer, intent(in) :: isgn logical, intent(in), optional :: use_task_groups public subroutine fw_tg_cft3_z (f_in, dfft, f_out) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f_in (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_out (:) public subroutine bw_tg_cft3_z (f_out, dfft, f_in) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f_out (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_in (:) public subroutine fw_tg_cft3_scatter (f, dfft, aux) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: aux (:) public subroutine bw_tg_cft3_scatter (f, dfft, aux) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: aux (:) public subroutine fw_tg_cft3_xy (f, dfft) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft public subroutine bw_tg_cft3_xy (f, dfft) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(inout) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft public subroutine pack_group_sticks (f, yf, dfft) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(in) :: f (:) complex(kind=DP), intent(out) :: yf (:) type( fft_dlay_descriptor ), intent(in) :: dfft public subroutine unpack_group_sticks (yf, f, dfft) Arguments Type Intent Optional Attributes Name complex(kind=DP), intent(in) :: yf (:) complex(kind=DP), intent(out) :: f (:) type( fft_dlay_descriptor ), intent(in) :: dfft public subroutine tg_gather (dffts, v, tg_v) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dffts real(kind=DP) :: v (:) real(kind=DP) :: tg_v (:) public subroutine tg_cgather (dffts, v, tg_v) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dffts complex(kind=DP) :: v (:) complex(kind=DP) :: tg_v (:)","tags":"","loc":"module/fft_parallel.html","title":"fft_parallel â€“ FFTXlib"},{"text":"Used By module~~fft_param~~UsedByGraph module~fft_param fft_param proc~good_fft_order good_fft_order module~fft_param->proc~good_fft_order module~fft_scalar~3 fft_scalar module~fft_param->module~fft_scalar~3 module~fft_scalar~2 fft_scalar module~fft_param->module~fft_scalar~2 module~fft_scalar~4 fft_scalar module~fft_param->module~fft_scalar~4 module~fft_scalar~6 fft_scalar module~fft_param->module~fft_scalar~6 module~fft_scalar~5 fft_scalar module~fft_param->module~fft_scalar~5 proc~invfft_b invfft_b module~fft_scalar~5->proc~invfft_b proc~tg_cft3s tg_cft3s module~fft_scalar~5->proc~tg_cft3s proc~bw_tg_cft3_xy bw_tg_cft3_xy module~fft_scalar~5->proc~bw_tg_cft3_xy proc~fw_tg_cft3_z fw_tg_cft3_z module~fft_scalar~5->proc~fw_tg_cft3_z proc~invfft_x invfft_x module~fft_scalar~5->proc~invfft_x proc~bw_tg_cft3_z bw_tg_cft3_z module~fft_scalar~5->proc~bw_tg_cft3_z proc~fw_tg_cft3_xy fw_tg_cft3_xy module~fft_scalar~5->proc~fw_tg_cft3_xy proc~fwfft_x fwfft_x module~fft_scalar~5->proc~fwfft_x Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: nfftx = 2049 Number of different FFT tables that the module\ncould keep into memory without reinitialization integer, public, parameter :: ndims = 3 Max allowed fft dimension","tags":"","loc":"module/fft_param.html","title":"fft_param â€“ FFTXlib"},{"text":"Uses: iso_c_binding MKL_DFTI fft_param module~~fft_scalar~5~~UsesGraph module~fft_scalar~5 fft_scalar MKL_DFTI MKL_DFTI MKL_DFTI->module~fft_scalar~5 iso_c_binding iso_c_binding iso_c_binding->module~fft_scalar~5 module~fft_param fft_param module~fft_param->module~fft_scalar~5 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~fft_scalar~5~~UsedByGraph module~fft_scalar~5 fft_scalar proc~invfft_b invfft_b module~fft_scalar~5->proc~invfft_b proc~tg_cft3s tg_cft3s module~fft_scalar~5->proc~tg_cft3s proc~bw_tg_cft3_xy bw_tg_cft3_xy module~fft_scalar~5->proc~bw_tg_cft3_xy proc~fw_tg_cft3_z fw_tg_cft3_z module~fft_scalar~5->proc~fw_tg_cft3_z proc~invfft_x invfft_x module~fft_scalar~5->proc~invfft_x proc~bw_tg_cft3_z bw_tg_cft3_z module~fft_scalar~5->proc~bw_tg_cft3_z proc~fw_tg_cft3_xy fw_tg_cft3_xy module~fft_scalar~5->proc~fw_tg_cft3_xy proc~fwfft_x fwfft_x module~fft_scalar~5->proc~fwfft_x Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) Derived Types type, private :: dfti_descriptor_array Components Type Visibility Attributes Name Initial type(DFTI_DESCRIPTOR), public, POINTER :: desc Subroutines public subroutine cft_1z (c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) public subroutine cft_2xy (r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) public subroutine cfft3d (f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign public subroutine cfft3ds (f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:)","tags":"","loc":"module/fft_scalar~5.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: iso_c_binding fft_param module~~fft_scalar~2~~UsesGraph module~fft_scalar~2 fft_scalar module~fft_param fft_param module~fft_param->module~fft_scalar~2 iso_c_binding iso_c_binding iso_c_binding->module~fft_scalar~2 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) integer, private, parameter :: lwork = 20000+(2*nfftx+256)*64+3*nfftx real(kind=DP), private :: work (lwork) Subroutines public subroutine cft_1z (c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) public subroutine cft_2xy (r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) public subroutine cfft3d (f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign public subroutine cfft3ds (f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:)","tags":"","loc":"module/fft_scalar~2.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: fft_param module~~fft_scalar~3~~UsesGraph module~fft_scalar~3 fft_scalar module~fft_param fft_param module~fft_param->module~fft_scalar~3 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/fft_scalar~3.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: iso_c_binding fft_param module~~fft_scalar~4~~UsesGraph module~fft_scalar~4 fft_scalar module~fft_param fft_param module~fft_param->module~fft_scalar~4 iso_c_binding iso_c_binding iso_c_binding->module~fft_scalar~4 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) Subroutines public subroutine cft_1z (c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) public subroutine cft_2xy (r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) public subroutine cfft3d (f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign public subroutine cfft3ds (f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:)","tags":"","loc":"module/fft_scalar~4.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: iso_c_binding fft_param module~~fft_scalar~6~~UsesGraph module~fft_scalar~6 fft_scalar module~fft_param fft_param module~fft_param->module~fft_scalar~6 iso_c_binding iso_c_binding iso_c_binding->module~fft_scalar~6 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) Subroutines public subroutine cft_1z (c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) public subroutine cft_2xy (r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) public subroutine cfft3d (f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign public subroutine cfft3ds (f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:)","tags":"","loc":"module/fft_scalar~6.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: iso_c_binding module~~fft_scalar~~UsesGraph module~fft_scalar fft_scalar iso_c_binding iso_c_binding iso_c_binding->module~fft_scalar Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) integer, private, parameter :: ndims = 3 integer, private, parameter :: nfftx = 2049 Subroutines public subroutine cft_1z (c, nsl, nz, ldz, isign, cout) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: c (:) integer, intent(in) :: nsl integer, intent(in) :: nz integer, intent(in) :: ldz integer, intent(in) :: isign complex(kind=DP) :: cout (:) public subroutine cft_2xy (r, nzl, nx, ny, ldx, ldy, isign, pl2ix) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: r (:) integer, intent(in) :: nzl integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: isign integer, intent(in), optional :: pl2ix (:) public subroutine cfft3d (f, nx, ny, nz, ldx, ldy, ldz, isign) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: isign public subroutine cfft3ds (f, nx, ny, nz, ldx, ldy, ldz, isign, do_fft_x, do_fft_y) Arguments Type Intent Optional Attributes Name complex(kind=DP) :: f (ldx*ldy*ldz) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: isign integer :: do_fft_x (:) integer :: do_fft_y (:)","tags":"","loc":"module/fft_scalar.html","title":"fft_scalar â€“ FFTXlib"},{"text":"Uses: iso_c_binding module~~fft_smallbox~~UsesGraph module~fft_smallbox fft_smallbox iso_c_binding iso_c_binding iso_c_binding->module~fft_smallbox Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~fft_smallbox~~UsedByGraph module~fft_smallbox fft_smallbox proc~invfft_b invfft_b module~fft_smallbox->proc~invfft_b proc~invfft_x invfft_x module~fft_smallbox->proc~invfft_x Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: DP = selected_real_kind(14,200) integer, private, parameter :: ndims = 3 integer, private :: cft_b_dims (4) Subroutines public subroutine cft_b (f, nx, ny, nz, ldx, ldy, ldz, imin3, imax3, sgn) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: f (:) integer :: nx integer :: ny integer :: nz integer :: ldx integer :: ldy integer :: ldz integer :: imin3 integer :: imax3 integer :: sgn public subroutine cft_b_omp_init (nx, ny, nz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz public subroutine cft_b_omp (f, nx, ny, nz, ldx, ldy, ldz, imin3, imax3, sgn) Arguments Type Intent Optional Attributes Name complex(kind=dp) :: f (:) integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz integer, intent(in) :: ldx integer, intent(in) :: ldy integer, intent(in) :: ldz integer, intent(in) :: imin3 integer, intent(in) :: imax3 integer, intent(in) :: sgn","tags":"","loc":"module/fft_smallbox.html","title":"fft_smallbox â€“ FFTXlib"},{"text":"Uses: iso_c_binding module~~fft_support~~UsesGraph module~fft_support fft_support iso_c_binding iso_c_binding iso_c_binding->module~fft_support Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200) Functions public function good_fft_dimension (n) Arguments Type Intent Optional Attributes Name integer :: n Return Value integer public function allowed (nr) Arguments Type Intent Optional Attributes Name integer :: nr Return Value logical public function good_fft_order (nr, np) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nr integer, intent(in), optional :: np Return Value integer","tags":"","loc":"module/fft_support.html","title":"fft_support â€“ FFTXlib"},{"text":"Used By module~~fft_types~~UsedByGraph module~fft_types fft_types proc~unpack_group_sticks unpack_group_sticks module~fft_types->proc~unpack_group_sticks proc~bw_tg_cft3_scatter bw_tg_cft3_scatter module~fft_types->proc~bw_tg_cft3_scatter proc~tg_gather tg_gather module~fft_types->proc~tg_gather proc~tg_cft3s tg_cft3s module~fft_types->proc~tg_cft3s proc~task_groups_init task_groups_init module~fft_types->proc~task_groups_init proc~invfft_b invfft_b module~fft_types->proc~invfft_b proc~fw_tg_cft3_z fw_tg_cft3_z module~fft_types->proc~fw_tg_cft3_z proc~invfft_x invfft_x module~fft_types->proc~invfft_x module~stick_set stick_set module~fft_types->module~stick_set proc~bw_tg_cft3_z bw_tg_cft3_z module~fft_types->proc~bw_tg_cft3_z proc~fw_tg_cft3_xy fw_tg_cft3_xy module~fft_types->proc~fw_tg_cft3_xy proc~bw_tg_cft3_xy bw_tg_cft3_xy module~fft_types->proc~bw_tg_cft3_xy module~scatter_mod scatter_mod module~fft_types->module~scatter_mod proc~fw_tg_cft3_scatter fw_tg_cft3_scatter module~fft_types->proc~fw_tg_cft3_scatter proc~tg_cgather tg_cgather module~fft_types->proc~tg_cgather proc~pack_group_sticks pack_group_sticks module~fft_types->proc~pack_group_sticks proc~task_groups_init_first task_groups_init_first module~fft_types->proc~task_groups_init_first proc~fwfft_x fwfft_x module~fft_types->proc~fwfft_x module~scatter_mod->proc~bw_tg_cft3_scatter module~scatter_mod->proc~tg_cft3s module~scatter_mod->proc~fw_tg_cft3_scatter none~fw_scatter fw_scatter module~scatter_mod->none~fw_scatter none~bw_scatter bw_scatter module~scatter_mod->none~bw_scatter Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: stdout = 6 integer, private :: icount = 0 Derived Types type, public :: fft_dlay_descriptor Components Type Visibility Attributes Name Initial integer, public :: nst integer, public, POINTER :: nsp (:) integer, public, POINTER :: nsw (:) integer, public :: nr1 = 0 integer, public :: nr2 = 0 integer, public :: nr3 = 0 integer, public :: nr1x = 0 integer, public :: nr2x = 0 integer, public :: nr3x = 0 integer, public :: npl = 0 integer, public :: nnp = 0 integer, public :: nnr = 0 integer, public, POINTER :: ngl (:) integer, public, POINTER :: nwl (:) integer, public, POINTER :: npp (:) integer, public, POINTER :: ipp (:) integer, public, POINTER :: iss (:) integer, public, POINTER :: isind (:) integer, public, POINTER :: ismap (:) integer, public, POINTER :: iplp (:) integer, public, POINTER :: iplw (:) integer, public :: id integer, public :: tptr integer, public, POINTER :: irb (:,:) integer, public, POINTER :: imin3 (:) integer, public, POINTER :: imax3 (:) integer, public, POINTER :: np3 (:) integer, public :: mype integer, public :: comm integer, public :: nproc integer, public :: root logical, public :: have_task_groups integer, public :: me_pgrp integer, public :: nogrp integer, public :: npgrp integer, public :: ogrp_comm integer, public :: pgrp_comm integer, public, POINTER :: nolist (:) integer, public, POINTER :: nplist (:) integer, public :: tg_nnr integer, public, POINTER :: tg_nsw (:) integer, public, POINTER :: tg_npp (:) integer, public, POINTER :: tg_snd (:) integer, public, POINTER :: tg_rcv (:) integer, public, POINTER :: tg_psdsp (:) integer, public, POINTER :: tg_usdsp (:) integer, public, POINTER :: tg_rdsp (:) Subroutines public subroutine fft_dlay_allocate (desc, mype, root, nproc, comm, nogrp, nx, ny) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp integer, intent(in) :: nx integer, intent(in) :: ny public subroutine fft_dlay_deallocate (desc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc public subroutine fft_box_allocate (desc, mype, root, nproc, comm, nat) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nat public subroutine fft_box_deallocate (desc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc public subroutine fft_dlay_set (desc, tk, nst, nr1, nr2, nr3, nr1x, nr2x, nr3x, ub, lb, idx, in1, in2, ncp, ncpw, ngp, ngpw, st, stw) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc logical, intent(in) :: tk integer, intent(in) :: nst integer, intent(in) :: nr1 integer, intent(in) :: nr2 integer, intent(in) :: nr3 integer, intent(in) :: nr1x integer, intent(in) :: nr2x integer, intent(in) :: nr3x integer, intent(in) :: ub (3) integer, intent(in) :: lb (3) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ncp (:) integer, intent(in) :: ncpw (:) integer, intent(in) :: ngp (:) integer, intent(in) :: ngpw (:) integer, intent(in) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: stw (lb(1):ub(1),lb(2):ub(2)) public subroutine fft_box_set (desc, nr1b, nr2b, nr3b, nr1bx, nr2bx, nr3bx, nat, irb, npp, ipp) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: nr1b integer, intent(in) :: nr2b integer, intent(in) :: nr3b integer, intent(in) :: nr1bx integer, intent(in) :: nr2bx integer, intent(in) :: nr3bx integer, intent(in) :: nat integer, intent(in) :: irb (:,:) integer, intent(in) :: npp (:) integer, intent(in) :: ipp (:) public subroutine fft_dlay_scalar (desc, ub, lb, nr1, nr2, nr3, nr1x, nr2x, nr3x, stw) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ) :: desc integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer :: nr1 integer :: nr2 integer :: nr3 integer :: nr1x integer :: nr2x integer :: nr3x integer, intent(in) :: stw (lb(2):ub(2),lb(3):ub(3))","tags":"","loc":"module/fft_types.html","title":"fft_types â€“ FFTXlib"},{"text":"Uses: fft_types module~~scatter_mod~~UsesGraph module~scatter_mod scatter_mod module~fft_types fft_types module~fft_types->module~scatter_mod Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~scatter_mod~~UsedByGraph module~scatter_mod scatter_mod none~fw_scatter fw_scatter module~scatter_mod->none~fw_scatter proc~bw_tg_cft3_scatter bw_tg_cft3_scatter module~scatter_mod->proc~bw_tg_cft3_scatter proc~tg_cft3s tg_cft3s module~scatter_mod->proc~tg_cft3s proc~fw_tg_cft3_scatter fw_tg_cft3_scatter module~scatter_mod->proc~fw_tg_cft3_scatter none~bw_scatter bw_scatter module~scatter_mod->none~bw_scatter Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200) Interfaces public interface gather_grid private subroutine gather_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine gather_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) public interface scatter_grid private subroutine scatter_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine scatter_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) Subroutines public subroutine fft_scatter (dfft, f_in, nr3x, nxx_, f_aux, ncp_, npp_, isgn, use_tg) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(inout) :: f_in (nxx_) integer, intent(in) :: nr3x integer, intent(in) :: nxx_ complex(kind=DP), intent(inout) :: f_aux (nxx_) integer, intent(in) :: ncp_ (:) integer, intent(in) :: npp_ (:) integer, intent(in) :: isgn logical, intent(in), optional :: use_tg Description f_in = 0.0_DP private subroutine gather_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine gather_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) private subroutine scatter_real_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft real(kind=DP), intent(in) :: f_in (:) real(kind=DP), intent(inout) :: f_out (:) private subroutine scatter_complex_grid (dfft, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfft complex(kind=DP), intent(in) :: f_in (:) complex(kind=DP), intent(inout) :: f_out (:) public subroutine cgather_sym (dfftp, f_in, f_out) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (:) complex(kind=DP) :: f_out (:) public subroutine cgather_sym_many (dfftp, f_in, f_out, nbnd, nbnd_proc, start_nbnd_proc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (dfftp%nnr,nbnd) complex(kind=DP) :: f_out (dfftp%nnp*dfftp%nr3x,nbnd_proc(dfftp%mype+1)) integer :: nbnd integer :: nbnd_proc (dfftp%nproc) integer :: start_nbnd_proc (dfftp%nproc) public subroutine cscatter_sym_many (dfftp, f_in, f_out, target_ibnd, nbnd, nbnd_proc, start_nbnd_proc) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(in) :: dfftp complex(kind=DP) :: f_in (dfftp%nnp*dfftp%nr3x,nbnd_proc(dfftp%mype+1)) complex(kind=DP) :: f_out (dfftp%nnr) integer :: target_ibnd integer :: nbnd integer :: nbnd_proc (dfftp%nproc) integer :: start_nbnd_proc (dfftp%nproc)","tags":"","loc":"module/scatter_mod.html","title":"scatter_mod â€“ FFTXlib"},{"text":"Used By module~~stick_base~~UsedByGraph module~stick_base stick_base module~stick_set stick_set module~stick_base->module~stick_set Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, ALLOCATABLE, TARGET :: sticks_owner (:,:) integer, private, parameter :: DP = selected_real_kind(14,200) Subroutines public subroutine sticks_maps (tk, ub, lb, b1, b2, b3, gcut, gcutw, gcuts, st, stw, sts, me, nproc, comm) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) real(kind=DP), intent(in) :: b1 (:) real(kind=DP), intent(in) :: b2 (:) real(kind=DP), intent(in) :: b3 (:) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gcutw real(kind=DP), intent(in) :: gcuts integer, intent(out) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: sts (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: me integer, intent(in) :: nproc integer, intent(in) :: comm Description ! TO REMOVE BEFORE COMMIT INTO SVN !!! public subroutine sticks_maps_scalar (lgamma, ub, lb, b1, b2, b3, gcutm, gkcut, gcutms, stw, ngm, ngms) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lgamma integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) real(kind=DP), intent(in) :: b1 (:) real(kind=DP), intent(in) :: b2 (:) real(kind=DP), intent(in) :: b3 (:) real(kind=DP), intent(in) :: gcutm real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcutms integer, intent(out) :: stw (lb(2):ub(2),lb(3):ub(3)) integer, intent(out) :: ngm integer, intent(out) :: ngms public subroutine sticks_sort (ngc, ngcw, ngcs, nct, idx, nproc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: idx (:) integer, intent(in) :: nproc Description ! TO REMOVE BEFORE COMMIT INTO SVN !!!\n! TO REMOVE BEFORE COMMIT INTO SVN !!! public subroutine sticks_countg (tk, ub, lb, st, stw, sts, in1, in2, ngc, ngcw, ngcs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: st (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: stw (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: sts (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: in1 (:) integer, intent(out) :: in2 (:) integer, intent(out) :: ngc (:) integer, intent(out) :: ngcw (:) integer, intent(out) :: ngcs (:) public subroutine sticks_dist (tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(out) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc public subroutine sticks_pairup (tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(inout) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(inout) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(inout) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc public subroutine sticks_ordered_dist (tk, ub, lb, idx, in1, in2, ngc, ngcw, ngcs, nct, ncp, ncpw, ncps, ngp, ngpw, ngps, stown, stownw, stowns, nproc) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tk integer, intent(in) :: ub (:) integer, intent(in) :: lb (:) integer, intent(in) :: idx (:) integer, intent(in) :: in1 (:) integer, intent(in) :: in2 (:) integer, intent(in) :: ngc (:) integer, intent(in) :: ngcw (:) integer, intent(in) :: ngcs (:) integer, intent(in) :: nct integer, intent(out) :: ncp (:) integer, intent(out) :: ncpw (:) integer, intent(out) :: ncps (:) integer, intent(out) :: ngp (:) integer, intent(out) :: ngpw (:) integer, intent(out) :: ngps (:) integer, intent(out) :: stown (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stownw (lb(1):ub(1),lb(2):ub(2)) integer, intent(out) :: stowns (lb(1):ub(1),lb(2):ub(2)) integer, intent(in) :: nproc public subroutine sticks_deallocate () Arguments None","tags":"","loc":"module/stick_base.html","title":"stick_base â€“ FFTXlib"},{"text":"Uses: stick_base fft_types module~~stick_set~~UsesGraph module~stick_set stick_set module~stick_base stick_base module~stick_base->module~stick_set module~fft_types fft_types module~fft_types->module~stick_set Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(14,200) Subroutines public subroutine pstickset (gamma_only, bg, gcut, gkcut, gcuts, dfftp, dffts, ngw, ngm, ngs, mype, root, nproc, comm, nogrp_, ionode, stdout, dfft3d) Arguments Type Intent Optional Attributes Name logical, intent(in) :: gamma_only real(kind=DP), intent(in) :: bg (3,3) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcuts type( fft_dlay_descriptor ), intent(inout) :: dfftp type( fft_dlay_descriptor ), intent(inout) :: dffts integer, intent(out) :: ngw integer, intent(out) :: ngm integer, intent(out) :: ngs integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp_ logical, intent(in) :: ionode integer, intent(in) :: stdout type( fft_dlay_descriptor ), intent(inout), optional :: dfft3d public subroutine pstickset_custom (gamma_only, bg, gcut, gkcut, gcuts, dfftp, dffts, ngw, ngm, ngs, mype, root, nproc, comm, nogrp_) Arguments Type Intent Optional Attributes Name logical, intent(in) :: gamma_only real(kind=DP), intent(in) :: bg (3,3) real(kind=DP), intent(in) :: gcut real(kind=DP), intent(in) :: gkcut real(kind=DP), intent(in) :: gcuts type( fft_dlay_descriptor ), intent(inout) :: dfftp type( fft_dlay_descriptor ), intent(inout) :: dffts integer, intent(inout) :: ngw integer, intent(inout) :: ngm integer, intent(inout) :: ngs integer, intent(in) :: mype integer, intent(in) :: root integer, intent(in) :: nproc integer, intent(in) :: comm integer, intent(in) :: nogrp_ private subroutine task_groups_init (dffts) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(inout) :: dffts private subroutine task_groups_init_first (dffts) Arguments Type Intent Optional Attributes Name type( fft_dlay_descriptor ), intent(inout) :: dffts","tags":"","loc":"module/stick_set.html","title":"stick_set â€“ FFTXlib"}]}